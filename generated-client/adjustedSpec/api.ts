/* tslint:disable */
/* eslint-disable */
/**
 * CMS API Specification
 * This is a private API and should only be used by the MCS frontend. All calls will be forwarded to Directus.  For authentication, use a Keycloak JWT token.
 *
 * The version of the OpenAPI document: 9.13.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface Collections
 */
export interface Collections {
    /**
     * The collection key.
     * @type {string}
     * @memberof Collections
     */
    'collection'?: string;
    /**
     * 
     * @type {string}
     * @memberof Collections
     */
    'icon'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Collections
     */
    'note'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Collections
     */
    'display_template'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof Collections
     */
    'hidden'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Collections
     */
    'singleton'?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof Collections
     */
    'translations'?: Array<string> | null;
    /**
     * 
     * @type {string}
     * @memberof Collections
     */
    'archive_field'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof Collections
     */
    'archive_app_filter'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Collections
     */
    'archive_value'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Collections
     */
    'unarchive_value'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Collections
     */
    'sort_field'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Collections
     */
    'accountability'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Collections
     */
    'color'?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof Collections
     */
    'item_duplication_fields'?: Array<string> | null;
    /**
     * 
     * @type {number}
     * @memberof Collections
     */
    'sort'?: number | null;
    /**
     * 
     * @type {CollectionsGroup}
     * @memberof Collections
     */
    'group'?: CollectionsGroup | null;
    /**
     * 
     * @type {string}
     * @memberof Collections
     */
    'collapse'?: string;
    /**
     * 
     * @type {string}
     * @memberof Collections
     */
    'collection_divider'?: string;
    /**
     * 
     * @type {string}
     * @memberof Collections
     */
    'archive_divider'?: string;
    /**
     * 
     * @type {string}
     * @memberof Collections
     */
    'sort_divider'?: string;
    /**
     * 
     * @type {string}
     * @memberof Collections
     */
    'accountability_divider'?: string;
    /**
     * 
     * @type {string}
     * @memberof Collections
     */
    'duplication_divider'?: string;
}
/**
 * @type CollectionsGroup
 * @export
 */
export type CollectionsGroup = Collections | string;

/**
 * 
 * @export
 * @interface CreateItemsAnswerOption200Response
 */
export interface CreateItemsAnswerOption200Response {
    /**
     * 
     * @type {Array<ItemsAnswerOption>}
     * @memberof CreateItemsAnswerOption200Response
     */
    'data'?: Array<ItemsAnswerOption>;
}
/**
 * @type CreateItemsAnswerOptionRequest
 * @export
 */
export type CreateItemsAnswerOptionRequest = Array<ItemsAnswerOption> | ItemsAnswerOption;

/**
 * 
 * @export
 * @interface CreateItemsAnswerOptionTranslation200Response
 */
export interface CreateItemsAnswerOptionTranslation200Response {
    /**
     * 
     * @type {Array<ItemsAnswerOptionTranslation>}
     * @memberof CreateItemsAnswerOptionTranslation200Response
     */
    'data'?: Array<ItemsAnswerOptionTranslation>;
}
/**
 * @type CreateItemsAnswerOptionTranslationRequest
 * @export
 */
export type CreateItemsAnswerOptionTranslationRequest = Array<ItemsAnswerOptionTranslation> | ItemsAnswerOptionTranslation;

/**
 * 
 * @export
 * @interface CreateItemsArticle200Response
 */
export interface CreateItemsArticle200Response {
    /**
     * 
     * @type {Array<ItemsArticle>}
     * @memberof CreateItemsArticle200Response
     */
    'data'?: Array<ItemsArticle>;
}
/**
 * 
 * @export
 * @interface CreateItemsArticleCategory200Response
 */
export interface CreateItemsArticleCategory200Response {
    /**
     * 
     * @type {Array<ItemsArticleCategory>}
     * @memberof CreateItemsArticleCategory200Response
     */
    'data'?: Array<ItemsArticleCategory>;
}
/**
 * @type CreateItemsArticleCategoryRequest
 * @export
 */
export type CreateItemsArticleCategoryRequest = Array<ItemsArticleCategory> | ItemsArticleCategory;

/**
 * @type CreateItemsArticleRequest
 * @export
 */
export type CreateItemsArticleRequest = Array<ItemsArticle> | ItemsArticle;

/**
 * 
 * @export
 * @interface CreateItemsArticleTranslation200Response
 */
export interface CreateItemsArticleTranslation200Response {
    /**
     * 
     * @type {Array<ItemsArticleTranslation>}
     * @memberof CreateItemsArticleTranslation200Response
     */
    'data'?: Array<ItemsArticleTranslation>;
}
/**
 * @type CreateItemsArticleTranslationRequest
 * @export
 */
export type CreateItemsArticleTranslationRequest = Array<ItemsArticleTranslation> | ItemsArticleTranslation;

/**
 * 
 * @export
 * @interface CreateItemsCondition200Response
 */
export interface CreateItemsCondition200Response {
    /**
     * 
     * @type {Array<ItemsCondition>}
     * @memberof CreateItemsCondition200Response
     */
    'data'?: Array<ItemsCondition>;
}
/**
 * 
 * @export
 * @interface CreateItemsConditionFact200Response
 */
export interface CreateItemsConditionFact200Response {
    /**
     * 
     * @type {Array<ItemsConditionFact>}
     * @memberof CreateItemsConditionFact200Response
     */
    'data'?: Array<ItemsConditionFact>;
}
/**
 * @type CreateItemsConditionFactRequest
 * @export
 */
export type CreateItemsConditionFactRequest = Array<ItemsConditionFact> | ItemsConditionFact;

/**
 * @type CreateItemsConditionRequest
 * @export
 */
export type CreateItemsConditionRequest = Array<ItemsCondition> | ItemsCondition;

/**
 * 
 * @export
 * @interface CreateItemsFact200Response
 */
export interface CreateItemsFact200Response {
    /**
     * 
     * @type {Array<ItemsFact>}
     * @memberof CreateItemsFact200Response
     */
    'data'?: Array<ItemsFact>;
}
/**
 * @type CreateItemsFactRequest
 * @export
 */
export type CreateItemsFactRequest = Array<ItemsFact> | ItemsFact;

/**
 * 
 * @export
 * @interface CreateItemsQuestion200Response
 */
export interface CreateItemsQuestion200Response {
    /**
     * 
     * @type {Array<ItemsQuestion>}
     * @memberof CreateItemsQuestion200Response
     */
    'data'?: Array<ItemsQuestion>;
}
/**
 * @type CreateItemsQuestionRequest
 * @export
 */
export type CreateItemsQuestionRequest = Array<ItemsQuestion> | ItemsQuestion;

/**
 * 
 * @export
 * @interface CreateItemsQuestionTranslation200Response
 */
export interface CreateItemsQuestionTranslation200Response {
    /**
     * 
     * @type {Array<ItemsQuestionTranslation>}
     * @memberof CreateItemsQuestionTranslation200Response
     */
    'data'?: Array<ItemsQuestionTranslation>;
}
/**
 * @type CreateItemsQuestionTranslationRequest
 * @export
 */
export type CreateItemsQuestionTranslationRequest = Array<ItemsQuestionTranslation> | ItemsQuestionTranslation;

/**
 * 
 * @export
 * @interface CreateItemsQuestionnaire200Response
 */
export interface CreateItemsQuestionnaire200Response {
    /**
     * 
     * @type {Array<ItemsQuestionnaire>}
     * @memberof CreateItemsQuestionnaire200Response
     */
    'data'?: Array<ItemsQuestionnaire>;
}
/**
 * @type CreateItemsQuestionnaireRequest
 * @export
 */
export type CreateItemsQuestionnaireRequest = Array<ItemsQuestionnaire> | ItemsQuestionnaire;

/**
 * 
 * @export
 * @interface CreateItemsQuestionnaireTranslation200Response
 */
export interface CreateItemsQuestionnaireTranslation200Response {
    /**
     * 
     * @type {Array<ItemsQuestionnaireTranslation>}
     * @memberof CreateItemsQuestionnaireTranslation200Response
     */
    'data'?: Array<ItemsQuestionnaireTranslation>;
}
/**
 * @type CreateItemsQuestionnaireTranslationRequest
 * @export
 */
export type CreateItemsQuestionnaireTranslationRequest = Array<ItemsQuestionnaireTranslation> | ItemsQuestionnaireTranslation;

/**
 * 
 * @export
 * @interface CreateItemsSection200Response
 */
export interface CreateItemsSection200Response {
    /**
     * 
     * @type {Array<ItemsSection>}
     * @memberof CreateItemsSection200Response
     */
    'data'?: Array<ItemsSection>;
}
/**
 * @type CreateItemsSectionRequest
 * @export
 */
export type CreateItemsSectionRequest = Array<ItemsSection> | ItemsSection;

/**
 * 
 * @export
 * @interface CreateItemsSectionTranslation200Response
 */
export interface CreateItemsSectionTranslation200Response {
    /**
     * 
     * @type {Array<ItemsSectionTranslation>}
     * @memberof CreateItemsSectionTranslation200Response
     */
    'data'?: Array<ItemsSectionTranslation>;
}
/**
 * @type CreateItemsSectionTranslationRequest
 * @export
 */
export type CreateItemsSectionTranslationRequest = Array<ItemsSectionTranslation> | ItemsSectionTranslation;

/**
 * 
 * @export
 * @interface CreateItemsVersion200Response
 */
export interface CreateItemsVersion200Response {
    /**
     * 
     * @type {Array<ItemsVersion>}
     * @memberof CreateItemsVersion200Response
     */
    'data'?: Array<ItemsVersion>;
}
/**
 * @type CreateItemsVersionRequest
 * @export
 */
export type CreateItemsVersionRequest = Array<ItemsVersion> | ItemsVersion;

/**
 * 
 * @export
 * @interface ExportRequest
 */
export interface ExportRequest {
    /**
     * What file format to save the export to. One of csv, xml, json
     * @type {string}
     * @memberof ExportRequest
     */
    'format'?: ExportRequestFormatEnum;
    /**
     * 
     * @type {Query}
     * @memberof ExportRequest
     */
    'query'?: Query;
    /**
     * 
     * @type {Files}
     * @memberof ExportRequest
     */
    'file'?: Files;
}

export const ExportRequestFormatEnum = {
    Csv: 'csv',
    Xml: 'xml',
    Json: 'json'
} as const;

export type ExportRequestFormatEnum = typeof ExportRequestFormatEnum[keyof typeof ExportRequestFormatEnum];

/**
 * 
 * @export
 * @interface Fields
 */
export interface Fields {
    /**
     * 
     * @type {number}
     * @memberof Fields
     */
    'id'?: number;
    /**
     * Unique name of the collection this field is in.
     * @type {string}
     * @memberof Fields
     */
    'collection'?: string;
    /**
     * Unique name of the field. Field name is unique within the collection.
     * @type {string}
     * @memberof Fields
     */
    'field'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Fields
     */
    'special'?: Array<string> | null;
    /**
     * 
     * @type {string}
     * @memberof Fields
     */
    'interface'?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof Fields
     */
    'options'?: Array<string> | null;
    /**
     * 
     * @type {string}
     * @memberof Fields
     */
    'display'?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof Fields
     */
    'display_options'?: Array<string> | null;
    /**
     * 
     * @type {boolean}
     * @memberof Fields
     */
    'readonly'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Fields
     */
    'hidden'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Fields
     */
    'sort'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof Fields
     */
    'width'?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof Fields
     */
    'translations'?: Array<string> | null;
    /**
     * 
     * @type {string}
     * @memberof Fields
     */
    'note'?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof Fields
     */
    'conditions'?: Array<string> | null;
    /**
     * 
     * @type {boolean}
     * @memberof Fields
     */
    'required'?: boolean | null;
    /**
     * 
     * @type {FieldsGroup}
     * @memberof Fields
     */
    'group'?: FieldsGroup | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof Fields
     */
    'validation'?: Array<string> | null;
    /**
     * 
     * @type {string}
     * @memberof Fields
     */
    'validation_message'?: string | null;
}
/**
 * @type FieldsGroup
 * @export
 */
export type FieldsGroup = Fields | number;

/**
 * 
 * @export
 * @interface Files
 */
export interface Files {
    /**
     * Unique identifier for the file.
     * @type {string}
     * @memberof Files
     */
    'id'?: string;
    /**
     * Where the file is stored. Either `local` for the local filesystem or the name of the storage adapter (for example `s3`).
     * @type {string}
     * @memberof Files
     */
    'storage'?: string;
    /**
     * Name of the file on disk. By default, Directus uses a random hash for the filename.
     * @type {string}
     * @memberof Files
     */
    'filename_disk'?: string;
    /**
     * How you want to the file to be named when it\'s being downloaded.
     * @type {string}
     * @memberof Files
     */
    'filename_download'?: string;
    /**
     * Title for the file. Is extracted from the filename on upload, but can be edited by the user.
     * @type {string}
     * @memberof Files
     */
    'title'?: string;
    /**
     * MIME type of the file.
     * @type {string}
     * @memberof Files
     */
    'type'?: string;
    /**
     * 
     * @type {FilesFolder}
     * @memberof Files
     */
    'folder'?: FilesFolder | null;
    /**
     * 
     * @type {FilesUploadedBy}
     * @memberof Files
     */
    'uploaded_by'?: FilesUploadedBy;
    /**
     * When the file was uploaded.
     * @type {string}
     * @memberof Files
     */
    'uploaded_on'?: string;
    /**
     * 
     * @type {ItemsAnswerOptionUserCreated}
     * @memberof Files
     */
    'modified_by'?: ItemsAnswerOptionUserCreated | null;
    /**
     * 
     * @type {string}
     * @memberof Files
     */
    'modified_on'?: string;
    /**
     * Character set of the file.
     * @type {string}
     * @memberof Files
     */
    'charset'?: string | null;
    /**
     * Size of the file in bytes.
     * @type {number}
     * @memberof Files
     */
    'filesize'?: number;
    /**
     * Width of the file in pixels. Only applies to images.
     * @type {number}
     * @memberof Files
     */
    'width'?: number | null;
    /**
     * Height of the file in pixels. Only applies to images.
     * @type {number}
     * @memberof Files
     */
    'height'?: number | null;
    /**
     * Duration of the file in seconds. Only applies to audio and video.
     * @type {number}
     * @memberof Files
     */
    'duration'?: number | null;
    /**
     * Where the file was embedded from.
     * @type {string}
     * @memberof Files
     */
    'embed'?: string | null;
    /**
     * Description for the file.
     * @type {string}
     * @memberof Files
     */
    'description'?: string | null;
    /**
     * Where the file was created. Is automatically populated based on EXIF data for images.
     * @type {string}
     * @memberof Files
     */
    'location'?: string | null;
    /**
     * Tags for the file. Is automatically populated based on EXIF data for images.
     * @type {Array<string>}
     * @memberof Files
     */
    'tags'?: Array<string> | null;
    /**
     * IPTC, EXIF, and ICC metadata extracted from file
     * @type {object}
     * @memberof Files
     */
    'metadata'?: object | null;
    /**
     * 
     * @type {string}
     * @memberof Files
     */
    'storage_divider'?: string;
}
/**
 * @type FilesFolder
 * Virtual folder where this file resides in.
 * @export
 */
export type FilesFolder = Folders | string;

/**
 * @type FilesUploadedBy
 * Who uploaded the file.
 * @export
 */
export type FilesUploadedBy = Users | string;

/**
 * 
 * @export
 * @interface Folders
 */
export interface Folders {
    /**
     * Unique identifier for the folder.
     * @type {string}
     * @memberof Folders
     */
    'id'?: string;
    /**
     * Name of the folder.
     * @type {string}
     * @memberof Folders
     */
    'name'?: string;
    /**
     * 
     * @type {FoldersParent}
     * @memberof Folders
     */
    'parent'?: FoldersParent | null;
}
/**
 * @type FoldersParent
 * Unique identifier of the parent folder. This allows for nested folders.
 * @export
 */
export type FoldersParent = Folders | string;

/**
 * 
 * @export
 * @interface GetAsset404Response
 */
export interface GetAsset404Response {
    /**
     * 
     * @type {GetAsset404ResponseError}
     * @memberof GetAsset404Response
     */
    'error'?: GetAsset404ResponseError;
}
/**
 * 
 * @export
 * @interface GetAsset404ResponseError
 */
export interface GetAsset404ResponseError {
    /**
     * 
     * @type {number}
     * @memberof GetAsset404ResponseError
     */
    'code'?: number;
    /**
     * 
     * @type {string}
     * @memberof GetAsset404ResponseError
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface GetCollection200Response
 */
export interface GetCollection200Response {
    /**
     * 
     * @type {Collections}
     * @memberof GetCollection200Response
     */
    'data'?: Collections;
}
/**
 * 
 * @export
 * @interface GetCollectionField200Response
 */
export interface GetCollectionField200Response {
    /**
     * 
     * @type {Fields}
     * @memberof GetCollectionField200Response
     */
    'data'?: Fields;
}
/**
 * 
 * @export
 * @interface GetCollections200Response
 */
export interface GetCollections200Response {
    /**
     * 
     * @type {Array<Collections>}
     * @memberof GetCollections200Response
     */
    'data'?: Array<Collections>;
}
/**
 * 
 * @export
 * @interface GetFields200Response
 */
export interface GetFields200Response {
    /**
     * 
     * @type {Array<Fields>}
     * @memberof GetFields200Response
     */
    'data'?: Array<Fields>;
}
/**
 * 
 * @export
 * @interface GetFile200Response
 */
export interface GetFile200Response {
    /**
     * 
     * @type {Files}
     * @memberof GetFile200Response
     */
    'data'?: Files;
}
/**
 * 
 * @export
 * @interface GetFiles200Response
 */
export interface GetFiles200Response {
    /**
     * 
     * @type {Array<Files>}
     * @memberof GetFiles200Response
     */
    'data'?: Array<Files>;
    /**
     * 
     * @type {XMetadata}
     * @memberof GetFiles200Response
     */
    'meta'?: XMetadata;
}
/**
 * 
 * @export
 * @interface GetFolder200Response
 */
export interface GetFolder200Response {
    /**
     * 
     * @type {Folders}
     * @memberof GetFolder200Response
     */
    'data'?: Folders;
}
/**
 * 
 * @export
 * @interface GetFolders200Response
 */
export interface GetFolders200Response {
    /**
     * 
     * @type {Array<Folders>}
     * @memberof GetFolders200Response
     */
    'data'?: Array<Folders>;
    /**
     * 
     * @type {XMetadata}
     * @memberof GetFolders200Response
     */
    'meta'?: XMetadata;
}
/**
 * 
 * @export
 * @interface GetInterfaces200Response
 */
export interface GetInterfaces200Response {
    /**
     * 
     * @type {Array<object>}
     * @memberof GetInterfaces200Response
     */
    'data'?: Array<object>;
}
/**
 * 
 * @export
 * @interface GetRelation200Response
 */
export interface GetRelation200Response {
    /**
     * 
     * @type {Relations}
     * @memberof GetRelation200Response
     */
    'data'?: Relations;
}
/**
 * 
 * @export
 * @interface GetRelations200Response
 */
export interface GetRelations200Response {
    /**
     * 
     * @type {Array<Relations>}
     * @memberof GetRelations200Response
     */
    'data'?: Array<Relations>;
}
/**
 * 
 * @export
 * @interface GetRole200Response
 */
export interface GetRole200Response {
    /**
     * 
     * @type {Roles}
     * @memberof GetRole200Response
     */
    'data'?: Roles;
}
/**
 * 
 * @export
 * @interface GetRoles200Response
 */
export interface GetRoles200Response {
    /**
     * 
     * @type {Array<Roles>}
     * @memberof GetRoles200Response
     */
    'data'?: Array<Roles>;
    /**
     * 
     * @type {XMetadata}
     * @memberof GetRoles200Response
     */
    'meta'?: XMetadata;
}
/**
 * 
 * @export
 * @interface GetUser200Response
 */
export interface GetUser200Response {
    /**
     * 
     * @type {Users}
     * @memberof GetUser200Response
     */
    'data'?: Users;
}
/**
 * 
 * @export
 * @interface GetUsers200Response
 */
export interface GetUsers200Response {
    /**
     * 
     * @type {Array<Users>}
     * @memberof GetUsers200Response
     */
    'data'?: Array<Users>;
    /**
     * 
     * @type {XMetadata}
     * @memberof GetUsers200Response
     */
    'meta'?: XMetadata;
}
/**
 * 
 * @export
 * @interface HashGenerate200Response
 */
export interface HashGenerate200Response {
    /**
     * 
     * @type {string}
     * @memberof HashGenerate200Response
     */
    'data'?: string;
}
/**
 * 
 * @export
 * @interface HashGenerateRequest
 */
export interface HashGenerateRequest {
    /**
     * String to hash.
     * @type {string}
     * @memberof HashGenerateRequest
     */
    'string'?: string;
}
/**
 * 
 * @export
 * @interface HashVerify200Response
 */
export interface HashVerify200Response {
    /**
     * 
     * @type {boolean}
     * @memberof HashVerify200Response
     */
    'data'?: boolean;
}
/**
 * 
 * @export
 * @interface HashVerifyRequest
 */
export interface HashVerifyRequest {
    /**
     * String to hash.
     * @type {string}
     * @memberof HashVerifyRequest
     */
    'string'?: string;
    /**
     * Hash you want to verify against.
     * @type {string}
     * @memberof HashVerifyRequest
     */
    'hash'?: string;
}
/**
 * 
 * @export
 * @interface ItemsAnswerOption
 */
export interface ItemsAnswerOption {
    /**
     * 
     * @type {string}
     * @memberof ItemsAnswerOption
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ItemsAnswerOption
     */
    'status'?: string | null;
    /**
     * 
     * @type {ItemsAnswerOptionUserCreated}
     * @memberof ItemsAnswerOption
     */
    'userCreated'?: ItemsAnswerOptionUserCreated | null;
    /**
     * 
     * @type {string}
     * @memberof ItemsAnswerOption
     */
    'dateCreated'?: string | null;
    /**
     * 
     * @type {ItemsAnswerOptionUserCreated}
     * @memberof ItemsAnswerOption
     */
    'userUpdated'?: ItemsAnswerOptionUserCreated | null;
    /**
     * 
     * @type {string}
     * @memberof ItemsAnswerOption
     */
    'dateUpdated'?: string | null;
    /**
     * Field to recognise an answer option in directus UI
     * @type {string}
     * @memberof ItemsAnswerOption
     */
    'description'?: string;
    /**
     * 
     * @type {ItemsAnswerOptionFirstValueOperator}
     * @memberof ItemsAnswerOption
     */
    'firstValueOperator'?: ItemsAnswerOptionFirstValueOperator | null;
    /**
     * 
     * @type {number}
     * @memberof ItemsAnswerOption
     */
    'firstValue'?: number | null;
    /**
     * 
     * @type {ItemsAnswerOptionFirstValueOperator}
     * @memberof ItemsAnswerOption
     */
    'secondValueOperator'?: ItemsAnswerOptionFirstValueOperator | null;
    /**
     * 
     * @type {number}
     * @memberof ItemsAnswerOption
     */
    'secondValue'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ItemsAnswerOption
     */
    'oldAnswerSetOptionId'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ItemsAnswerOption
     */
    'oldAnswerSetId'?: number | null;
    /**
     * 
     * @type {ItemsAnswerOptionQuestion}
     * @memberof ItemsAnswerOption
     */
    'question'?: ItemsAnswerOptionQuestion;
    /**
     * 
     * @type {ItemsAnswerOptionFact}
     * @memberof ItemsAnswerOption
     */
    'fact'?: ItemsAnswerOptionFact | null;
    /**
     * 
     * @type {number}
     * @memberof ItemsAnswerOption
     */
    'order'?: number;
    /**
     * 
     * @type {Array<ItemsAnswerOptionTranslationsInner>}
     * @memberof ItemsAnswerOption
     */
    'translations'?: Array<ItemsAnswerOptionTranslationsInner>;
}
/**
 * @type ItemsAnswerOptionFact
 * @export
 */
export type ItemsAnswerOptionFact = ItemsFact | string;

/**
 * @type ItemsAnswerOptionFirstValueOperator
 * @export
 */
export type ItemsAnswerOptionFirstValueOperator = ItemsOperator | string;

/**
 * @type ItemsAnswerOptionQuestion
 * @export
 */
export type ItemsAnswerOptionQuestion = ItemsQuestion | string;

/**
 * 
 * @export
 * @interface ItemsAnswerOptionTranslation
 */
export interface ItemsAnswerOptionTranslation {
    /**
     * 
     * @type {string}
     * @memberof ItemsAnswerOptionTranslation
     */
    'id'?: string;
    /**
     * 
     * @type {ItemsAnswerOptionTranslationAnswerOptionId}
     * @memberof ItemsAnswerOptionTranslation
     */
    'answerOptionId'?: ItemsAnswerOptionTranslationAnswerOptionId | null;
    /**
     * 
     * @type {ItemsAnswerOptionTranslationLanguageId}
     * @memberof ItemsAnswerOptionTranslation
     */
    'languageId'?: ItemsAnswerOptionTranslationLanguageId | null;
    /**
     * Text that is used to show an answer for multiple choice questions
     * @type {string}
     * @memberof ItemsAnswerOptionTranslation
     */
    'label'?: string | null;
    /**
     * Additional information that is part of the answer option, which allows formatting
     * @type {string}
     * @memberof ItemsAnswerOptionTranslation
     */
    'additionalInformation'?: string | null;
}
/**
 * @type ItemsAnswerOptionTranslationAnswerOptionId
 * @export
 */
export type ItemsAnswerOptionTranslationAnswerOptionId = ItemsAnswerOption | string;

/**
 * @type ItemsAnswerOptionTranslationLanguageId
 * @export
 */
export type ItemsAnswerOptionTranslationLanguageId = ItemsLanguage | number;

/**
 * @type ItemsAnswerOptionTranslationsInner
 * @export
 */
export type ItemsAnswerOptionTranslationsInner = ItemsAnswerOptionTranslation | string;

/**
 * @type ItemsAnswerOptionUserCreated
 * @export
 */
export type ItemsAnswerOptionUserCreated = Users | string;

/**
 * 
 * @export
 * @interface ItemsArticle
 */
export interface ItemsArticle {
    /**
     * 
     * @type {string}
     * @memberof ItemsArticle
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ItemsArticle
     */
    'status'?: string | null;
    /**
     * 
     * @type {ItemsAnswerOptionUserCreated}
     * @memberof ItemsArticle
     */
    'userCreated'?: ItemsAnswerOptionUserCreated | null;
    /**
     * 
     * @type {string}
     * @memberof ItemsArticle
     */
    'dateCreated'?: string | null;
    /**
     * 
     * @type {ItemsAnswerOptionUserCreated}
     * @memberof ItemsArticle
     */
    'userUpdated'?: ItemsAnswerOptionUserCreated | null;
    /**
     * 
     * @type {string}
     * @memberof ItemsArticle
     */
    'dateUpdated'?: string | null;
    /**
     * value mainly to better recognise article in directus UI
     * @type {string}
     * @memberof ItemsArticle
     */
    'description'?: string;
    /**
     * User defined value to identify article across environments
     * @type {string}
     * @memberof ItemsArticle
     */
    'key'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof ItemsArticle
     */
    'oldArticleId'?: number | null;
    /**
     * 
     * @type {ItemsArticleArticleCategory}
     * @memberof ItemsArticle
     */
    'articleCategory'?: ItemsArticleArticleCategory | null;
    /**
     * 
     * @type {Array<ItemsArticleTranslationsInner>}
     * @memberof ItemsArticle
     */
    'translations'?: Array<ItemsArticleTranslationsInner>;
}
/**
 * @type ItemsArticleArticleCategory
 * @export
 */
export type ItemsArticleArticleCategory = ItemsArticleCategory | string;

/**
 * 
 * @export
 * @interface ItemsArticleCategory
 */
export interface ItemsArticleCategory {
    /**
     * 
     * @type {string}
     * @memberof ItemsArticleCategory
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ItemsArticleCategory
     */
    'status'?: string | null;
    /**
     * 
     * @type {ItemsAnswerOptionUserCreated}
     * @memberof ItemsArticleCategory
     */
    'userCreated'?: ItemsAnswerOptionUserCreated | null;
    /**
     * 
     * @type {string}
     * @memberof ItemsArticleCategory
     */
    'dateCreated'?: string | null;
    /**
     * 
     * @type {ItemsAnswerOptionUserCreated}
     * @memberof ItemsArticleCategory
     */
    'userUpdated'?: ItemsAnswerOptionUserCreated | null;
    /**
     * 
     * @type {string}
     * @memberof ItemsArticleCategory
     */
    'dateUpdated'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ItemsArticleCategory
     */
    'name'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof ItemsArticleCategory
     */
    'oldArticleCategoryId'?: number | null;
}
/**
 * 
 * @export
 * @interface ItemsArticleTranslation
 */
export interface ItemsArticleTranslation {
    /**
     * 
     * @type {string}
     * @memberof ItemsArticleTranslation
     */
    'id'?: string;
    /**
     * 
     * @type {ItemsArticleTranslationArticleId}
     * @memberof ItemsArticleTranslation
     */
    'articleId'?: ItemsArticleTranslationArticleId | null;
    /**
     * 
     * @type {ItemsAnswerOptionTranslationLanguageId}
     * @memberof ItemsArticleTranslation
     */
    'languageId'?: ItemsAnswerOptionTranslationLanguageId | null;
    /**
     * 
     * @type {string}
     * @memberof ItemsArticleTranslation
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof ItemsArticleTranslation
     */
    'text'?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof ItemsArticleTranslation
     */
    'topTags'?: Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof ItemsArticleTranslation
     */
    'tags'?: Array<string> | null;
    /**
     * 
     * @type {number}
     * @memberof ItemsArticleTranslation
     */
    'oldArticleTranslationId'?: number | null;
}
/**
 * @type ItemsArticleTranslationArticleId
 * @export
 */
export type ItemsArticleTranslationArticleId = ItemsArticle | string;

/**
 * @type ItemsArticleTranslationsInner
 * @export
 */
export type ItemsArticleTranslationsInner = ItemsArticleTranslation | string;

/**
 * 
 * @export
 * @interface ItemsCondition
 */
export interface ItemsCondition {
    /**
     * 
     * @type {string}
     * @memberof ItemsCondition
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ItemsCondition
     */
    'status'?: string | null;
    /**
     * 
     * @type {ItemsAnswerOptionUserCreated}
     * @memberof ItemsCondition
     */
    'userCreated'?: ItemsAnswerOptionUserCreated | null;
    /**
     * 
     * @type {string}
     * @memberof ItemsCondition
     */
    'dateCreated'?: string | null;
    /**
     * 
     * @type {ItemsAnswerOptionUserCreated}
     * @memberof ItemsCondition
     */
    'userUpdated'?: ItemsAnswerOptionUserCreated | null;
    /**
     * 
     * @type {string}
     * @memberof ItemsCondition
     */
    'dateUpdated'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ItemsCondition
     */
    'description'?: string | null;
    /**
     * 
     * @type {ItemsConditionQuestion}
     * @memberof ItemsCondition
     */
    'question'?: ItemsConditionQuestion | null;
    /**
     * 
     * @type {Array<ItemsConditionFactsInner>}
     * @memberof ItemsCondition
     */
    'facts'?: Array<ItemsConditionFactsInner>;
}
/**
 * 
 * @export
 * @interface ItemsConditionFact
 */
export interface ItemsConditionFact {
    /**
     * 
     * @type {string}
     * @memberof ItemsConditionFact
     */
    'id'?: string;
    /**
     * 
     * @type {ItemsConditionFactFact}
     * @memberof ItemsConditionFact
     */
    'fact'?: ItemsConditionFactFact;
    /**
     * 
     * @type {ItemsConditionFactCondition}
     * @memberof ItemsConditionFact
     */
    'condition'?: ItemsConditionFactCondition;
}
/**
 * @type ItemsConditionFactCondition
 * @export
 */
export type ItemsConditionFactCondition = ItemsCondition | string;

/**
 * @type ItemsConditionFactFact
 * @export
 */
export type ItemsConditionFactFact = ItemsFact | string;

/**
 * @type ItemsConditionFactsInner
 * @export
 */
export type ItemsConditionFactsInner = ItemsConditionFact | string;

/**
 * @type ItemsConditionQuestion
 * @export
 */
export type ItemsConditionQuestion = ItemsQuestion | string;

/**
 * 
 * @export
 * @interface ItemsFact
 */
export interface ItemsFact {
    /**
     * Primary key string set by user to define a fact
     * @type {string}
     * @memberof ItemsFact
     */
    'fact'?: string;
    /**
     * 
     * @type {string}
     * @memberof ItemsFact
     */
    'status'?: string | null;
    /**
     * 
     * @type {ItemsAnswerOptionUserCreated}
     * @memberof ItemsFact
     */
    'userCreated'?: ItemsAnswerOptionUserCreated | null;
    /**
     * 
     * @type {string}
     * @memberof ItemsFact
     */
    'dateCreated'?: string | null;
    /**
     * 
     * @type {ItemsAnswerOptionUserCreated}
     * @memberof ItemsFact
     */
    'userUpdated'?: ItemsAnswerOptionUserCreated | null;
    /**
     * 
     * @type {string}
     * @memberof ItemsFact
     */
    'dateUpdated'?: string | null;
    /**
     * Value that gives more explanation on the fact
     * @type {string}
     * @memberof ItemsFact
     */
    'description'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof ItemsFact
     */
    'oldFactId'?: number | null;
}
/**
 * 
 * @export
 * @interface ItemsLanguage
 */
export interface ItemsLanguage {
    /**
     * 
     * @type {number}
     * @memberof ItemsLanguage
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof ItemsLanguage
     */
    'code'?: string;
    /**
     * 
     * @type {string}
     * @memberof ItemsLanguage
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface ItemsMeaning
 */
export interface ItemsMeaning {
    /**
     * 
     * @type {string}
     * @memberof ItemsMeaning
     */
    'meaning'?: string;
}
/**
 * 
 * @export
 * @interface ItemsOperator
 */
export interface ItemsOperator {
    /**
     * 
     * @type {string}
     * @memberof ItemsOperator
     */
    'operator'?: string;
}
/**
 * 
 * @export
 * @interface ItemsQuestion
 */
export interface ItemsQuestion {
    /**
     * 
     * @type {string}
     * @memberof ItemsQuestion
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ItemsQuestion
     */
    'status'?: string | null;
    /**
     * 
     * @type {ItemsAnswerOptionUserCreated}
     * @memberof ItemsQuestion
     */
    'userCreated'?: ItemsAnswerOptionUserCreated | null;
    /**
     * 
     * @type {string}
     * @memberof ItemsQuestion
     */
    'dateCreated'?: string | null;
    /**
     * 
     * @type {ItemsAnswerOptionUserCreated}
     * @memberof ItemsQuestion
     */
    'userUpdated'?: ItemsAnswerOptionUserCreated | null;
    /**
     * 
     * @type {string}
     * @memberof ItemsQuestion
     */
    'dateUpdated'?: string | null;
    /**
     * Value to recognise question mainly within directus UI
     * @type {string}
     * @memberof ItemsQuestion
     */
    'description'?: string;
    /**
     * 
     * @type {number}
     * @memberof ItemsQuestion
     */
    'order'?: number;
    /**
     * Question constraint depend on use case (e.g. minimals answers in multiple choice)
     * @type {number}
     * @memberof ItemsQuestion
     */
    'min'?: number | null;
    /**
     * Question constraint depend on use case (e.g. maximal answers in multiple choice)
     * @type {number}
     * @memberof ItemsQuestion
     */
    'max'?: number | null;
    /**
     * User defined value to identify question across environments
     * @type {string}
     * @memberof ItemsQuestion
     */
    'key'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof ItemsQuestion
     */
    'oldQuestionId'?: number | null;
    /**
     * 
     * @type {ItemsQuestionType}
     * @memberof ItemsQuestion
     */
    'type'?: ItemsQuestionType;
    /**
     * 
     * @type {ItemsQuestionDisplay}
     * @memberof ItemsQuestion
     */
    'display'?: ItemsQuestionDisplay | null;
    /**
     * 
     * @type {ItemsQuestionMeaning}
     * @memberof ItemsQuestion
     */
    'meaning'?: ItemsQuestionMeaning | null;
    /**
     * 
     * @type {ItemsQuestionSection}
     * @memberof ItemsQuestion
     */
    'section'?: ItemsQuestionSection | null;
    /**
     * Translatable fields of question to show question in a questionnaire
     * @type {Array<ItemsQuestionTranslationsInner>}
     * @memberof ItemsQuestion
     */
    'translations'?: Array<ItemsQuestionTranslationsInner>;
    /**
     * Field referencing an answer option for the question
     * @type {Array<ItemsQuestionAnswerOptionsInner>}
     * @memberof ItemsQuestion
     */
    'answerOptions'?: Array<ItemsQuestionAnswerOptionsInner>;
    /**
     * One of the conditions have to be full-filled that it is valid to ask this question in a questionnaire. A condition is a combination of facts. 
     * @type {Array<ItemsQuestionConditionsInner>}
     * @memberof ItemsQuestion
     */
    'conditions'?: Array<ItemsQuestionConditionsInner>;
}
/**
 * @type ItemsQuestionAnswerOptionsInner
 * @export
 */
export type ItemsQuestionAnswerOptionsInner = ItemsAnswerOption | string;

/**
 * @type ItemsQuestionConditionsInner
 * @export
 */
export type ItemsQuestionConditionsInner = ItemsCondition | string;

/**
 * @type ItemsQuestionDisplay
 * Value to be used in frontend applications how to show the question.
 * @export
 */
export type ItemsQuestionDisplay = ItemsQuestiondisplay | string;

/**
 * @type ItemsQuestionMeaning
 * Value to identify question for specialist care questionnaire reporting
 * @export
 */
export type ItemsQuestionMeaning = ItemsMeaning | string;

/**
 * @type ItemsQuestionSection
 * @export
 */
export type ItemsQuestionSection = ItemsSection | string;

/**
 * 
 * @export
 * @interface ItemsQuestionTranslation
 */
export interface ItemsQuestionTranslation {
    /**
     * 
     * @type {string}
     * @memberof ItemsQuestionTranslation
     */
    'id'?: string;
    /**
     * 
     * @type {ItemsConditionQuestion}
     * @memberof ItemsQuestionTranslation
     */
    'questionId'?: ItemsConditionQuestion | null;
    /**
     * 
     * @type {ItemsAnswerOptionTranslationLanguageId}
     * @memberof ItemsQuestionTranslation
     */
    'languageId'?: ItemsAnswerOptionTranslationLanguageId | null;
    /**
     * The actual question shown to the ones hoe answers a questionnaire.
     * @type {string}
     * @memberof ItemsQuestionTranslation
     */
    'text'?: string;
    /**
     * 
     * @type {string}
     * @memberof ItemsQuestionTranslation
     */
    'additionalInformation'?: string | null;
    /**
     * This indicates whether the content for the given language is complete and available
     * @type {boolean}
     * @memberof ItemsQuestionTranslation
     */
    'isEnabled'?: boolean;
}
/**
 * @type ItemsQuestionTranslationsInner
 * @export
 */
export type ItemsQuestionTranslationsInner = ItemsQuestionTranslation | string;

/**
 * @type ItemsQuestionType
 * Value to define sort of question, also has influence on the logic of treating a question.
 * @export
 */
export type ItemsQuestionType = ItemsQuestiontype | string;

/**
 * 
 * @export
 * @interface ItemsQuestiondisplay
 */
export interface ItemsQuestiondisplay {
    /**
     * 
     * @type {string}
     * @memberof ItemsQuestiondisplay
     */
    'display'?: string;
}
/**
 * 
 * @export
 * @interface ItemsQuestionnaire
 */
export interface ItemsQuestionnaire {
    /**
     * 
     * @type {string}
     * @memberof ItemsQuestionnaire
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ItemsQuestionnaire
     */
    'status'?: string | null;
    /**
     * 
     * @type {ItemsAnswerOptionUserCreated}
     * @memberof ItemsQuestionnaire
     */
    'userCreated'?: ItemsAnswerOptionUserCreated | null;
    /**
     * 
     * @type {string}
     * @memberof ItemsQuestionnaire
     */
    'dateCreated'?: string | null;
    /**
     * 
     * @type {ItemsAnswerOptionUserCreated}
     * @memberof ItemsQuestionnaire
     */
    'userUpdated'?: ItemsAnswerOptionUserCreated | null;
    /**
     * 
     * @type {string}
     * @memberof ItemsQuestionnaire
     */
    'dateUpdated'?: string | null;
    /**
     * Value to recognise questionnaire mostly within directus UI
     * @type {string}
     * @memberof ItemsQuestionnaire
     */
    'description'?: string;
    /**
     * User defined value to identify questionnaire across environments
     * @type {string}
     * @memberof ItemsQuestionnaire
     */
    'key'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof ItemsQuestionnaire
     */
    'oldQuestionSetId'?: number | null;
    /**
     * Sections that belong to this questionnaire. Sections contain questions.
     * @type {Array<ItemsQuestionnaireSectionsInner>}
     * @memberof ItemsQuestionnaire
     */
    'sections'?: Array<ItemsQuestionnaireSectionsInner>;
    /**
     * Translatable fields that are used to display actual content
     * @type {Array<ItemsQuestionnaireTranslationsInner>}
     * @memberof ItemsQuestionnaire
     */
    'translations'?: Array<ItemsQuestionnaireTranslationsInner>;
}
/**
 * @type ItemsQuestionnaireSectionsInner
 * @export
 */
export type ItemsQuestionnaireSectionsInner = ItemsSection | string;

/**
 * 
 * @export
 * @interface ItemsQuestionnaireTranslation
 */
export interface ItemsQuestionnaireTranslation {
    /**
     * 
     * @type {string}
     * @memberof ItemsQuestionnaireTranslation
     */
    'id'?: string;
    /**
     * 
     * @type {ItemsQuestionnaireTranslationQuestionnaireId}
     * @memberof ItemsQuestionnaireTranslation
     */
    'questionnaireId'?: ItemsQuestionnaireTranslationQuestionnaireId | null;
    /**
     * 
     * @type {ItemsAnswerOptionTranslationLanguageId}
     * @memberof ItemsQuestionnaireTranslation
     */
    'languageId'?: ItemsAnswerOptionTranslationLanguageId | null;
    /**
     * 
     * @type {string}
     * @memberof ItemsQuestionnaireTranslation
     */
    'label'?: string;
    /**
     * This indicates whether the content for the given language is complete and available
     * @type {boolean}
     * @memberof ItemsQuestionnaireTranslation
     */
    'isEnabled'?: boolean;
}
/**
 * @type ItemsQuestionnaireTranslationQuestionnaireId
 * @export
 */
export type ItemsQuestionnaireTranslationQuestionnaireId = ItemsQuestionnaire | string;

/**
 * @type ItemsQuestionnaireTranslationsInner
 * @export
 */
export type ItemsQuestionnaireTranslationsInner = ItemsQuestionnaireTranslation | string;

/**
 * 
 * @export
 * @interface ItemsQuestiontype
 */
export interface ItemsQuestiontype {
    /**
     * 
     * @type {string}
     * @memberof ItemsQuestiontype
     */
    'type'?: string;
    /**
     * 
     * @type {number}
     * @memberof ItemsQuestiontype
     */
    'oldQuestionTypeId'?: number | null;
}
/**
 * 
 * @export
 * @interface ItemsSection
 */
export interface ItemsSection {
    /**
     * 
     * @type {string}
     * @memberof ItemsSection
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ItemsSection
     */
    'status'?: string | null;
    /**
     * 
     * @type {ItemsAnswerOptionUserCreated}
     * @memberof ItemsSection
     */
    'userCreated'?: ItemsAnswerOptionUserCreated | null;
    /**
     * 
     * @type {string}
     * @memberof ItemsSection
     */
    'dateCreated'?: string | null;
    /**
     * 
     * @type {ItemsAnswerOptionUserCreated}
     * @memberof ItemsSection
     */
    'userUpdated'?: ItemsAnswerOptionUserCreated | null;
    /**
     * 
     * @type {string}
     * @memberof ItemsSection
     */
    'dateUpdated'?: string | null;
    /**
     * Value mainly to better identify the section in directus UI
     * @type {string}
     * @memberof ItemsSection
     */
    'description'?: string;
    /**
     * 
     * @type {number}
     * @memberof ItemsSection
     */
    'order'?: number;
    /**
     * 
     * @type {number}
     * @memberof ItemsSection
     */
    'oldQuestionSectionId'?: number | null;
    /**
     * 
     * @type {ItemsQuestionnaireTranslationQuestionnaireId}
     * @memberof ItemsSection
     */
    'questionnaire'?: ItemsQuestionnaireTranslationQuestionnaireId | null;
    /**
     * 
     * @type {Array<ItemsSectionTranslationsInner>}
     * @memberof ItemsSection
     */
    'translations'?: Array<ItemsSectionTranslationsInner>;
    /**
     * 
     * @type {Array<ItemsSectionQuestionsInner>}
     * @memberof ItemsSection
     */
    'questions'?: Array<ItemsSectionQuestionsInner>;
}
/**
 * @type ItemsSectionQuestionsInner
 * @export
 */
export type ItemsSectionQuestionsInner = ItemsQuestion | string;

/**
 * 
 * @export
 * @interface ItemsSectionTranslation
 */
export interface ItemsSectionTranslation {
    /**
     * 
     * @type {string}
     * @memberof ItemsSectionTranslation
     */
    'id'?: string;
    /**
     * 
     * @type {ItemsQuestionSection}
     * @memberof ItemsSectionTranslation
     */
    'sectionId'?: ItemsQuestionSection | null;
    /**
     * 
     * @type {ItemsAnswerOptionTranslationLanguageId}
     * @memberof ItemsSectionTranslation
     */
    'languageId'?: ItemsAnswerOptionTranslationLanguageId | null;
    /**
     * 
     * @type {string}
     * @memberof ItemsSectionTranslation
     */
    'title'?: string;
}
/**
 * @type ItemsSectionTranslationsInner
 * @export
 */
export type ItemsSectionTranslationsInner = ItemsSectionTranslation | string;

/**
 * 
 * @export
 * @interface ItemsVersion
 */
export interface ItemsVersion {
    /**
     * 
     * @type {string}
     * @memberof ItemsVersion
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ItemsVersion
     */
    'key'?: string;
    /**
     * 
     * @type {ItemsVersionType}
     * @memberof ItemsVersion
     */
    'type'?: ItemsVersionType;
    /**
     * 
     * @type {Array<string>}
     * @memberof ItemsVersion
     */
    'snapshot'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ItemsVersion
     */
    'dateCreated'?: string;
    /**
     * 
     * @type {number}
     * @memberof ItemsVersion
     */
    'number'?: number;
}
/**
 * 
 * @export
 * @interface ItemsVersionContentType
 */
export interface ItemsVersionContentType {
    /**
     * 
     * @type {string}
     * @memberof ItemsVersionContentType
     */
    'type'?: string;
}
/**
 * @type ItemsVersionType
 * @export
 */
export type ItemsVersionType = ItemsVersionContentType | string;

/**
 * 
 * @export
 * @interface Login200Response
 */
export interface Login200Response {
    /**
     * 
     * @type {Login200ResponseData}
     * @memberof Login200Response
     */
    'data'?: Login200ResponseData;
}
/**
 * 
 * @export
 * @interface Login200ResponseData
 */
export interface Login200ResponseData {
    /**
     * 
     * @type {string}
     * @memberof Login200ResponseData
     */
    'access_token'?: string;
    /**
     * 
     * @type {number}
     * @memberof Login200ResponseData
     */
    'expires'?: number;
    /**
     * 
     * @type {string}
     * @memberof Login200ResponseData
     */
    'refresh_token'?: string;
}
/**
 * 
 * @export
 * @interface LoginRequest
 */
export interface LoginRequest {
    /**
     * Email address of the user you\'re retrieving the access token for.
     * @type {string}
     * @memberof LoginRequest
     */
    'email': string;
    /**
     * Password of the user.
     * @type {string}
     * @memberof LoginRequest
     */
    'password': string;
    /**
     * Choose between retrieving the token as a string, or setting it as a cookie.
     * @type {string}
     * @memberof LoginRequest
     */
    'mode'?: LoginRequestModeEnum;
    /**
     * If 2FA is enabled, you need to pass the one time password.
     * @type {string}
     * @memberof LoginRequest
     */
    'otp'?: string;
}

export const LoginRequestModeEnum = {
    Json: 'json',
    Cookie: 'cookie'
} as const;

export type LoginRequestModeEnum = typeof LoginRequestModeEnum[keyof typeof LoginRequestModeEnum];

/**
 * 
 * @export
 * @interface LogoutRequest
 */
export interface LogoutRequest {
    /**
     * JWT access token you want to logout.
     * @type {string}
     * @memberof LogoutRequest
     */
    'refresh_token'?: string;
}
/**
 * 
 * @export
 * @interface Oauth200Response
 */
export interface Oauth200Response {
    /**
     * 
     * @type {boolean}
     * @memberof Oauth200Response
     */
    'public'?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof Oauth200Response
     */
    'data'?: Array<string>;
}
/**
 * 
 * @export
 * @interface OauthProvider200Response
 */
export interface OauthProvider200Response {
    /**
     * 
     * @type {boolean}
     * @memberof OauthProvider200Response
     */
    'public'?: boolean;
    /**
     * 
     * @type {OauthProvider200ResponseData}
     * @memberof OauthProvider200Response
     */
    'data'?: OauthProvider200ResponseData;
}
/**
 * 
 * @export
 * @interface OauthProvider200ResponseData
 */
export interface OauthProvider200ResponseData {
    /**
     * 
     * @type {string}
     * @memberof OauthProvider200ResponseData
     */
    'token'?: string;
}
/**
 * 
 * @export
 * @interface PasswordRequestRequest
 */
export interface PasswordRequestRequest {
    /**
     * Email address of the user you\'re requesting a reset for.
     * @type {string}
     * @memberof PasswordRequestRequest
     */
    'email': string;
}
/**
 * 
 * @export
 * @interface PasswordResetRequest
 */
export interface PasswordResetRequest {
    /**
     * One-time use JWT token that is used to verify the user.
     * @type {string}
     * @memberof PasswordResetRequest
     */
    'token': string;
    /**
     * New password for the user.
     * @type {string}
     * @memberof PasswordResetRequest
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface Query
 */
export interface Query {
    /**
     * Control what fields are being returned in the object.
     * @type {Array<string>}
     * @memberof Query
     */
    'fields'?: Array<string>;
    /**
     * 
     * @type {object}
     * @memberof Query
     */
    'filter'?: object;
    /**
     * Filter by items that contain the given search query in one of their fields.
     * @type {string}
     * @memberof Query
     */
    'search'?: string;
    /**
     * How to sort the returned items.
     * @type {Array<string>}
     * @memberof Query
     */
    'sort'?: Array<string>;
    /**
     * Set the maximum number of items that will be returned
     * @type {number}
     * @memberof Query
     */
    'limit'?: number;
    /**
     * How many items to skip when fetching data.
     * @type {number}
     * @memberof Query
     */
    'offset'?: number;
    /**
     * Cursor for use in pagination. Often used in combination with limit.
     * @type {number}
     * @memberof Query
     */
    'page'?: number;
    /**
     * Deep allows you to set any of the other query parameters on a nested relational dataset.
     * @type {object}
     * @memberof Query
     */
    'deep'?: object;
}
/**
 * 
 * @export
 * @interface Random200Response
 */
export interface Random200Response {
    /**
     * 
     * @type {string}
     * @memberof Random200Response
     */
    'data'?: string;
}
/**
 * 
 * @export
 * @interface ReadItemsAnswerOption200Response
 */
export interface ReadItemsAnswerOption200Response {
    /**
     * 
     * @type {Array<ItemsAnswerOption>}
     * @memberof ReadItemsAnswerOption200Response
     */
    'data'?: Array<ItemsAnswerOption>;
    /**
     * 
     * @type {XMetadata}
     * @memberof ReadItemsAnswerOption200Response
     */
    'meta'?: XMetadata;
}
/**
 * 
 * @export
 * @interface ReadItemsAnswerOptionTranslation200Response
 */
export interface ReadItemsAnswerOptionTranslation200Response {
    /**
     * 
     * @type {Array<ItemsAnswerOptionTranslation>}
     * @memberof ReadItemsAnswerOptionTranslation200Response
     */
    'data'?: Array<ItemsAnswerOptionTranslation>;
    /**
     * 
     * @type {XMetadata}
     * @memberof ReadItemsAnswerOptionTranslation200Response
     */
    'meta'?: XMetadata;
}
/**
 * 
 * @export
 * @interface ReadItemsArticle200Response
 */
export interface ReadItemsArticle200Response {
    /**
     * 
     * @type {Array<ItemsArticle>}
     * @memberof ReadItemsArticle200Response
     */
    'data'?: Array<ItemsArticle>;
    /**
     * 
     * @type {XMetadata}
     * @memberof ReadItemsArticle200Response
     */
    'meta'?: XMetadata;
}
/**
 * 
 * @export
 * @interface ReadItemsArticleCategory200Response
 */
export interface ReadItemsArticleCategory200Response {
    /**
     * 
     * @type {Array<ItemsArticleCategory>}
     * @memberof ReadItemsArticleCategory200Response
     */
    'data'?: Array<ItemsArticleCategory>;
    /**
     * 
     * @type {XMetadata}
     * @memberof ReadItemsArticleCategory200Response
     */
    'meta'?: XMetadata;
}
/**
 * 
 * @export
 * @interface ReadItemsArticleTranslation200Response
 */
export interface ReadItemsArticleTranslation200Response {
    /**
     * 
     * @type {Array<ItemsArticleTranslation>}
     * @memberof ReadItemsArticleTranslation200Response
     */
    'data'?: Array<ItemsArticleTranslation>;
    /**
     * 
     * @type {XMetadata}
     * @memberof ReadItemsArticleTranslation200Response
     */
    'meta'?: XMetadata;
}
/**
 * 
 * @export
 * @interface ReadItemsCondition200Response
 */
export interface ReadItemsCondition200Response {
    /**
     * 
     * @type {Array<ItemsCondition>}
     * @memberof ReadItemsCondition200Response
     */
    'data'?: Array<ItemsCondition>;
    /**
     * 
     * @type {XMetadata}
     * @memberof ReadItemsCondition200Response
     */
    'meta'?: XMetadata;
}
/**
 * 
 * @export
 * @interface ReadItemsConditionFact200Response
 */
export interface ReadItemsConditionFact200Response {
    /**
     * 
     * @type {Array<ItemsConditionFact>}
     * @memberof ReadItemsConditionFact200Response
     */
    'data'?: Array<ItemsConditionFact>;
    /**
     * 
     * @type {XMetadata}
     * @memberof ReadItemsConditionFact200Response
     */
    'meta'?: XMetadata;
}
/**
 * 
 * @export
 * @interface ReadItemsFact200Response
 */
export interface ReadItemsFact200Response {
    /**
     * 
     * @type {Array<ItemsFact>}
     * @memberof ReadItemsFact200Response
     */
    'data'?: Array<ItemsFact>;
    /**
     * 
     * @type {XMetadata}
     * @memberof ReadItemsFact200Response
     */
    'meta'?: XMetadata;
}
/**
 * 
 * @export
 * @interface ReadItemsLanguage200Response
 */
export interface ReadItemsLanguage200Response {
    /**
     * 
     * @type {Array<ItemsLanguage>}
     * @memberof ReadItemsLanguage200Response
     */
    'data'?: Array<ItemsLanguage>;
    /**
     * 
     * @type {XMetadata}
     * @memberof ReadItemsLanguage200Response
     */
    'meta'?: XMetadata;
}
/**
 * 
 * @export
 * @interface ReadItemsMeaning200Response
 */
export interface ReadItemsMeaning200Response {
    /**
     * 
     * @type {Array<ItemsMeaning>}
     * @memberof ReadItemsMeaning200Response
     */
    'data'?: Array<ItemsMeaning>;
    /**
     * 
     * @type {XMetadata}
     * @memberof ReadItemsMeaning200Response
     */
    'meta'?: XMetadata;
}
/**
 * 
 * @export
 * @interface ReadItemsOperator200Response
 */
export interface ReadItemsOperator200Response {
    /**
     * 
     * @type {Array<ItemsOperator>}
     * @memberof ReadItemsOperator200Response
     */
    'data'?: Array<ItemsOperator>;
    /**
     * 
     * @type {XMetadata}
     * @memberof ReadItemsOperator200Response
     */
    'meta'?: XMetadata;
}
/**
 * 
 * @export
 * @interface ReadItemsQuestion200Response
 */
export interface ReadItemsQuestion200Response {
    /**
     * 
     * @type {Array<ItemsQuestion>}
     * @memberof ReadItemsQuestion200Response
     */
    'data'?: Array<ItemsQuestion>;
    /**
     * 
     * @type {XMetadata}
     * @memberof ReadItemsQuestion200Response
     */
    'meta'?: XMetadata;
}
/**
 * 
 * @export
 * @interface ReadItemsQuestionTranslation200Response
 */
export interface ReadItemsQuestionTranslation200Response {
    /**
     * 
     * @type {Array<ItemsQuestionTranslation>}
     * @memberof ReadItemsQuestionTranslation200Response
     */
    'data'?: Array<ItemsQuestionTranslation>;
    /**
     * 
     * @type {XMetadata}
     * @memberof ReadItemsQuestionTranslation200Response
     */
    'meta'?: XMetadata;
}
/**
 * 
 * @export
 * @interface ReadItemsQuestiondisplay200Response
 */
export interface ReadItemsQuestiondisplay200Response {
    /**
     * 
     * @type {Array<ItemsQuestiondisplay>}
     * @memberof ReadItemsQuestiondisplay200Response
     */
    'data'?: Array<ItemsQuestiondisplay>;
    /**
     * 
     * @type {XMetadata}
     * @memberof ReadItemsQuestiondisplay200Response
     */
    'meta'?: XMetadata;
}
/**
 * 
 * @export
 * @interface ReadItemsQuestionnaire200Response
 */
export interface ReadItemsQuestionnaire200Response {
    /**
     * 
     * @type {Array<ItemsQuestionnaire>}
     * @memberof ReadItemsQuestionnaire200Response
     */
    'data'?: Array<ItemsQuestionnaire>;
    /**
     * 
     * @type {XMetadata}
     * @memberof ReadItemsQuestionnaire200Response
     */
    'meta'?: XMetadata;
}
/**
 * 
 * @export
 * @interface ReadItemsQuestionnaireTranslation200Response
 */
export interface ReadItemsQuestionnaireTranslation200Response {
    /**
     * 
     * @type {Array<ItemsQuestionnaireTranslation>}
     * @memberof ReadItemsQuestionnaireTranslation200Response
     */
    'data'?: Array<ItemsQuestionnaireTranslation>;
    /**
     * 
     * @type {XMetadata}
     * @memberof ReadItemsQuestionnaireTranslation200Response
     */
    'meta'?: XMetadata;
}
/**
 * 
 * @export
 * @interface ReadItemsQuestiontype200Response
 */
export interface ReadItemsQuestiontype200Response {
    /**
     * 
     * @type {Array<ItemsQuestiontype>}
     * @memberof ReadItemsQuestiontype200Response
     */
    'data'?: Array<ItemsQuestiontype>;
    /**
     * 
     * @type {XMetadata}
     * @memberof ReadItemsQuestiontype200Response
     */
    'meta'?: XMetadata;
}
/**
 * 
 * @export
 * @interface ReadItemsSection200Response
 */
export interface ReadItemsSection200Response {
    /**
     * 
     * @type {Array<ItemsSection>}
     * @memberof ReadItemsSection200Response
     */
    'data'?: Array<ItemsSection>;
    /**
     * 
     * @type {XMetadata}
     * @memberof ReadItemsSection200Response
     */
    'meta'?: XMetadata;
}
/**
 * 
 * @export
 * @interface ReadItemsSectionTranslation200Response
 */
export interface ReadItemsSectionTranslation200Response {
    /**
     * 
     * @type {Array<ItemsSectionTranslation>}
     * @memberof ReadItemsSectionTranslation200Response
     */
    'data'?: Array<ItemsSectionTranslation>;
    /**
     * 
     * @type {XMetadata}
     * @memberof ReadItemsSectionTranslation200Response
     */
    'meta'?: XMetadata;
}
/**
 * 
 * @export
 * @interface ReadItemsVersion200Response
 */
export interface ReadItemsVersion200Response {
    /**
     * 
     * @type {Array<ItemsVersion>}
     * @memberof ReadItemsVersion200Response
     */
    'data'?: Array<ItemsVersion>;
    /**
     * 
     * @type {XMetadata}
     * @memberof ReadItemsVersion200Response
     */
    'meta'?: XMetadata;
}
/**
 * 
 * @export
 * @interface ReadItemsVersionContentType200Response
 */
export interface ReadItemsVersionContentType200Response {
    /**
     * 
     * @type {Array<ItemsVersionContentType>}
     * @memberof ReadItemsVersionContentType200Response
     */
    'data'?: Array<ItemsVersionContentType>;
    /**
     * 
     * @type {XMetadata}
     * @memberof ReadItemsVersionContentType200Response
     */
    'meta'?: XMetadata;
}
/**
 * 
 * @export
 * @interface ReadSingleItemsAnswerOption200Response
 */
export interface ReadSingleItemsAnswerOption200Response {
    /**
     * 
     * @type {ItemsAnswerOption}
     * @memberof ReadSingleItemsAnswerOption200Response
     */
    'data'?: ItemsAnswerOption;
}
/**
 * @type ReadSingleItemsAnswerOptionIdParameter
 * @export
 */
export type ReadSingleItemsAnswerOptionIdParameter = number | string;

/**
 * 
 * @export
 * @interface ReadSingleItemsAnswerOptionTranslation200Response
 */
export interface ReadSingleItemsAnswerOptionTranslation200Response {
    /**
     * 
     * @type {ItemsAnswerOptionTranslation}
     * @memberof ReadSingleItemsAnswerOptionTranslation200Response
     */
    'data'?: ItemsAnswerOptionTranslation;
}
/**
 * 
 * @export
 * @interface ReadSingleItemsArticle200Response
 */
export interface ReadSingleItemsArticle200Response {
    /**
     * 
     * @type {ItemsArticle}
     * @memberof ReadSingleItemsArticle200Response
     */
    'data'?: ItemsArticle;
}
/**
 * 
 * @export
 * @interface ReadSingleItemsArticleCategory200Response
 */
export interface ReadSingleItemsArticleCategory200Response {
    /**
     * 
     * @type {ItemsArticleCategory}
     * @memberof ReadSingleItemsArticleCategory200Response
     */
    'data'?: ItemsArticleCategory;
}
/**
 * 
 * @export
 * @interface ReadSingleItemsArticleTranslation200Response
 */
export interface ReadSingleItemsArticleTranslation200Response {
    /**
     * 
     * @type {ItemsArticleTranslation}
     * @memberof ReadSingleItemsArticleTranslation200Response
     */
    'data'?: ItemsArticleTranslation;
}
/**
 * 
 * @export
 * @interface ReadSingleItemsCondition200Response
 */
export interface ReadSingleItemsCondition200Response {
    /**
     * 
     * @type {ItemsCondition}
     * @memberof ReadSingleItemsCondition200Response
     */
    'data'?: ItemsCondition;
}
/**
 * 
 * @export
 * @interface ReadSingleItemsConditionFact200Response
 */
export interface ReadSingleItemsConditionFact200Response {
    /**
     * 
     * @type {ItemsConditionFact}
     * @memberof ReadSingleItemsConditionFact200Response
     */
    'data'?: ItemsConditionFact;
}
/**
 * 
 * @export
 * @interface ReadSingleItemsFact200Response
 */
export interface ReadSingleItemsFact200Response {
    /**
     * 
     * @type {ItemsFact}
     * @memberof ReadSingleItemsFact200Response
     */
    'data'?: ItemsFact;
}
/**
 * 
 * @export
 * @interface ReadSingleItemsLanguage200Response
 */
export interface ReadSingleItemsLanguage200Response {
    /**
     * 
     * @type {ItemsLanguage}
     * @memberof ReadSingleItemsLanguage200Response
     */
    'data'?: ItemsLanguage;
}
/**
 * 
 * @export
 * @interface ReadSingleItemsMeaning200Response
 */
export interface ReadSingleItemsMeaning200Response {
    /**
     * 
     * @type {ItemsMeaning}
     * @memberof ReadSingleItemsMeaning200Response
     */
    'data'?: ItemsMeaning;
}
/**
 * 
 * @export
 * @interface ReadSingleItemsOperator200Response
 */
export interface ReadSingleItemsOperator200Response {
    /**
     * 
     * @type {ItemsOperator}
     * @memberof ReadSingleItemsOperator200Response
     */
    'data'?: ItemsOperator;
}
/**
 * 
 * @export
 * @interface ReadSingleItemsQuestion200Response
 */
export interface ReadSingleItemsQuestion200Response {
    /**
     * 
     * @type {ItemsQuestion}
     * @memberof ReadSingleItemsQuestion200Response
     */
    'data'?: ItemsQuestion;
}
/**
 * 
 * @export
 * @interface ReadSingleItemsQuestionTranslation200Response
 */
export interface ReadSingleItemsQuestionTranslation200Response {
    /**
     * 
     * @type {ItemsQuestionTranslation}
     * @memberof ReadSingleItemsQuestionTranslation200Response
     */
    'data'?: ItemsQuestionTranslation;
}
/**
 * 
 * @export
 * @interface ReadSingleItemsQuestiondisplay200Response
 */
export interface ReadSingleItemsQuestiondisplay200Response {
    /**
     * 
     * @type {ItemsQuestiondisplay}
     * @memberof ReadSingleItemsQuestiondisplay200Response
     */
    'data'?: ItemsQuestiondisplay;
}
/**
 * 
 * @export
 * @interface ReadSingleItemsQuestionnaire200Response
 */
export interface ReadSingleItemsQuestionnaire200Response {
    /**
     * 
     * @type {ItemsQuestionnaire}
     * @memberof ReadSingleItemsQuestionnaire200Response
     */
    'data'?: ItemsQuestionnaire;
}
/**
 * 
 * @export
 * @interface ReadSingleItemsQuestionnaireTranslation200Response
 */
export interface ReadSingleItemsQuestionnaireTranslation200Response {
    /**
     * 
     * @type {ItemsQuestionnaireTranslation}
     * @memberof ReadSingleItemsQuestionnaireTranslation200Response
     */
    'data'?: ItemsQuestionnaireTranslation;
}
/**
 * 
 * @export
 * @interface ReadSingleItemsQuestiontype200Response
 */
export interface ReadSingleItemsQuestiontype200Response {
    /**
     * 
     * @type {ItemsQuestiontype}
     * @memberof ReadSingleItemsQuestiontype200Response
     */
    'data'?: ItemsQuestiontype;
}
/**
 * 
 * @export
 * @interface ReadSingleItemsSection200Response
 */
export interface ReadSingleItemsSection200Response {
    /**
     * 
     * @type {ItemsSection}
     * @memberof ReadSingleItemsSection200Response
     */
    'data'?: ItemsSection;
}
/**
 * 
 * @export
 * @interface ReadSingleItemsSectionTranslation200Response
 */
export interface ReadSingleItemsSectionTranslation200Response {
    /**
     * 
     * @type {ItemsSectionTranslation}
     * @memberof ReadSingleItemsSectionTranslation200Response
     */
    'data'?: ItemsSectionTranslation;
}
/**
 * 
 * @export
 * @interface ReadSingleItemsVersion200Response
 */
export interface ReadSingleItemsVersion200Response {
    /**
     * 
     * @type {ItemsVersion}
     * @memberof ReadSingleItemsVersion200Response
     */
    'data'?: ItemsVersion;
}
/**
 * 
 * @export
 * @interface ReadSingleItemsVersionContentType200Response
 */
export interface ReadSingleItemsVersionContentType200Response {
    /**
     * 
     * @type {ItemsVersionContentType}
     * @memberof ReadSingleItemsVersionContentType200Response
     */
    'data'?: ItemsVersionContentType;
}
/**
 * 
 * @export
 * @interface Refresh200Response
 */
export interface Refresh200Response {
    /**
     * 
     * @type {Refresh200ResponseData}
     * @memberof Refresh200Response
     */
    'data'?: Refresh200ResponseData;
}
/**
 * 
 * @export
 * @interface Refresh200ResponseData
 */
export interface Refresh200ResponseData {
    /**
     * 
     * @type {string}
     * @memberof Refresh200ResponseData
     */
    'access_token'?: string;
    /**
     * 
     * @type {number}
     * @memberof Refresh200ResponseData
     */
    'expires'?: number;
    /**
     * 
     * @type {string}
     * @memberof Refresh200ResponseData
     */
    'refresh_token'?: string;
}
/**
 * 
 * @export
 * @interface RefreshRequest
 */
export interface RefreshRequest {
    /**
     * JWT access token you want to refresh. This token can\'t be expired.
     * @type {string}
     * @memberof RefreshRequest
     */
    'refresh_token'?: string;
}
/**
 * 
 * @export
 * @interface Relations
 */
export interface Relations {
    /**
     * Unique identifier for the relation.
     * @type {number}
     * @memberof Relations
     */
    'id'?: number;
    /**
     * Collection that has the field that holds the foreign key.
     * @type {string}
     * @memberof Relations
     */
    'many_collection'?: string;
    /**
     * Foreign key. Field that holds the primary key of the related collection.
     * @type {string}
     * @memberof Relations
     */
    'many_field'?: string;
    /**
     * Collection on the _one_ side of the relationship.
     * @type {string}
     * @memberof Relations
     */
    'one_collection'?: string;
    /**
     * Alias column that serves as the _one_ side of the relationship.
     * @type {string}
     * @memberof Relations
     */
    'one_field'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Relations
     */
    'one_collection_field'?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof Relations
     */
    'one_allowed_collections'?: Array<string> | null;
    /**
     * Field on the junction table that holds the many field of the related relation.
     * @type {string}
     * @memberof Relations
     */
    'junction_field'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Relations
     */
    'sort_field'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Relations
     */
    'one_deselect_action'?: string;
}
/**
 * 
 * @export
 * @interface Roles
 */
export interface Roles {
    /**
     * Unique identifier for the role.
     * @type {string}
     * @memberof Roles
     */
    'id'?: string;
    /**
     * Name of the role.
     * @type {string}
     * @memberof Roles
     */
    'name'?: string;
    /**
     * The role\'s icon.
     * @type {string}
     * @memberof Roles
     */
    'icon'?: string;
    /**
     * Description of the role.
     * @type {string}
     * @memberof Roles
     */
    'description'?: string | null;
    /**
     * Array of IP addresses that are allowed to connect to the API as a user of this role.
     * @type {Array<string>}
     * @memberof Roles
     */
    'ip_access'?: Array<string>;
    /**
     * Whether or not this role enforces the use of 2FA.
     * @type {boolean}
     * @memberof Roles
     */
    'enforce_tfa'?: boolean;
    /**
     * Admin role. If true, skips all permission checks.
     * @type {boolean}
     * @memberof Roles
     */
    'admin_access'?: boolean;
    /**
     * The users in the role are allowed to use the app.
     * @type {boolean}
     * @memberof Roles
     */
    'app_access'?: boolean;
    /**
     * 
     * @type {Array<RolesUsersInner>}
     * @memberof Roles
     */
    'users'?: Array<RolesUsersInner>;
}
/**
 * @type RolesUsersInner
 * @export
 */
export type RolesUsersInner = Users | string;

/**
 * 
 * @export
 * @interface ServerInfo200Response
 */
export interface ServerInfo200Response {
    /**
     * 
     * @type {object}
     * @memberof ServerInfo200Response
     */
    'data'?: object;
}
/**
 * 
 * @export
 * @interface SortRequest
 */
export interface SortRequest {
    /**
     * Primary key of item to move
     * @type {number}
     * @memberof SortRequest
     */
    'item'?: number;
    /**
     * Primary key of item where to move the current item to
     * @type {number}
     * @memberof SortRequest
     */
    'to'?: number;
}
/**
 * 
 * @export
 * @interface Users
 */
export interface Users {
    /**
     * Unique identifier for the user.
     * @type {string}
     * @memberof Users
     */
    'id'?: string;
    /**
     * First name of the user.
     * @type {string}
     * @memberof Users
     */
    'first_name'?: string;
    /**
     * Last name of the user.
     * @type {string}
     * @memberof Users
     */
    'last_name'?: string;
    /**
     * Unique email address for the user.
     * @type {string}
     * @memberof Users
     */
    'email'?: string;
    /**
     * Password of the user.
     * @type {string}
     * @memberof Users
     */
    'password'?: string;
    /**
     * The user\'s location.
     * @type {string}
     * @memberof Users
     */
    'location'?: string | null;
    /**
     * The user\'s title.
     * @type {string}
     * @memberof Users
     */
    'title'?: string | null;
    /**
     * The user\'s description.
     * @type {string}
     * @memberof Users
     */
    'description'?: string | null;
    /**
     * The user\'s tags.
     * @type {Array<string>}
     * @memberof Users
     */
    'tags'?: Array<string> | null;
    /**
     * 
     * @type {UsersAvatar}
     * @memberof Users
     */
    'avatar'?: UsersAvatar | null;
    /**
     * The user\'s language used in Directus.
     * @type {string}
     * @memberof Users
     */
    'language'?: string;
    /**
     * What theme the user is using.
     * @type {string}
     * @memberof Users
     */
    'theme'?: UsersThemeEnum;
    /**
     * The 2FA secret string that\'s used to generate one time passwords.
     * @type {string}
     * @memberof Users
     */
    'tfa_secret'?: string | null;
    /**
     * Status of the user.
     * @type {string}
     * @memberof Users
     */
    'status'?: UsersStatusEnum;
    /**
     * 
     * @type {UsersRole}
     * @memberof Users
     */
    'role'?: UsersRole;
    /**
     * Static token for the user.
     * @type {string}
     * @memberof Users
     */
    'token'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Users
     */
    'last_access'?: string | null;
    /**
     * Last page that the user was on.
     * @type {string}
     * @memberof Users
     */
    'last_page'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Users
     */
    'provider'?: string;
    /**
     * 
     * @type {string}
     * @memberof Users
     */
    'external_identifier'?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof Users
     */
    'auth_data'?: Array<string> | null;
    /**
     * 
     * @type {boolean}
     * @memberof Users
     */
    'email_notifications'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof Users
     */
    'preferences_divider'?: string;
    /**
     * 
     * @type {string}
     * @memberof Users
     */
    'admin_divider'?: string;
}

export const UsersThemeEnum = {
    Light: 'light',
    Dark: 'dark',
    Auto: 'auto'
} as const;

export type UsersThemeEnum = typeof UsersThemeEnum[keyof typeof UsersThemeEnum];
export const UsersStatusEnum = {
    Active: 'active',
    Invited: 'invited',
    Draft: 'draft',
    Suspended: 'suspended',
    Deleted: 'deleted'
} as const;

export type UsersStatusEnum = typeof UsersStatusEnum[keyof typeof UsersStatusEnum];

/**
 * @type UsersAvatar
 * The user\'s avatar.
 * @export
 */
export type UsersAvatar = Files | string;

/**
 * @type UsersRole
 * Unique identifier of the role of this user.
 * @export
 */
export type UsersRole = Roles | string;

/**
 * 
 * @export
 * @interface XMetadata
 */
export interface XMetadata {
    /**
     * Returns the total item count of the collection you\'re querying.
     * @type {number}
     * @memberof XMetadata
     */
    'total_count'?: number;
    /**
     * Returns the item count of the collection you\'re querying, taking the current filter/search parameters into account.
     * @type {number}
     * @memberof XMetadata
     */
    'filter_count'?: number;
}

/**
 * AssetsApi - axios parameter creator
 * @export
 */
export const AssetsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Image typed files can be dynamically resized and transformed to fit any need.
         * @summary Get an Asset
         * @param {string} id The id of the file.
         * @param {string} [key] The key of the asset size configured in settings.
         * @param {string} [transforms] A JSON array of image transformations
         * @param {boolean} [download] Download the asset to your computer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAsset: async (id: string, key?: string, transforms?: string, download?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getAsset', 'id', id)
            const localVarPath = `/assets/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (key !== undefined) {
                localVarQueryParameter['key'] = key;
            }

            if (transforms !== undefined) {
                localVarQueryParameter['transforms'] = transforms;
            }

            if (download !== undefined) {
                localVarQueryParameter['download'] = download;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AssetsApi - functional programming interface
 * @export
 */
export const AssetsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AssetsApiAxiosParamCreator(configuration)
    return {
        /**
         * Image typed files can be dynamically resized and transformed to fit any need.
         * @summary Get an Asset
         * @param {string} id The id of the file.
         * @param {string} [key] The key of the asset size configured in settings.
         * @param {string} [transforms] A JSON array of image transformations
         * @param {boolean} [download] Download the asset to your computer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAsset(id: string, key?: string, transforms?: string, download?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAsset(id, key, transforms, download, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AssetsApi - factory interface
 * @export
 */
export const AssetsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AssetsApiFp(configuration)
    return {
        /**
         * Image typed files can be dynamically resized and transformed to fit any need.
         * @summary Get an Asset
         * @param {string} id The id of the file.
         * @param {string} [key] The key of the asset size configured in settings.
         * @param {string} [transforms] A JSON array of image transformations
         * @param {boolean} [download] Download the asset to your computer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAsset(id: string, key?: string, transforms?: string, download?: boolean, options?: any): AxiosPromise<string> {
            return localVarFp.getAsset(id, key, transforms, download, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AssetsApi - object-oriented interface
 * @export
 * @class AssetsApi
 * @extends {BaseAPI}
 */
export class AssetsApi extends BaseAPI {
    /**
     * Image typed files can be dynamically resized and transformed to fit any need.
     * @summary Get an Asset
     * @param {string} id The id of the file.
     * @param {string} [key] The key of the asset size configured in settings.
     * @param {string} [transforms] A JSON array of image transformations
     * @param {boolean} [download] Download the asset to your computer
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetsApi
     */
    public getAsset(id: string, key?: string, transforms?: string, download?: boolean, options?: AxiosRequestConfig) {
        return AssetsApiFp(this.configuration).getAsset(id, key, transforms, download, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AuthenticationApi - axios parameter creator
 * @export
 */
export const AuthenticationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve a Temporary Access Token
         * @summary Retrieve a Temporary Access Token
         * @param {LoginRequest} [loginRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login: async (loginRequest?: LoginRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Log Out
         * @summary Log Out
         * @param {LogoutRequest} [logoutRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout: async (logoutRequest?: LogoutRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(logoutRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List configured OAuth providers.
         * @summary List OAuth Providers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauth: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/oauth`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Start OAuth flow using the specified provider
         * @summary Authenticated using an OAuth provider
         * @param {string} provider Key of the activated OAuth provider.
         * @param {string} [redirect] Where to redirect on successful login. If set the authentication details are set inside cookies otherwise a JSON is returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauthProvider: async (provider: string, redirect?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'provider' is not null or undefined
            assertParamExists('oauthProvider', 'provider', provider)
            const localVarPath = `/auth/oauth/{provider}`
                .replace(`{${"provider"}}`, encodeURIComponent(String(provider)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (redirect !== undefined) {
                localVarQueryParameter['redirect'] = redirect;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Request a reset password email to be send.
         * @summary Request a Password Reset
         * @param {PasswordRequestRequest} [passwordRequestRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        passwordRequest: async (passwordRequestRequest?: PasswordRequestRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/password/request`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(passwordRequestRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The request a password reset endpoint sends an email with a link to the admin app which in turn uses this endpoint to allow the user to reset their password.
         * @summary Reset a Password
         * @param {PasswordResetRequest} [passwordResetRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        passwordReset: async (passwordResetRequest?: PasswordResetRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/password/reset`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(passwordResetRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Refresh a Temporary Access Token.
         * @summary Refresh Token
         * @param {RefreshRequest} [refreshRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refresh: async (refreshRequest?: RefreshRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/refresh`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(refreshRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthenticationApi - functional programming interface
 * @export
 */
export const AuthenticationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthenticationApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve a Temporary Access Token
         * @summary Retrieve a Temporary Access Token
         * @param {LoginRequest} [loginRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async login(loginRequest?: LoginRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Login200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.login(loginRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Log Out
         * @summary Log Out
         * @param {LogoutRequest} [logoutRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logout(logoutRequest?: LogoutRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logout(logoutRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List configured OAuth providers.
         * @summary List OAuth Providers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oauth(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Oauth200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oauth(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Start OAuth flow using the specified provider
         * @summary Authenticated using an OAuth provider
         * @param {string} provider Key of the activated OAuth provider.
         * @param {string} [redirect] Where to redirect on successful login. If set the authentication details are set inside cookies otherwise a JSON is returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oauthProvider(provider: string, redirect?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OauthProvider200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oauthProvider(provider, redirect, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Request a reset password email to be send.
         * @summary Request a Password Reset
         * @param {PasswordRequestRequest} [passwordRequestRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async passwordRequest(passwordRequestRequest?: PasswordRequestRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.passwordRequest(passwordRequestRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The request a password reset endpoint sends an email with a link to the admin app which in turn uses this endpoint to allow the user to reset their password.
         * @summary Reset a Password
         * @param {PasswordResetRequest} [passwordResetRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async passwordReset(passwordResetRequest?: PasswordResetRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.passwordReset(passwordResetRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Refresh a Temporary Access Token.
         * @summary Refresh Token
         * @param {RefreshRequest} [refreshRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refresh(refreshRequest?: RefreshRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Refresh200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refresh(refreshRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AuthenticationApi - factory interface
 * @export
 */
export const AuthenticationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthenticationApiFp(configuration)
    return {
        /**
         * Retrieve a Temporary Access Token
         * @summary Retrieve a Temporary Access Token
         * @param {LoginRequest} [loginRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(loginRequest?: LoginRequest, options?: any): AxiosPromise<Login200Response> {
            return localVarFp.login(loginRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Log Out
         * @summary Log Out
         * @param {LogoutRequest} [logoutRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout(logoutRequest?: LogoutRequest, options?: any): AxiosPromise<void> {
            return localVarFp.logout(logoutRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * List configured OAuth providers.
         * @summary List OAuth Providers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauth(options?: any): AxiosPromise<Oauth200Response> {
            return localVarFp.oauth(options).then((request) => request(axios, basePath));
        },
        /**
         * Start OAuth flow using the specified provider
         * @summary Authenticated using an OAuth provider
         * @param {string} provider Key of the activated OAuth provider.
         * @param {string} [redirect] Where to redirect on successful login. If set the authentication details are set inside cookies otherwise a JSON is returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauthProvider(provider: string, redirect?: string, options?: any): AxiosPromise<OauthProvider200Response> {
            return localVarFp.oauthProvider(provider, redirect, options).then((request) => request(axios, basePath));
        },
        /**
         * Request a reset password email to be send.
         * @summary Request a Password Reset
         * @param {PasswordRequestRequest} [passwordRequestRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        passwordRequest(passwordRequestRequest?: PasswordRequestRequest, options?: any): AxiosPromise<void> {
            return localVarFp.passwordRequest(passwordRequestRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * The request a password reset endpoint sends an email with a link to the admin app which in turn uses this endpoint to allow the user to reset their password.
         * @summary Reset a Password
         * @param {PasswordResetRequest} [passwordResetRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        passwordReset(passwordResetRequest?: PasswordResetRequest, options?: any): AxiosPromise<void> {
            return localVarFp.passwordReset(passwordResetRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Refresh a Temporary Access Token.
         * @summary Refresh Token
         * @param {RefreshRequest} [refreshRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refresh(refreshRequest?: RefreshRequest, options?: any): AxiosPromise<Refresh200Response> {
            return localVarFp.refresh(refreshRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthenticationApi - object-oriented interface
 * @export
 * @class AuthenticationApi
 * @extends {BaseAPI}
 */
export class AuthenticationApi extends BaseAPI {
    /**
     * Retrieve a Temporary Access Token
     * @summary Retrieve a Temporary Access Token
     * @param {LoginRequest} [loginRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public login(loginRequest?: LoginRequest, options?: AxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).login(loginRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Log Out
     * @summary Log Out
     * @param {LogoutRequest} [logoutRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public logout(logoutRequest?: LogoutRequest, options?: AxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).logout(logoutRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List configured OAuth providers.
     * @summary List OAuth Providers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public oauth(options?: AxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).oauth(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Start OAuth flow using the specified provider
     * @summary Authenticated using an OAuth provider
     * @param {string} provider Key of the activated OAuth provider.
     * @param {string} [redirect] Where to redirect on successful login. If set the authentication details are set inside cookies otherwise a JSON is returned.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public oauthProvider(provider: string, redirect?: string, options?: AxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).oauthProvider(provider, redirect, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Request a reset password email to be send.
     * @summary Request a Password Reset
     * @param {PasswordRequestRequest} [passwordRequestRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public passwordRequest(passwordRequestRequest?: PasswordRequestRequest, options?: AxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).passwordRequest(passwordRequestRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The request a password reset endpoint sends an email with a link to the admin app which in turn uses this endpoint to allow the user to reset their password.
     * @summary Reset a Password
     * @param {PasswordResetRequest} [passwordResetRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public passwordReset(passwordResetRequest?: PasswordResetRequest, options?: AxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).passwordReset(passwordResetRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Refresh a Temporary Access Token.
     * @summary Refresh Token
     * @param {RefreshRequest} [refreshRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public refresh(refreshRequest?: RefreshRequest, options?: AxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).refresh(refreshRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CollectionsApi - axios parameter creator
 * @export
 */
export const CollectionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieves the details of a single collection.
         * @summary Retrieve a Collection
         * @param {string} id Unique identifier of the collection.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollection: async (id: string, meta?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getCollection', 'id', id)
            const localVarPath = `/collections/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of the collections available in the project.
         * @summary List Collections
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollections: async (offset?: number, meta?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/collections`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CollectionsApi - functional programming interface
 * @export
 */
export const CollectionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CollectionsApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieves the details of a single collection.
         * @summary Retrieve a Collection
         * @param {string} id Unique identifier of the collection.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCollection(id: string, meta?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetCollection200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCollection(id, meta, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of the collections available in the project.
         * @summary List Collections
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCollections(offset?: number, meta?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetCollections200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCollections(offset, meta, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CollectionsApi - factory interface
 * @export
 */
export const CollectionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CollectionsApiFp(configuration)
    return {
        /**
         * Retrieves the details of a single collection.
         * @summary Retrieve a Collection
         * @param {string} id Unique identifier of the collection.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollection(id: string, meta?: string, options?: any): AxiosPromise<GetCollection200Response> {
            return localVarFp.getCollection(id, meta, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of the collections available in the project.
         * @summary List Collections
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollections(offset?: number, meta?: string, options?: any): AxiosPromise<GetCollections200Response> {
            return localVarFp.getCollections(offset, meta, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CollectionsApi - object-oriented interface
 * @export
 * @class CollectionsApi
 * @extends {BaseAPI}
 */
export class CollectionsApi extends BaseAPI {
    /**
     * Retrieves the details of a single collection.
     * @summary Retrieve a Collection
     * @param {string} id Unique identifier of the collection.
     * @param {string} [meta] What metadata to return in the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    public getCollection(id: string, meta?: string, options?: AxiosRequestConfig) {
        return CollectionsApiFp(this.configuration).getCollection(id, meta, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of the collections available in the project.
     * @summary List Collections
     * @param {number} [offset] How many items to skip when fetching data.
     * @param {string} [meta] What metadata to return in the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    public getCollections(offset?: number, meta?: string, options?: AxiosRequestConfig) {
        return CollectionsApiFp(this.configuration).getCollections(offset, meta, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ExtensionsApi - axios parameter creator
 * @export
 */
export const ExtensionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * List all installed custom displays.
         * @summary List Displays
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDisplays: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/extensions/displays`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all installed custom interfaces.
         * @summary List Interfaces
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInterfaces: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/extensions/interfaces`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all installed custom layouts.
         * @summary List Layouts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLayouts: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/extensions/layouts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all installed custom modules.
         * @summary List Modules
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getModules: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/extensions/modules`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ExtensionsApi - functional programming interface
 * @export
 */
export const ExtensionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ExtensionsApiAxiosParamCreator(configuration)
    return {
        /**
         * List all installed custom displays.
         * @summary List Displays
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDisplays(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetInterfaces200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDisplays(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List all installed custom interfaces.
         * @summary List Interfaces
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInterfaces(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetInterfaces200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInterfaces(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List all installed custom layouts.
         * @summary List Layouts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLayouts(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetInterfaces200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLayouts(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List all installed custom modules.
         * @summary List Modules
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getModules(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetInterfaces200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getModules(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ExtensionsApi - factory interface
 * @export
 */
export const ExtensionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ExtensionsApiFp(configuration)
    return {
        /**
         * List all installed custom displays.
         * @summary List Displays
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDisplays(options?: any): AxiosPromise<GetInterfaces200Response> {
            return localVarFp.getDisplays(options).then((request) => request(axios, basePath));
        },
        /**
         * List all installed custom interfaces.
         * @summary List Interfaces
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInterfaces(options?: any): AxiosPromise<GetInterfaces200Response> {
            return localVarFp.getInterfaces(options).then((request) => request(axios, basePath));
        },
        /**
         * List all installed custom layouts.
         * @summary List Layouts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLayouts(options?: any): AxiosPromise<GetInterfaces200Response> {
            return localVarFp.getLayouts(options).then((request) => request(axios, basePath));
        },
        /**
         * List all installed custom modules.
         * @summary List Modules
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getModules(options?: any): AxiosPromise<GetInterfaces200Response> {
            return localVarFp.getModules(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ExtensionsApi - object-oriented interface
 * @export
 * @class ExtensionsApi
 * @extends {BaseAPI}
 */
export class ExtensionsApi extends BaseAPI {
    /**
     * List all installed custom displays.
     * @summary List Displays
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExtensionsApi
     */
    public getDisplays(options?: AxiosRequestConfig) {
        return ExtensionsApiFp(this.configuration).getDisplays(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all installed custom interfaces.
     * @summary List Interfaces
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExtensionsApi
     */
    public getInterfaces(options?: AxiosRequestConfig) {
        return ExtensionsApiFp(this.configuration).getInterfaces(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all installed custom layouts.
     * @summary List Layouts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExtensionsApi
     */
    public getLayouts(options?: AxiosRequestConfig) {
        return ExtensionsApiFp(this.configuration).getLayouts(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all installed custom modules.
     * @summary List Modules
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExtensionsApi
     */
    public getModules(options?: AxiosRequestConfig) {
        return ExtensionsApiFp(this.configuration).getModules(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * FieldsApi - axios parameter creator
 * @export
 */
export const FieldsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieves the details of a single field in a given collection.
         * @summary Retrieve a Field
         * @param {string} collection Unique identifier of the collection the item resides in.
         * @param {string} id Unique identifier of the field.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollectionField: async (collection: string, id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'collection' is not null or undefined
            assertParamExists('getCollectionField', 'collection', collection)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getCollectionField', 'id', id)
            const localVarPath = `/fields/{collection}/{id}`
                .replace(`{${"collection"}}`, encodeURIComponent(String(collection)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of the fields available in the given collection.
         * @summary List Fields in Collection
         * @param {string} collection Unique identifier of the collection the item resides in.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollectionFields: async (collection: string, sort?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'collection' is not null or undefined
            assertParamExists('getCollectionFields', 'collection', collection)
            const localVarPath = `/fields/{collection}`
                .replace(`{${"collection"}}`, encodeURIComponent(String(collection)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (sort) {
                localVarQueryParameter['sort'] = sort.join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of the fields available in the project.
         * @summary List All Fields
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFields: async (limit?: number, sort?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/fields`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort) {
                localVarQueryParameter['sort'] = sort.join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FieldsApi - functional programming interface
 * @export
 */
export const FieldsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FieldsApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieves the details of a single field in a given collection.
         * @summary Retrieve a Field
         * @param {string} collection Unique identifier of the collection the item resides in.
         * @param {string} id Unique identifier of the field.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCollectionField(collection: string, id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetCollectionField200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCollectionField(collection, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of the fields available in the given collection.
         * @summary List Fields in Collection
         * @param {string} collection Unique identifier of the collection the item resides in.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCollectionFields(collection: string, sort?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetFields200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCollectionFields(collection, sort, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of the fields available in the project.
         * @summary List All Fields
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFields(limit?: number, sort?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetFields200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFields(limit, sort, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * FieldsApi - factory interface
 * @export
 */
export const FieldsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FieldsApiFp(configuration)
    return {
        /**
         * Retrieves the details of a single field in a given collection.
         * @summary Retrieve a Field
         * @param {string} collection Unique identifier of the collection the item resides in.
         * @param {string} id Unique identifier of the field.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollectionField(collection: string, id: string, options?: any): AxiosPromise<GetCollectionField200Response> {
            return localVarFp.getCollectionField(collection, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of the fields available in the given collection.
         * @summary List Fields in Collection
         * @param {string} collection Unique identifier of the collection the item resides in.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollectionFields(collection: string, sort?: Array<string>, options?: any): AxiosPromise<GetFields200Response> {
            return localVarFp.getCollectionFields(collection, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of the fields available in the project.
         * @summary List All Fields
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFields(limit?: number, sort?: Array<string>, options?: any): AxiosPromise<GetFields200Response> {
            return localVarFp.getFields(limit, sort, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FieldsApi - object-oriented interface
 * @export
 * @class FieldsApi
 * @extends {BaseAPI}
 */
export class FieldsApi extends BaseAPI {
    /**
     * Retrieves the details of a single field in a given collection.
     * @summary Retrieve a Field
     * @param {string} collection Unique identifier of the collection the item resides in.
     * @param {string} id Unique identifier of the field.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FieldsApi
     */
    public getCollectionField(collection: string, id: string, options?: AxiosRequestConfig) {
        return FieldsApiFp(this.configuration).getCollectionField(collection, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of the fields available in the given collection.
     * @summary List Fields in Collection
     * @param {string} collection Unique identifier of the collection the item resides in.
     * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FieldsApi
     */
    public getCollectionFields(collection: string, sort?: Array<string>, options?: AxiosRequestConfig) {
        return FieldsApiFp(this.configuration).getCollectionFields(collection, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of the fields available in the project.
     * @summary List All Fields
     * @param {number} [limit] A limit on the number of objects that are returned.
     * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FieldsApi
     */
    public getFields(limit?: number, sort?: Array<string>, options?: AxiosRequestConfig) {
        return FieldsApiFp(this.configuration).getFields(limit, sort, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * FilesApi - axios parameter creator
 * @export
 */
export const FilesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve a single file by unique identifier.
         * @summary Retrieve a Files
         * @param {string} id Unique identifier for the object.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFile: async (id: string, fields?: Array<string>, meta?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getFile', 'id', id)
            const localVarPath = `/files/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List the files.
         * @summary List Files
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {Array<string>} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFiles: async (fields?: Array<string>, limit?: number, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, meta?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/files`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sort) {
                localVarQueryParameter['sort'] = sort.join(COLLECTION_FORMATS.csv);
            }

            if (filter) {
                localVarQueryParameter['filter'] = filter;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FilesApi - functional programming interface
 * @export
 */
export const FilesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FilesApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve a single file by unique identifier.
         * @summary Retrieve a Files
         * @param {string} id Unique identifier for the object.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFile(id: string, fields?: Array<string>, meta?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetFile200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFile(id, fields, meta, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List the files.
         * @summary List Files
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {Array<string>} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFiles(fields?: Array<string>, limit?: number, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, meta?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetFiles200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFiles(fields, limit, offset, sort, filter, search, meta, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * FilesApi - factory interface
 * @export
 */
export const FilesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FilesApiFp(configuration)
    return {
        /**
         * Retrieve a single file by unique identifier.
         * @summary Retrieve a Files
         * @param {string} id Unique identifier for the object.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFile(id: string, fields?: Array<string>, meta?: string, options?: any): AxiosPromise<GetFile200Response> {
            return localVarFp.getFile(id, fields, meta, options).then((request) => request(axios, basePath));
        },
        /**
         * List the files.
         * @summary List Files
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {Array<string>} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFiles(fields?: Array<string>, limit?: number, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, meta?: string, options?: any): AxiosPromise<GetFiles200Response> {
            return localVarFp.getFiles(fields, limit, offset, sort, filter, search, meta, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FilesApi - object-oriented interface
 * @export
 * @class FilesApi
 * @extends {BaseAPI}
 */
export class FilesApi extends BaseAPI {
    /**
     * Retrieve a single file by unique identifier.
     * @summary Retrieve a Files
     * @param {string} id Unique identifier for the object.
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    public getFile(id: string, fields?: Array<string>, meta?: string, options?: AxiosRequestConfig) {
        return FilesApiFp(this.configuration).getFile(id, fields, meta, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List the files.
     * @summary List Files
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {number} [limit] A limit on the number of objects that are returned.
     * @param {number} [offset] How many items to skip when fetching data.
     * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
     * @param {Array<string>} [filter] Select items in collection by given conditions.
     * @param {string} [search] Filter by items that contain the given search query in one of their fields.
     * @param {string} [meta] What metadata to return in the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    public getFiles(fields?: Array<string>, limit?: number, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, meta?: string, options?: AxiosRequestConfig) {
        return FilesApiFp(this.configuration).getFiles(fields, limit, offset, sort, filter, search, meta, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * FoldersApi - axios parameter creator
 * @export
 */
export const FoldersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve a single folder by unique identifier.
         * @summary Retrieve a Folder
         * @param {string} id Unique identifier for the object.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFolder: async (id: string, fields?: Array<string>, meta?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getFolder', 'id', id)
            const localVarPath = `/folders/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List the folders.
         * @summary List Folders
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {Array<string>} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFolders: async (fields?: Array<string>, limit?: number, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, meta?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/folders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sort) {
                localVarQueryParameter['sort'] = sort.join(COLLECTION_FORMATS.csv);
            }

            if (filter) {
                localVarQueryParameter['filter'] = filter;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FoldersApi - functional programming interface
 * @export
 */
export const FoldersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FoldersApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve a single folder by unique identifier.
         * @summary Retrieve a Folder
         * @param {string} id Unique identifier for the object.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFolder(id: string, fields?: Array<string>, meta?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetFolder200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFolder(id, fields, meta, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List the folders.
         * @summary List Folders
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {Array<string>} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFolders(fields?: Array<string>, limit?: number, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, meta?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetFolders200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFolders(fields, limit, offset, sort, filter, search, meta, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * FoldersApi - factory interface
 * @export
 */
export const FoldersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FoldersApiFp(configuration)
    return {
        /**
         * Retrieve a single folder by unique identifier.
         * @summary Retrieve a Folder
         * @param {string} id Unique identifier for the object.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFolder(id: string, fields?: Array<string>, meta?: string, options?: any): AxiosPromise<GetFolder200Response> {
            return localVarFp.getFolder(id, fields, meta, options).then((request) => request(axios, basePath));
        },
        /**
         * List the folders.
         * @summary List Folders
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {Array<string>} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFolders(fields?: Array<string>, limit?: number, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, meta?: string, options?: any): AxiosPromise<GetFolders200Response> {
            return localVarFp.getFolders(fields, limit, offset, sort, filter, search, meta, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FoldersApi - object-oriented interface
 * @export
 * @class FoldersApi
 * @extends {BaseAPI}
 */
export class FoldersApi extends BaseAPI {
    /**
     * Retrieve a single folder by unique identifier.
     * @summary Retrieve a Folder
     * @param {string} id Unique identifier for the object.
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoldersApi
     */
    public getFolder(id: string, fields?: Array<string>, meta?: string, options?: AxiosRequestConfig) {
        return FoldersApiFp(this.configuration).getFolder(id, fields, meta, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List the folders.
     * @summary List Folders
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {number} [limit] A limit on the number of objects that are returned.
     * @param {number} [offset] How many items to skip when fetching data.
     * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
     * @param {Array<string>} [filter] Select items in collection by given conditions.
     * @param {string} [search] Filter by items that contain the given search query in one of their fields.
     * @param {string} [meta] What metadata to return in the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoldersApi
     */
    public getFolders(fields?: Array<string>, limit?: number, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, meta?: string, options?: AxiosRequestConfig) {
        return FoldersApiFp(this.configuration).getFolders(fields, limit, offset, sort, filter, search, meta, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ItemsApi - axios parameter creator
 * @export
 */
export const ItemsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new AnswerOption item.
         * @summary Create an Item
         * @param {string} [meta] What metadata to return in the response.
         * @param {CreateItemsAnswerOptionRequest} [createItemsAnswerOptionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createItemsAnswerOption: async (meta?: string, createItemsAnswerOptionRequest?: CreateItemsAnswerOptionRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/items/AnswerOption`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createItemsAnswerOptionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new AnswerOptionTranslation item.
         * @summary Create an Item
         * @param {string} [meta] What metadata to return in the response.
         * @param {CreateItemsAnswerOptionTranslationRequest} [createItemsAnswerOptionTranslationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createItemsAnswerOptionTranslation: async (meta?: string, createItemsAnswerOptionTranslationRequest?: CreateItemsAnswerOptionTranslationRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/items/AnswerOptionTranslation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createItemsAnswerOptionTranslationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new Article item.
         * @summary Create an Item
         * @param {string} [meta] What metadata to return in the response.
         * @param {CreateItemsArticleRequest} [createItemsArticleRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createItemsArticle: async (meta?: string, createItemsArticleRequest?: CreateItemsArticleRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/items/Article`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createItemsArticleRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new ArticleCategory item.
         * @summary Create an Item
         * @param {string} [meta] What metadata to return in the response.
         * @param {CreateItemsArticleCategoryRequest} [createItemsArticleCategoryRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createItemsArticleCategory: async (meta?: string, createItemsArticleCategoryRequest?: CreateItemsArticleCategoryRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/items/ArticleCategory`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createItemsArticleCategoryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new ArticleTranslation item.
         * @summary Create an Item
         * @param {string} [meta] What metadata to return in the response.
         * @param {CreateItemsArticleTranslationRequest} [createItemsArticleTranslationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createItemsArticleTranslation: async (meta?: string, createItemsArticleTranslationRequest?: CreateItemsArticleTranslationRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/items/ArticleTranslation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createItemsArticleTranslationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new Condition item.
         * @summary Create an Item
         * @param {string} [meta] What metadata to return in the response.
         * @param {CreateItemsConditionRequest} [createItemsConditionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createItemsCondition: async (meta?: string, createItemsConditionRequest?: CreateItemsConditionRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/items/Condition`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createItemsConditionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new ConditionFact item.
         * @summary Create an Item
         * @param {string} [meta] What metadata to return in the response.
         * @param {CreateItemsConditionFactRequest} [createItemsConditionFactRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createItemsConditionFact: async (meta?: string, createItemsConditionFactRequest?: CreateItemsConditionFactRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/items/ConditionFact`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createItemsConditionFactRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new Fact item.
         * @summary Create an Item
         * @param {string} [meta] What metadata to return in the response.
         * @param {CreateItemsFactRequest} [createItemsFactRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createItemsFact: async (meta?: string, createItemsFactRequest?: CreateItemsFactRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/items/Fact`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createItemsFactRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new Question item.
         * @summary Create an Item
         * @param {string} [meta] What metadata to return in the response.
         * @param {CreateItemsQuestionRequest} [createItemsQuestionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createItemsQuestion: async (meta?: string, createItemsQuestionRequest?: CreateItemsQuestionRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/items/Question`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createItemsQuestionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new QuestionTranslation item.
         * @summary Create an Item
         * @param {string} [meta] What metadata to return in the response.
         * @param {CreateItemsQuestionTranslationRequest} [createItemsQuestionTranslationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createItemsQuestionTranslation: async (meta?: string, createItemsQuestionTranslationRequest?: CreateItemsQuestionTranslationRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/items/QuestionTranslation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createItemsQuestionTranslationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new Questionnaire item.
         * @summary Create an Item
         * @param {string} [meta] What metadata to return in the response.
         * @param {CreateItemsQuestionnaireRequest} [createItemsQuestionnaireRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createItemsQuestionnaire: async (meta?: string, createItemsQuestionnaireRequest?: CreateItemsQuestionnaireRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/items/Questionnaire`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createItemsQuestionnaireRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new QuestionnaireTranslation item.
         * @summary Create an Item
         * @param {string} [meta] What metadata to return in the response.
         * @param {CreateItemsQuestionnaireTranslationRequest} [createItemsQuestionnaireTranslationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createItemsQuestionnaireTranslation: async (meta?: string, createItemsQuestionnaireTranslationRequest?: CreateItemsQuestionnaireTranslationRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/items/QuestionnaireTranslation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createItemsQuestionnaireTranslationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new Section item.
         * @summary Create an Item
         * @param {string} [meta] What metadata to return in the response.
         * @param {CreateItemsSectionRequest} [createItemsSectionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createItemsSection: async (meta?: string, createItemsSectionRequest?: CreateItemsSectionRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/items/Section`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createItemsSectionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new SectionTranslation item.
         * @summary Create an Item
         * @param {string} [meta] What metadata to return in the response.
         * @param {CreateItemsSectionTranslationRequest} [createItemsSectionTranslationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createItemsSectionTranslation: async (meta?: string, createItemsSectionTranslationRequest?: CreateItemsSectionTranslationRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/items/SectionTranslation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createItemsSectionTranslationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new Version item.
         * @summary Create an Item
         * @param {string} [meta] What metadata to return in the response.
         * @param {CreateItemsVersionRequest} [createItemsVersionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createItemsVersion: async (meta?: string, createItemsVersionRequest?: CreateItemsVersionRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/items/Version`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createItemsVersionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an existing AnswerOption item.
         * @summary Delete an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSingleItemsAnswerOption: async (id: ReadSingleItemsAnswerOptionIdParameter, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteSingleItemsAnswerOption', 'id', id)
            const localVarPath = `/items/AnswerOption/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an existing AnswerOptionTranslation item.
         * @summary Delete an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSingleItemsAnswerOptionTranslation: async (id: ReadSingleItemsAnswerOptionIdParameter, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteSingleItemsAnswerOptionTranslation', 'id', id)
            const localVarPath = `/items/AnswerOptionTranslation/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an existing Article item.
         * @summary Delete an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSingleItemsArticle: async (id: ReadSingleItemsAnswerOptionIdParameter, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteSingleItemsArticle', 'id', id)
            const localVarPath = `/items/Article/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an existing ArticleCategory item.
         * @summary Delete an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSingleItemsArticleCategory: async (id: ReadSingleItemsAnswerOptionIdParameter, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteSingleItemsArticleCategory', 'id', id)
            const localVarPath = `/items/ArticleCategory/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an existing ArticleTranslation item.
         * @summary Delete an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSingleItemsArticleTranslation: async (id: ReadSingleItemsAnswerOptionIdParameter, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteSingleItemsArticleTranslation', 'id', id)
            const localVarPath = `/items/ArticleTranslation/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an existing Condition item.
         * @summary Delete an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSingleItemsCondition: async (id: ReadSingleItemsAnswerOptionIdParameter, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteSingleItemsCondition', 'id', id)
            const localVarPath = `/items/Condition/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an existing ConditionFact item.
         * @summary Delete an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSingleItemsConditionFact: async (id: ReadSingleItemsAnswerOptionIdParameter, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteSingleItemsConditionFact', 'id', id)
            const localVarPath = `/items/ConditionFact/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an existing Fact item.
         * @summary Delete an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSingleItemsFact: async (id: ReadSingleItemsAnswerOptionIdParameter, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteSingleItemsFact', 'id', id)
            const localVarPath = `/items/Fact/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an existing Question item.
         * @summary Delete an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSingleItemsQuestion: async (id: ReadSingleItemsAnswerOptionIdParameter, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteSingleItemsQuestion', 'id', id)
            const localVarPath = `/items/Question/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an existing QuestionTranslation item.
         * @summary Delete an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSingleItemsQuestionTranslation: async (id: ReadSingleItemsAnswerOptionIdParameter, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteSingleItemsQuestionTranslation', 'id', id)
            const localVarPath = `/items/QuestionTranslation/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an existing Questionnaire item.
         * @summary Delete an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSingleItemsQuestionnaire: async (id: ReadSingleItemsAnswerOptionIdParameter, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteSingleItemsQuestionnaire', 'id', id)
            const localVarPath = `/items/Questionnaire/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an existing QuestionnaireTranslation item.
         * @summary Delete an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSingleItemsQuestionnaireTranslation: async (id: ReadSingleItemsAnswerOptionIdParameter, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteSingleItemsQuestionnaireTranslation', 'id', id)
            const localVarPath = `/items/QuestionnaireTranslation/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an existing Section item.
         * @summary Delete an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSingleItemsSection: async (id: ReadSingleItemsAnswerOptionIdParameter, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteSingleItemsSection', 'id', id)
            const localVarPath = `/items/Section/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an existing SectionTranslation item.
         * @summary Delete an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSingleItemsSectionTranslation: async (id: ReadSingleItemsAnswerOptionIdParameter, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteSingleItemsSectionTranslation', 'id', id)
            const localVarPath = `/items/SectionTranslation/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an existing Version item.
         * @summary Delete an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSingleItemsVersion: async (id: ReadSingleItemsAnswerOptionIdParameter, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteSingleItemsVersion', 'id', id)
            const localVarPath = `/items/Version/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List the AnswerOption items.
         * @summary List Items
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {Array<string>} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readItemsAnswerOption: async (fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/items/AnswerOption`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sort) {
                localVarQueryParameter['sort'] = sort.join(COLLECTION_FORMATS.csv);
            }

            if (filter) {
                localVarQueryParameter['filter'] = filter;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List the AnswerOptionTranslation items.
         * @summary List Items
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {Array<string>} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readItemsAnswerOptionTranslation: async (fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/items/AnswerOptionTranslation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sort) {
                localVarQueryParameter['sort'] = sort.join(COLLECTION_FORMATS.csv);
            }

            if (filter) {
                localVarQueryParameter['filter'] = filter;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List the Article items.
         * @summary List Items
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {Array<string>} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readItemsArticle: async (fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/items/Article`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sort) {
                localVarQueryParameter['sort'] = sort.join(COLLECTION_FORMATS.csv);
            }

            if (filter) {
                localVarQueryParameter['filter'] = filter;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List the ArticleCategory items.
         * @summary List Items
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {Array<string>} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readItemsArticleCategory: async (fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/items/ArticleCategory`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sort) {
                localVarQueryParameter['sort'] = sort.join(COLLECTION_FORMATS.csv);
            }

            if (filter) {
                localVarQueryParameter['filter'] = filter;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List the ArticleTranslation items.
         * @summary List Items
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {Array<string>} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readItemsArticleTranslation: async (fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/items/ArticleTranslation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sort) {
                localVarQueryParameter['sort'] = sort.join(COLLECTION_FORMATS.csv);
            }

            if (filter) {
                localVarQueryParameter['filter'] = filter;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List the Condition items.
         * @summary List Items
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {Array<string>} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readItemsCondition: async (fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/items/Condition`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sort) {
                localVarQueryParameter['sort'] = sort.join(COLLECTION_FORMATS.csv);
            }

            if (filter) {
                localVarQueryParameter['filter'] = filter;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List the ConditionFact items.
         * @summary List Items
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {Array<string>} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readItemsConditionFact: async (fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/items/ConditionFact`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sort) {
                localVarQueryParameter['sort'] = sort.join(COLLECTION_FORMATS.csv);
            }

            if (filter) {
                localVarQueryParameter['filter'] = filter;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List the Fact items.
         * @summary List Items
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {Array<string>} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readItemsFact: async (fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/items/Fact`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sort) {
                localVarQueryParameter['sort'] = sort.join(COLLECTION_FORMATS.csv);
            }

            if (filter) {
                localVarQueryParameter['filter'] = filter;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List the Language items.
         * @summary List Items
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {Array<string>} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readItemsLanguage: async (fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/items/Language`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sort) {
                localVarQueryParameter['sort'] = sort.join(COLLECTION_FORMATS.csv);
            }

            if (filter) {
                localVarQueryParameter['filter'] = filter;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List the Meaning items.
         * @summary List Items
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {Array<string>} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readItemsMeaning: async (fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/items/Meaning`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sort) {
                localVarQueryParameter['sort'] = sort.join(COLLECTION_FORMATS.csv);
            }

            if (filter) {
                localVarQueryParameter['filter'] = filter;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List the Operator items.
         * @summary List Items
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {Array<string>} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readItemsOperator: async (fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/items/Operator`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sort) {
                localVarQueryParameter['sort'] = sort.join(COLLECTION_FORMATS.csv);
            }

            if (filter) {
                localVarQueryParameter['filter'] = filter;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List the Question items.
         * @summary List Items
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {Array<string>} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readItemsQuestion: async (fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/items/Question`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sort) {
                localVarQueryParameter['sort'] = sort.join(COLLECTION_FORMATS.csv);
            }

            if (filter) {
                localVarQueryParameter['filter'] = filter;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List the QuestionTranslation items.
         * @summary List Items
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {Array<string>} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readItemsQuestionTranslation: async (fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/items/QuestionTranslation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sort) {
                localVarQueryParameter['sort'] = sort.join(COLLECTION_FORMATS.csv);
            }

            if (filter) {
                localVarQueryParameter['filter'] = filter;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List the QuestionDisplay items.
         * @summary List Items
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {Array<string>} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readItemsQuestiondisplay: async (fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/items/QuestionDisplay`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sort) {
                localVarQueryParameter['sort'] = sort.join(COLLECTION_FORMATS.csv);
            }

            if (filter) {
                localVarQueryParameter['filter'] = filter;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List the Questionnaire items.
         * @summary List Items
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {Array<string>} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readItemsQuestionnaire: async (fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/items/Questionnaire`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sort) {
                localVarQueryParameter['sort'] = sort.join(COLLECTION_FORMATS.csv);
            }

            if (filter) {
                localVarQueryParameter['filter'] = filter;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List the QuestionnaireTranslation items.
         * @summary List Items
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {Array<string>} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readItemsQuestionnaireTranslation: async (fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/items/QuestionnaireTranslation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sort) {
                localVarQueryParameter['sort'] = sort.join(COLLECTION_FORMATS.csv);
            }

            if (filter) {
                localVarQueryParameter['filter'] = filter;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List the QuestionType items.
         * @summary List Items
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {Array<string>} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readItemsQuestiontype: async (fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/items/QuestionType`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sort) {
                localVarQueryParameter['sort'] = sort.join(COLLECTION_FORMATS.csv);
            }

            if (filter) {
                localVarQueryParameter['filter'] = filter;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List the Section items.
         * @summary List Items
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {Array<string>} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readItemsSection: async (fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/items/Section`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sort) {
                localVarQueryParameter['sort'] = sort.join(COLLECTION_FORMATS.csv);
            }

            if (filter) {
                localVarQueryParameter['filter'] = filter;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List the SectionTranslation items.
         * @summary List Items
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {Array<string>} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readItemsSectionTranslation: async (fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/items/SectionTranslation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sort) {
                localVarQueryParameter['sort'] = sort.join(COLLECTION_FORMATS.csv);
            }

            if (filter) {
                localVarQueryParameter['filter'] = filter;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List the Version items.
         * @summary List Items
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {Array<string>} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readItemsVersion: async (fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/items/Version`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sort) {
                localVarQueryParameter['sort'] = sort.join(COLLECTION_FORMATS.csv);
            }

            if (filter) {
                localVarQueryParameter['filter'] = filter;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List the VersionContentType items.
         * @summary List Items
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {Array<string>} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readItemsVersionContentType: async (fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/items/VersionContentType`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sort) {
                localVarQueryParameter['sort'] = sort.join(COLLECTION_FORMATS.csv);
            }

            if (filter) {
                localVarQueryParameter['filter'] = filter;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a single AnswerOption item by unique identifier.
         * @summary Retrieve an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readSingleItemsAnswerOption: async (id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('readSingleItemsAnswerOption', 'id', id)
            const localVarPath = `/items/AnswerOption/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a single AnswerOptionTranslation item by unique identifier.
         * @summary Retrieve an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readSingleItemsAnswerOptionTranslation: async (id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('readSingleItemsAnswerOptionTranslation', 'id', id)
            const localVarPath = `/items/AnswerOptionTranslation/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a single Article item by unique identifier.
         * @summary Retrieve an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readSingleItemsArticle: async (id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('readSingleItemsArticle', 'id', id)
            const localVarPath = `/items/Article/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a single ArticleCategory item by unique identifier.
         * @summary Retrieve an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readSingleItemsArticleCategory: async (id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('readSingleItemsArticleCategory', 'id', id)
            const localVarPath = `/items/ArticleCategory/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a single ArticleTranslation item by unique identifier.
         * @summary Retrieve an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readSingleItemsArticleTranslation: async (id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('readSingleItemsArticleTranslation', 'id', id)
            const localVarPath = `/items/ArticleTranslation/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a single Condition item by unique identifier.
         * @summary Retrieve an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readSingleItemsCondition: async (id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('readSingleItemsCondition', 'id', id)
            const localVarPath = `/items/Condition/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a single ConditionFact item by unique identifier.
         * @summary Retrieve an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readSingleItemsConditionFact: async (id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('readSingleItemsConditionFact', 'id', id)
            const localVarPath = `/items/ConditionFact/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a single Fact item by unique identifier.
         * @summary Retrieve an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readSingleItemsFact: async (id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('readSingleItemsFact', 'id', id)
            const localVarPath = `/items/Fact/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a single Language item by unique identifier.
         * @summary Retrieve an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readSingleItemsLanguage: async (id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('readSingleItemsLanguage', 'id', id)
            const localVarPath = `/items/Language/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a single Meaning item by unique identifier.
         * @summary Retrieve an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readSingleItemsMeaning: async (id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('readSingleItemsMeaning', 'id', id)
            const localVarPath = `/items/Meaning/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a single Operator item by unique identifier.
         * @summary Retrieve an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readSingleItemsOperator: async (id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('readSingleItemsOperator', 'id', id)
            const localVarPath = `/items/Operator/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a single Question item by unique identifier.
         * @summary Retrieve an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readSingleItemsQuestion: async (id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('readSingleItemsQuestion', 'id', id)
            const localVarPath = `/items/Question/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a single QuestionTranslation item by unique identifier.
         * @summary Retrieve an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readSingleItemsQuestionTranslation: async (id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('readSingleItemsQuestionTranslation', 'id', id)
            const localVarPath = `/items/QuestionTranslation/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a single QuestionDisplay item by unique identifier.
         * @summary Retrieve an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readSingleItemsQuestiondisplay: async (id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('readSingleItemsQuestiondisplay', 'id', id)
            const localVarPath = `/items/QuestionDisplay/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a single Questionnaire item by unique identifier.
         * @summary Retrieve an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readSingleItemsQuestionnaire: async (id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('readSingleItemsQuestionnaire', 'id', id)
            const localVarPath = `/items/Questionnaire/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a single QuestionnaireTranslation item by unique identifier.
         * @summary Retrieve an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readSingleItemsQuestionnaireTranslation: async (id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('readSingleItemsQuestionnaireTranslation', 'id', id)
            const localVarPath = `/items/QuestionnaireTranslation/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a single QuestionType item by unique identifier.
         * @summary Retrieve an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readSingleItemsQuestiontype: async (id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('readSingleItemsQuestiontype', 'id', id)
            const localVarPath = `/items/QuestionType/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a single Section item by unique identifier.
         * @summary Retrieve an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readSingleItemsSection: async (id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('readSingleItemsSection', 'id', id)
            const localVarPath = `/items/Section/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a single SectionTranslation item by unique identifier.
         * @summary Retrieve an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readSingleItemsSectionTranslation: async (id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('readSingleItemsSectionTranslation', 'id', id)
            const localVarPath = `/items/SectionTranslation/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a single Version item by unique identifier.
         * @summary Retrieve an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readSingleItemsVersion: async (id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('readSingleItemsVersion', 'id', id)
            const localVarPath = `/items/Version/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a single VersionContentType item by unique identifier.
         * @summary Retrieve an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readSingleItemsVersionContentType: async (id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('readSingleItemsVersionContentType', 'id', id)
            const localVarPath = `/items/VersionContentType/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an existing AnswerOption item.
         * @summary Update an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {ItemsAnswerOption} [itemsAnswerOption] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSingleItemsAnswerOption: async (id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, itemsAnswerOption?: ItemsAnswerOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateSingleItemsAnswerOption', 'id', id)
            const localVarPath = `/items/AnswerOption/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(itemsAnswerOption, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an existing AnswerOptionTranslation item.
         * @summary Update an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {ItemsAnswerOptionTranslation} [itemsAnswerOptionTranslation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSingleItemsAnswerOptionTranslation: async (id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, itemsAnswerOptionTranslation?: ItemsAnswerOptionTranslation, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateSingleItemsAnswerOptionTranslation', 'id', id)
            const localVarPath = `/items/AnswerOptionTranslation/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(itemsAnswerOptionTranslation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an existing Article item.
         * @summary Update an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {ItemsArticle} [itemsArticle] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSingleItemsArticle: async (id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, itemsArticle?: ItemsArticle, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateSingleItemsArticle', 'id', id)
            const localVarPath = `/items/Article/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(itemsArticle, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an existing ArticleCategory item.
         * @summary Update an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {ItemsArticleCategory} [itemsArticleCategory] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSingleItemsArticleCategory: async (id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, itemsArticleCategory?: ItemsArticleCategory, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateSingleItemsArticleCategory', 'id', id)
            const localVarPath = `/items/ArticleCategory/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(itemsArticleCategory, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an existing ArticleTranslation item.
         * @summary Update an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {ItemsArticleTranslation} [itemsArticleTranslation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSingleItemsArticleTranslation: async (id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, itemsArticleTranslation?: ItemsArticleTranslation, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateSingleItemsArticleTranslation', 'id', id)
            const localVarPath = `/items/ArticleTranslation/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(itemsArticleTranslation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an existing Condition item.
         * @summary Update an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {ItemsCondition} [itemsCondition] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSingleItemsCondition: async (id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, itemsCondition?: ItemsCondition, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateSingleItemsCondition', 'id', id)
            const localVarPath = `/items/Condition/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(itemsCondition, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an existing ConditionFact item.
         * @summary Update an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {ItemsConditionFact} [itemsConditionFact] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSingleItemsConditionFact: async (id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, itemsConditionFact?: ItemsConditionFact, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateSingleItemsConditionFact', 'id', id)
            const localVarPath = `/items/ConditionFact/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(itemsConditionFact, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an existing Fact item.
         * @summary Update an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {ItemsFact} [itemsFact] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSingleItemsFact: async (id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, itemsFact?: ItemsFact, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateSingleItemsFact', 'id', id)
            const localVarPath = `/items/Fact/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(itemsFact, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an existing Question item.
         * @summary Update an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {ItemsQuestion} [itemsQuestion] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSingleItemsQuestion: async (id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, itemsQuestion?: ItemsQuestion, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateSingleItemsQuestion', 'id', id)
            const localVarPath = `/items/Question/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(itemsQuestion, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an existing QuestionTranslation item.
         * @summary Update an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {ItemsQuestionTranslation} [itemsQuestionTranslation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSingleItemsQuestionTranslation: async (id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, itemsQuestionTranslation?: ItemsQuestionTranslation, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateSingleItemsQuestionTranslation', 'id', id)
            const localVarPath = `/items/QuestionTranslation/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(itemsQuestionTranslation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an existing Questionnaire item.
         * @summary Update an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {ItemsQuestionnaire} [itemsQuestionnaire] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSingleItemsQuestionnaire: async (id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, itemsQuestionnaire?: ItemsQuestionnaire, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateSingleItemsQuestionnaire', 'id', id)
            const localVarPath = `/items/Questionnaire/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(itemsQuestionnaire, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an existing QuestionnaireTranslation item.
         * @summary Update an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {ItemsQuestionnaireTranslation} [itemsQuestionnaireTranslation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSingleItemsQuestionnaireTranslation: async (id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, itemsQuestionnaireTranslation?: ItemsQuestionnaireTranslation, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateSingleItemsQuestionnaireTranslation', 'id', id)
            const localVarPath = `/items/QuestionnaireTranslation/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(itemsQuestionnaireTranslation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an existing Section item.
         * @summary Update an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {ItemsSection} [itemsSection] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSingleItemsSection: async (id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, itemsSection?: ItemsSection, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateSingleItemsSection', 'id', id)
            const localVarPath = `/items/Section/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(itemsSection, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an existing SectionTranslation item.
         * @summary Update an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {ItemsSectionTranslation} [itemsSectionTranslation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSingleItemsSectionTranslation: async (id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, itemsSectionTranslation?: ItemsSectionTranslation, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateSingleItemsSectionTranslation', 'id', id)
            const localVarPath = `/items/SectionTranslation/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(itemsSectionTranslation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ItemsApi - functional programming interface
 * @export
 */
export const ItemsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ItemsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new AnswerOption item.
         * @summary Create an Item
         * @param {string} [meta] What metadata to return in the response.
         * @param {CreateItemsAnswerOptionRequest} [createItemsAnswerOptionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createItemsAnswerOption(meta?: string, createItemsAnswerOptionRequest?: CreateItemsAnswerOptionRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateItemsAnswerOption200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createItemsAnswerOption(meta, createItemsAnswerOptionRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new AnswerOptionTranslation item.
         * @summary Create an Item
         * @param {string} [meta] What metadata to return in the response.
         * @param {CreateItemsAnswerOptionTranslationRequest} [createItemsAnswerOptionTranslationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createItemsAnswerOptionTranslation(meta?: string, createItemsAnswerOptionTranslationRequest?: CreateItemsAnswerOptionTranslationRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateItemsAnswerOptionTranslation200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createItemsAnswerOptionTranslation(meta, createItemsAnswerOptionTranslationRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new Article item.
         * @summary Create an Item
         * @param {string} [meta] What metadata to return in the response.
         * @param {CreateItemsArticleRequest} [createItemsArticleRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createItemsArticle(meta?: string, createItemsArticleRequest?: CreateItemsArticleRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateItemsArticle200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createItemsArticle(meta, createItemsArticleRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new ArticleCategory item.
         * @summary Create an Item
         * @param {string} [meta] What metadata to return in the response.
         * @param {CreateItemsArticleCategoryRequest} [createItemsArticleCategoryRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createItemsArticleCategory(meta?: string, createItemsArticleCategoryRequest?: CreateItemsArticleCategoryRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateItemsArticleCategory200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createItemsArticleCategory(meta, createItemsArticleCategoryRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new ArticleTranslation item.
         * @summary Create an Item
         * @param {string} [meta] What metadata to return in the response.
         * @param {CreateItemsArticleTranslationRequest} [createItemsArticleTranslationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createItemsArticleTranslation(meta?: string, createItemsArticleTranslationRequest?: CreateItemsArticleTranslationRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateItemsArticleTranslation200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createItemsArticleTranslation(meta, createItemsArticleTranslationRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new Condition item.
         * @summary Create an Item
         * @param {string} [meta] What metadata to return in the response.
         * @param {CreateItemsConditionRequest} [createItemsConditionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createItemsCondition(meta?: string, createItemsConditionRequest?: CreateItemsConditionRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateItemsCondition200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createItemsCondition(meta, createItemsConditionRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new ConditionFact item.
         * @summary Create an Item
         * @param {string} [meta] What metadata to return in the response.
         * @param {CreateItemsConditionFactRequest} [createItemsConditionFactRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createItemsConditionFact(meta?: string, createItemsConditionFactRequest?: CreateItemsConditionFactRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateItemsConditionFact200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createItemsConditionFact(meta, createItemsConditionFactRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new Fact item.
         * @summary Create an Item
         * @param {string} [meta] What metadata to return in the response.
         * @param {CreateItemsFactRequest} [createItemsFactRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createItemsFact(meta?: string, createItemsFactRequest?: CreateItemsFactRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateItemsFact200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createItemsFact(meta, createItemsFactRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new Question item.
         * @summary Create an Item
         * @param {string} [meta] What metadata to return in the response.
         * @param {CreateItemsQuestionRequest} [createItemsQuestionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createItemsQuestion(meta?: string, createItemsQuestionRequest?: CreateItemsQuestionRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateItemsQuestion200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createItemsQuestion(meta, createItemsQuestionRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new QuestionTranslation item.
         * @summary Create an Item
         * @param {string} [meta] What metadata to return in the response.
         * @param {CreateItemsQuestionTranslationRequest} [createItemsQuestionTranslationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createItemsQuestionTranslation(meta?: string, createItemsQuestionTranslationRequest?: CreateItemsQuestionTranslationRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateItemsQuestionTranslation200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createItemsQuestionTranslation(meta, createItemsQuestionTranslationRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new Questionnaire item.
         * @summary Create an Item
         * @param {string} [meta] What metadata to return in the response.
         * @param {CreateItemsQuestionnaireRequest} [createItemsQuestionnaireRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createItemsQuestionnaire(meta?: string, createItemsQuestionnaireRequest?: CreateItemsQuestionnaireRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateItemsQuestionnaire200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createItemsQuestionnaire(meta, createItemsQuestionnaireRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new QuestionnaireTranslation item.
         * @summary Create an Item
         * @param {string} [meta] What metadata to return in the response.
         * @param {CreateItemsQuestionnaireTranslationRequest} [createItemsQuestionnaireTranslationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createItemsQuestionnaireTranslation(meta?: string, createItemsQuestionnaireTranslationRequest?: CreateItemsQuestionnaireTranslationRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateItemsQuestionnaireTranslation200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createItemsQuestionnaireTranslation(meta, createItemsQuestionnaireTranslationRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new Section item.
         * @summary Create an Item
         * @param {string} [meta] What metadata to return in the response.
         * @param {CreateItemsSectionRequest} [createItemsSectionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createItemsSection(meta?: string, createItemsSectionRequest?: CreateItemsSectionRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateItemsSection200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createItemsSection(meta, createItemsSectionRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new SectionTranslation item.
         * @summary Create an Item
         * @param {string} [meta] What metadata to return in the response.
         * @param {CreateItemsSectionTranslationRequest} [createItemsSectionTranslationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createItemsSectionTranslation(meta?: string, createItemsSectionTranslationRequest?: CreateItemsSectionTranslationRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateItemsSectionTranslation200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createItemsSectionTranslation(meta, createItemsSectionTranslationRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new Version item.
         * @summary Create an Item
         * @param {string} [meta] What metadata to return in the response.
         * @param {CreateItemsVersionRequest} [createItemsVersionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createItemsVersion(meta?: string, createItemsVersionRequest?: CreateItemsVersionRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateItemsVersion200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createItemsVersion(meta, createItemsVersionRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete an existing AnswerOption item.
         * @summary Delete an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSingleItemsAnswerOption(id: ReadSingleItemsAnswerOptionIdParameter, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSingleItemsAnswerOption(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete an existing AnswerOptionTranslation item.
         * @summary Delete an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSingleItemsAnswerOptionTranslation(id: ReadSingleItemsAnswerOptionIdParameter, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSingleItemsAnswerOptionTranslation(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete an existing Article item.
         * @summary Delete an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSingleItemsArticle(id: ReadSingleItemsAnswerOptionIdParameter, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSingleItemsArticle(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete an existing ArticleCategory item.
         * @summary Delete an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSingleItemsArticleCategory(id: ReadSingleItemsAnswerOptionIdParameter, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSingleItemsArticleCategory(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete an existing ArticleTranslation item.
         * @summary Delete an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSingleItemsArticleTranslation(id: ReadSingleItemsAnswerOptionIdParameter, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSingleItemsArticleTranslation(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete an existing Condition item.
         * @summary Delete an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSingleItemsCondition(id: ReadSingleItemsAnswerOptionIdParameter, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSingleItemsCondition(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete an existing ConditionFact item.
         * @summary Delete an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSingleItemsConditionFact(id: ReadSingleItemsAnswerOptionIdParameter, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSingleItemsConditionFact(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete an existing Fact item.
         * @summary Delete an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSingleItemsFact(id: ReadSingleItemsAnswerOptionIdParameter, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSingleItemsFact(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete an existing Question item.
         * @summary Delete an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSingleItemsQuestion(id: ReadSingleItemsAnswerOptionIdParameter, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSingleItemsQuestion(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete an existing QuestionTranslation item.
         * @summary Delete an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSingleItemsQuestionTranslation(id: ReadSingleItemsAnswerOptionIdParameter, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSingleItemsQuestionTranslation(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete an existing Questionnaire item.
         * @summary Delete an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSingleItemsQuestionnaire(id: ReadSingleItemsAnswerOptionIdParameter, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSingleItemsQuestionnaire(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete an existing QuestionnaireTranslation item.
         * @summary Delete an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSingleItemsQuestionnaireTranslation(id: ReadSingleItemsAnswerOptionIdParameter, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSingleItemsQuestionnaireTranslation(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete an existing Section item.
         * @summary Delete an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSingleItemsSection(id: ReadSingleItemsAnswerOptionIdParameter, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSingleItemsSection(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete an existing SectionTranslation item.
         * @summary Delete an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSingleItemsSectionTranslation(id: ReadSingleItemsAnswerOptionIdParameter, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSingleItemsSectionTranslation(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete an existing Version item.
         * @summary Delete an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSingleItemsVersion(id: ReadSingleItemsAnswerOptionIdParameter, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSingleItemsVersion(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List the AnswerOption items.
         * @summary List Items
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {Array<string>} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readItemsAnswerOption(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReadItemsAnswerOption200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readItemsAnswerOption(fields, limit, meta, offset, sort, filter, search, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List the AnswerOptionTranslation items.
         * @summary List Items
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {Array<string>} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readItemsAnswerOptionTranslation(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReadItemsAnswerOptionTranslation200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readItemsAnswerOptionTranslation(fields, limit, meta, offset, sort, filter, search, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List the Article items.
         * @summary List Items
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {Array<string>} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readItemsArticle(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReadItemsArticle200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readItemsArticle(fields, limit, meta, offset, sort, filter, search, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List the ArticleCategory items.
         * @summary List Items
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {Array<string>} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readItemsArticleCategory(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReadItemsArticleCategory200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readItemsArticleCategory(fields, limit, meta, offset, sort, filter, search, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List the ArticleTranslation items.
         * @summary List Items
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {Array<string>} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readItemsArticleTranslation(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReadItemsArticleTranslation200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readItemsArticleTranslation(fields, limit, meta, offset, sort, filter, search, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List the Condition items.
         * @summary List Items
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {Array<string>} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readItemsCondition(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReadItemsCondition200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readItemsCondition(fields, limit, meta, offset, sort, filter, search, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List the ConditionFact items.
         * @summary List Items
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {Array<string>} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readItemsConditionFact(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReadItemsConditionFact200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readItemsConditionFact(fields, limit, meta, offset, sort, filter, search, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List the Fact items.
         * @summary List Items
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {Array<string>} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readItemsFact(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReadItemsFact200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readItemsFact(fields, limit, meta, offset, sort, filter, search, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List the Language items.
         * @summary List Items
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {Array<string>} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readItemsLanguage(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReadItemsLanguage200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readItemsLanguage(fields, limit, meta, offset, sort, filter, search, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List the Meaning items.
         * @summary List Items
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {Array<string>} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readItemsMeaning(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReadItemsMeaning200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readItemsMeaning(fields, limit, meta, offset, sort, filter, search, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List the Operator items.
         * @summary List Items
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {Array<string>} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readItemsOperator(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReadItemsOperator200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readItemsOperator(fields, limit, meta, offset, sort, filter, search, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List the Question items.
         * @summary List Items
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {Array<string>} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readItemsQuestion(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReadItemsQuestion200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readItemsQuestion(fields, limit, meta, offset, sort, filter, search, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List the QuestionTranslation items.
         * @summary List Items
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {Array<string>} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readItemsQuestionTranslation(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReadItemsQuestionTranslation200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readItemsQuestionTranslation(fields, limit, meta, offset, sort, filter, search, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List the QuestionDisplay items.
         * @summary List Items
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {Array<string>} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readItemsQuestiondisplay(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReadItemsQuestiondisplay200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readItemsQuestiondisplay(fields, limit, meta, offset, sort, filter, search, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List the Questionnaire items.
         * @summary List Items
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {Array<string>} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readItemsQuestionnaire(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReadItemsQuestionnaire200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readItemsQuestionnaire(fields, limit, meta, offset, sort, filter, search, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List the QuestionnaireTranslation items.
         * @summary List Items
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {Array<string>} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readItemsQuestionnaireTranslation(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReadItemsQuestionnaireTranslation200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readItemsQuestionnaireTranslation(fields, limit, meta, offset, sort, filter, search, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List the QuestionType items.
         * @summary List Items
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {Array<string>} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readItemsQuestiontype(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReadItemsQuestiontype200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readItemsQuestiontype(fields, limit, meta, offset, sort, filter, search, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List the Section items.
         * @summary List Items
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {Array<string>} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readItemsSection(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReadItemsSection200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readItemsSection(fields, limit, meta, offset, sort, filter, search, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List the SectionTranslation items.
         * @summary List Items
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {Array<string>} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readItemsSectionTranslation(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReadItemsSectionTranslation200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readItemsSectionTranslation(fields, limit, meta, offset, sort, filter, search, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List the Version items.
         * @summary List Items
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {Array<string>} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readItemsVersion(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReadItemsVersion200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readItemsVersion(fields, limit, meta, offset, sort, filter, search, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List the VersionContentType items.
         * @summary List Items
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {Array<string>} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readItemsVersionContentType(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReadItemsVersionContentType200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readItemsVersionContentType(fields, limit, meta, offset, sort, filter, search, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve a single AnswerOption item by unique identifier.
         * @summary Retrieve an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readSingleItemsAnswerOption(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReadSingleItemsAnswerOption200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readSingleItemsAnswerOption(id, fields, meta, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve a single AnswerOptionTranslation item by unique identifier.
         * @summary Retrieve an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readSingleItemsAnswerOptionTranslation(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReadSingleItemsAnswerOptionTranslation200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readSingleItemsAnswerOptionTranslation(id, fields, meta, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve a single Article item by unique identifier.
         * @summary Retrieve an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readSingleItemsArticle(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReadSingleItemsArticle200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readSingleItemsArticle(id, fields, meta, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve a single ArticleCategory item by unique identifier.
         * @summary Retrieve an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readSingleItemsArticleCategory(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReadSingleItemsArticleCategory200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readSingleItemsArticleCategory(id, fields, meta, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve a single ArticleTranslation item by unique identifier.
         * @summary Retrieve an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readSingleItemsArticleTranslation(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReadSingleItemsArticleTranslation200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readSingleItemsArticleTranslation(id, fields, meta, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve a single Condition item by unique identifier.
         * @summary Retrieve an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readSingleItemsCondition(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReadSingleItemsCondition200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readSingleItemsCondition(id, fields, meta, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve a single ConditionFact item by unique identifier.
         * @summary Retrieve an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readSingleItemsConditionFact(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReadSingleItemsConditionFact200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readSingleItemsConditionFact(id, fields, meta, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve a single Fact item by unique identifier.
         * @summary Retrieve an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readSingleItemsFact(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReadSingleItemsFact200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readSingleItemsFact(id, fields, meta, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve a single Language item by unique identifier.
         * @summary Retrieve an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readSingleItemsLanguage(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReadSingleItemsLanguage200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readSingleItemsLanguage(id, fields, meta, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve a single Meaning item by unique identifier.
         * @summary Retrieve an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readSingleItemsMeaning(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReadSingleItemsMeaning200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readSingleItemsMeaning(id, fields, meta, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve a single Operator item by unique identifier.
         * @summary Retrieve an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readSingleItemsOperator(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReadSingleItemsOperator200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readSingleItemsOperator(id, fields, meta, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve a single Question item by unique identifier.
         * @summary Retrieve an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readSingleItemsQuestion(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReadSingleItemsQuestion200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readSingleItemsQuestion(id, fields, meta, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve a single QuestionTranslation item by unique identifier.
         * @summary Retrieve an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readSingleItemsQuestionTranslation(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReadSingleItemsQuestionTranslation200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readSingleItemsQuestionTranslation(id, fields, meta, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve a single QuestionDisplay item by unique identifier.
         * @summary Retrieve an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readSingleItemsQuestiondisplay(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReadSingleItemsQuestiondisplay200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readSingleItemsQuestiondisplay(id, fields, meta, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve a single Questionnaire item by unique identifier.
         * @summary Retrieve an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readSingleItemsQuestionnaire(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReadSingleItemsQuestionnaire200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readSingleItemsQuestionnaire(id, fields, meta, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve a single QuestionnaireTranslation item by unique identifier.
         * @summary Retrieve an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readSingleItemsQuestionnaireTranslation(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReadSingleItemsQuestionnaireTranslation200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readSingleItemsQuestionnaireTranslation(id, fields, meta, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve a single QuestionType item by unique identifier.
         * @summary Retrieve an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readSingleItemsQuestiontype(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReadSingleItemsQuestiontype200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readSingleItemsQuestiontype(id, fields, meta, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve a single Section item by unique identifier.
         * @summary Retrieve an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readSingleItemsSection(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReadSingleItemsSection200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readSingleItemsSection(id, fields, meta, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve a single SectionTranslation item by unique identifier.
         * @summary Retrieve an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readSingleItemsSectionTranslation(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReadSingleItemsSectionTranslation200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readSingleItemsSectionTranslation(id, fields, meta, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve a single Version item by unique identifier.
         * @summary Retrieve an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readSingleItemsVersion(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReadSingleItemsVersion200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readSingleItemsVersion(id, fields, meta, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve a single VersionContentType item by unique identifier.
         * @summary Retrieve an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readSingleItemsVersionContentType(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReadSingleItemsVersionContentType200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readSingleItemsVersionContentType(id, fields, meta, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update an existing AnswerOption item.
         * @summary Update an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {ItemsAnswerOption} [itemsAnswerOption] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSingleItemsAnswerOption(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, itemsAnswerOption?: ItemsAnswerOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReadSingleItemsAnswerOption200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSingleItemsAnswerOption(id, fields, meta, itemsAnswerOption, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update an existing AnswerOptionTranslation item.
         * @summary Update an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {ItemsAnswerOptionTranslation} [itemsAnswerOptionTranslation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSingleItemsAnswerOptionTranslation(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, itemsAnswerOptionTranslation?: ItemsAnswerOptionTranslation, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReadSingleItemsAnswerOptionTranslation200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSingleItemsAnswerOptionTranslation(id, fields, meta, itemsAnswerOptionTranslation, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update an existing Article item.
         * @summary Update an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {ItemsArticle} [itemsArticle] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSingleItemsArticle(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, itemsArticle?: ItemsArticle, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReadSingleItemsArticle200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSingleItemsArticle(id, fields, meta, itemsArticle, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update an existing ArticleCategory item.
         * @summary Update an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {ItemsArticleCategory} [itemsArticleCategory] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSingleItemsArticleCategory(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, itemsArticleCategory?: ItemsArticleCategory, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReadSingleItemsArticleCategory200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSingleItemsArticleCategory(id, fields, meta, itemsArticleCategory, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update an existing ArticleTranslation item.
         * @summary Update an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {ItemsArticleTranslation} [itemsArticleTranslation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSingleItemsArticleTranslation(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, itemsArticleTranslation?: ItemsArticleTranslation, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReadSingleItemsArticleTranslation200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSingleItemsArticleTranslation(id, fields, meta, itemsArticleTranslation, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update an existing Condition item.
         * @summary Update an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {ItemsCondition} [itemsCondition] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSingleItemsCondition(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, itemsCondition?: ItemsCondition, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReadSingleItemsCondition200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSingleItemsCondition(id, fields, meta, itemsCondition, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update an existing ConditionFact item.
         * @summary Update an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {ItemsConditionFact} [itemsConditionFact] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSingleItemsConditionFact(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, itemsConditionFact?: ItemsConditionFact, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReadSingleItemsConditionFact200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSingleItemsConditionFact(id, fields, meta, itemsConditionFact, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update an existing Fact item.
         * @summary Update an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {ItemsFact} [itemsFact] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSingleItemsFact(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, itemsFact?: ItemsFact, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReadSingleItemsFact200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSingleItemsFact(id, fields, meta, itemsFact, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update an existing Question item.
         * @summary Update an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {ItemsQuestion} [itemsQuestion] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSingleItemsQuestion(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, itemsQuestion?: ItemsQuestion, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReadSingleItemsQuestion200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSingleItemsQuestion(id, fields, meta, itemsQuestion, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update an existing QuestionTranslation item.
         * @summary Update an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {ItemsQuestionTranslation} [itemsQuestionTranslation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSingleItemsQuestionTranslation(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, itemsQuestionTranslation?: ItemsQuestionTranslation, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReadSingleItemsQuestionTranslation200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSingleItemsQuestionTranslation(id, fields, meta, itemsQuestionTranslation, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update an existing Questionnaire item.
         * @summary Update an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {ItemsQuestionnaire} [itemsQuestionnaire] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSingleItemsQuestionnaire(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, itemsQuestionnaire?: ItemsQuestionnaire, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReadSingleItemsQuestionnaire200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSingleItemsQuestionnaire(id, fields, meta, itemsQuestionnaire, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update an existing QuestionnaireTranslation item.
         * @summary Update an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {ItemsQuestionnaireTranslation} [itemsQuestionnaireTranslation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSingleItemsQuestionnaireTranslation(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, itemsQuestionnaireTranslation?: ItemsQuestionnaireTranslation, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReadSingleItemsQuestionnaireTranslation200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSingleItemsQuestionnaireTranslation(id, fields, meta, itemsQuestionnaireTranslation, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update an existing Section item.
         * @summary Update an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {ItemsSection} [itemsSection] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSingleItemsSection(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, itemsSection?: ItemsSection, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReadSingleItemsSection200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSingleItemsSection(id, fields, meta, itemsSection, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update an existing SectionTranslation item.
         * @summary Update an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {ItemsSectionTranslation} [itemsSectionTranslation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSingleItemsSectionTranslation(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, itemsSectionTranslation?: ItemsSectionTranslation, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReadSingleItemsSectionTranslation200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSingleItemsSectionTranslation(id, fields, meta, itemsSectionTranslation, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ItemsApi - factory interface
 * @export
 */
export const ItemsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ItemsApiFp(configuration)
    return {
        /**
         * Create a new AnswerOption item.
         * @summary Create an Item
         * @param {string} [meta] What metadata to return in the response.
         * @param {CreateItemsAnswerOptionRequest} [createItemsAnswerOptionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createItemsAnswerOption(meta?: string, createItemsAnswerOptionRequest?: CreateItemsAnswerOptionRequest, options?: any): AxiosPromise<CreateItemsAnswerOption200Response> {
            return localVarFp.createItemsAnswerOption(meta, createItemsAnswerOptionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new AnswerOptionTranslation item.
         * @summary Create an Item
         * @param {string} [meta] What metadata to return in the response.
         * @param {CreateItemsAnswerOptionTranslationRequest} [createItemsAnswerOptionTranslationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createItemsAnswerOptionTranslation(meta?: string, createItemsAnswerOptionTranslationRequest?: CreateItemsAnswerOptionTranslationRequest, options?: any): AxiosPromise<CreateItemsAnswerOptionTranslation200Response> {
            return localVarFp.createItemsAnswerOptionTranslation(meta, createItemsAnswerOptionTranslationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new Article item.
         * @summary Create an Item
         * @param {string} [meta] What metadata to return in the response.
         * @param {CreateItemsArticleRequest} [createItemsArticleRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createItemsArticle(meta?: string, createItemsArticleRequest?: CreateItemsArticleRequest, options?: any): AxiosPromise<CreateItemsArticle200Response> {
            return localVarFp.createItemsArticle(meta, createItemsArticleRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new ArticleCategory item.
         * @summary Create an Item
         * @param {string} [meta] What metadata to return in the response.
         * @param {CreateItemsArticleCategoryRequest} [createItemsArticleCategoryRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createItemsArticleCategory(meta?: string, createItemsArticleCategoryRequest?: CreateItemsArticleCategoryRequest, options?: any): AxiosPromise<CreateItemsArticleCategory200Response> {
            return localVarFp.createItemsArticleCategory(meta, createItemsArticleCategoryRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new ArticleTranslation item.
         * @summary Create an Item
         * @param {string} [meta] What metadata to return in the response.
         * @param {CreateItemsArticleTranslationRequest} [createItemsArticleTranslationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createItemsArticleTranslation(meta?: string, createItemsArticleTranslationRequest?: CreateItemsArticleTranslationRequest, options?: any): AxiosPromise<CreateItemsArticleTranslation200Response> {
            return localVarFp.createItemsArticleTranslation(meta, createItemsArticleTranslationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new Condition item.
         * @summary Create an Item
         * @param {string} [meta] What metadata to return in the response.
         * @param {CreateItemsConditionRequest} [createItemsConditionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createItemsCondition(meta?: string, createItemsConditionRequest?: CreateItemsConditionRequest, options?: any): AxiosPromise<CreateItemsCondition200Response> {
            return localVarFp.createItemsCondition(meta, createItemsConditionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new ConditionFact item.
         * @summary Create an Item
         * @param {string} [meta] What metadata to return in the response.
         * @param {CreateItemsConditionFactRequest} [createItemsConditionFactRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createItemsConditionFact(meta?: string, createItemsConditionFactRequest?: CreateItemsConditionFactRequest, options?: any): AxiosPromise<CreateItemsConditionFact200Response> {
            return localVarFp.createItemsConditionFact(meta, createItemsConditionFactRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new Fact item.
         * @summary Create an Item
         * @param {string} [meta] What metadata to return in the response.
         * @param {CreateItemsFactRequest} [createItemsFactRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createItemsFact(meta?: string, createItemsFactRequest?: CreateItemsFactRequest, options?: any): AxiosPromise<CreateItemsFact200Response> {
            return localVarFp.createItemsFact(meta, createItemsFactRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new Question item.
         * @summary Create an Item
         * @param {string} [meta] What metadata to return in the response.
         * @param {CreateItemsQuestionRequest} [createItemsQuestionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createItemsQuestion(meta?: string, createItemsQuestionRequest?: CreateItemsQuestionRequest, options?: any): AxiosPromise<CreateItemsQuestion200Response> {
            return localVarFp.createItemsQuestion(meta, createItemsQuestionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new QuestionTranslation item.
         * @summary Create an Item
         * @param {string} [meta] What metadata to return in the response.
         * @param {CreateItemsQuestionTranslationRequest} [createItemsQuestionTranslationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createItemsQuestionTranslation(meta?: string, createItemsQuestionTranslationRequest?: CreateItemsQuestionTranslationRequest, options?: any): AxiosPromise<CreateItemsQuestionTranslation200Response> {
            return localVarFp.createItemsQuestionTranslation(meta, createItemsQuestionTranslationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new Questionnaire item.
         * @summary Create an Item
         * @param {string} [meta] What metadata to return in the response.
         * @param {CreateItemsQuestionnaireRequest} [createItemsQuestionnaireRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createItemsQuestionnaire(meta?: string, createItemsQuestionnaireRequest?: CreateItemsQuestionnaireRequest, options?: any): AxiosPromise<CreateItemsQuestionnaire200Response> {
            return localVarFp.createItemsQuestionnaire(meta, createItemsQuestionnaireRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new QuestionnaireTranslation item.
         * @summary Create an Item
         * @param {string} [meta] What metadata to return in the response.
         * @param {CreateItemsQuestionnaireTranslationRequest} [createItemsQuestionnaireTranslationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createItemsQuestionnaireTranslation(meta?: string, createItemsQuestionnaireTranslationRequest?: CreateItemsQuestionnaireTranslationRequest, options?: any): AxiosPromise<CreateItemsQuestionnaireTranslation200Response> {
            return localVarFp.createItemsQuestionnaireTranslation(meta, createItemsQuestionnaireTranslationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new Section item.
         * @summary Create an Item
         * @param {string} [meta] What metadata to return in the response.
         * @param {CreateItemsSectionRequest} [createItemsSectionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createItemsSection(meta?: string, createItemsSectionRequest?: CreateItemsSectionRequest, options?: any): AxiosPromise<CreateItemsSection200Response> {
            return localVarFp.createItemsSection(meta, createItemsSectionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new SectionTranslation item.
         * @summary Create an Item
         * @param {string} [meta] What metadata to return in the response.
         * @param {CreateItemsSectionTranslationRequest} [createItemsSectionTranslationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createItemsSectionTranslation(meta?: string, createItemsSectionTranslationRequest?: CreateItemsSectionTranslationRequest, options?: any): AxiosPromise<CreateItemsSectionTranslation200Response> {
            return localVarFp.createItemsSectionTranslation(meta, createItemsSectionTranslationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new Version item.
         * @summary Create an Item
         * @param {string} [meta] What metadata to return in the response.
         * @param {CreateItemsVersionRequest} [createItemsVersionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createItemsVersion(meta?: string, createItemsVersionRequest?: CreateItemsVersionRequest, options?: any): AxiosPromise<CreateItemsVersion200Response> {
            return localVarFp.createItemsVersion(meta, createItemsVersionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an existing AnswerOption item.
         * @summary Delete an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSingleItemsAnswerOption(id: ReadSingleItemsAnswerOptionIdParameter, options?: any): AxiosPromise<void> {
            return localVarFp.deleteSingleItemsAnswerOption(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an existing AnswerOptionTranslation item.
         * @summary Delete an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSingleItemsAnswerOptionTranslation(id: ReadSingleItemsAnswerOptionIdParameter, options?: any): AxiosPromise<void> {
            return localVarFp.deleteSingleItemsAnswerOptionTranslation(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an existing Article item.
         * @summary Delete an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSingleItemsArticle(id: ReadSingleItemsAnswerOptionIdParameter, options?: any): AxiosPromise<void> {
            return localVarFp.deleteSingleItemsArticle(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an existing ArticleCategory item.
         * @summary Delete an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSingleItemsArticleCategory(id: ReadSingleItemsAnswerOptionIdParameter, options?: any): AxiosPromise<void> {
            return localVarFp.deleteSingleItemsArticleCategory(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an existing ArticleTranslation item.
         * @summary Delete an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSingleItemsArticleTranslation(id: ReadSingleItemsAnswerOptionIdParameter, options?: any): AxiosPromise<void> {
            return localVarFp.deleteSingleItemsArticleTranslation(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an existing Condition item.
         * @summary Delete an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSingleItemsCondition(id: ReadSingleItemsAnswerOptionIdParameter, options?: any): AxiosPromise<void> {
            return localVarFp.deleteSingleItemsCondition(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an existing ConditionFact item.
         * @summary Delete an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSingleItemsConditionFact(id: ReadSingleItemsAnswerOptionIdParameter, options?: any): AxiosPromise<void> {
            return localVarFp.deleteSingleItemsConditionFact(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an existing Fact item.
         * @summary Delete an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSingleItemsFact(id: ReadSingleItemsAnswerOptionIdParameter, options?: any): AxiosPromise<void> {
            return localVarFp.deleteSingleItemsFact(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an existing Question item.
         * @summary Delete an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSingleItemsQuestion(id: ReadSingleItemsAnswerOptionIdParameter, options?: any): AxiosPromise<void> {
            return localVarFp.deleteSingleItemsQuestion(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an existing QuestionTranslation item.
         * @summary Delete an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSingleItemsQuestionTranslation(id: ReadSingleItemsAnswerOptionIdParameter, options?: any): AxiosPromise<void> {
            return localVarFp.deleteSingleItemsQuestionTranslation(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an existing Questionnaire item.
         * @summary Delete an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSingleItemsQuestionnaire(id: ReadSingleItemsAnswerOptionIdParameter, options?: any): AxiosPromise<void> {
            return localVarFp.deleteSingleItemsQuestionnaire(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an existing QuestionnaireTranslation item.
         * @summary Delete an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSingleItemsQuestionnaireTranslation(id: ReadSingleItemsAnswerOptionIdParameter, options?: any): AxiosPromise<void> {
            return localVarFp.deleteSingleItemsQuestionnaireTranslation(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an existing Section item.
         * @summary Delete an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSingleItemsSection(id: ReadSingleItemsAnswerOptionIdParameter, options?: any): AxiosPromise<void> {
            return localVarFp.deleteSingleItemsSection(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an existing SectionTranslation item.
         * @summary Delete an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSingleItemsSectionTranslation(id: ReadSingleItemsAnswerOptionIdParameter, options?: any): AxiosPromise<void> {
            return localVarFp.deleteSingleItemsSectionTranslation(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an existing Version item.
         * @summary Delete an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSingleItemsVersion(id: ReadSingleItemsAnswerOptionIdParameter, options?: any): AxiosPromise<void> {
            return localVarFp.deleteSingleItemsVersion(id, options).then((request) => request(axios, basePath));
        },
        /**
         * List the AnswerOption items.
         * @summary List Items
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {Array<string>} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readItemsAnswerOption(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, options?: any): AxiosPromise<ReadItemsAnswerOption200Response> {
            return localVarFp.readItemsAnswerOption(fields, limit, meta, offset, sort, filter, search, options).then((request) => request(axios, basePath));
        },
        /**
         * List the AnswerOptionTranslation items.
         * @summary List Items
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {Array<string>} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readItemsAnswerOptionTranslation(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, options?: any): AxiosPromise<ReadItemsAnswerOptionTranslation200Response> {
            return localVarFp.readItemsAnswerOptionTranslation(fields, limit, meta, offset, sort, filter, search, options).then((request) => request(axios, basePath));
        },
        /**
         * List the Article items.
         * @summary List Items
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {Array<string>} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readItemsArticle(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, options?: any): AxiosPromise<ReadItemsArticle200Response> {
            return localVarFp.readItemsArticle(fields, limit, meta, offset, sort, filter, search, options).then((request) => request(axios, basePath));
        },
        /**
         * List the ArticleCategory items.
         * @summary List Items
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {Array<string>} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readItemsArticleCategory(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, options?: any): AxiosPromise<ReadItemsArticleCategory200Response> {
            return localVarFp.readItemsArticleCategory(fields, limit, meta, offset, sort, filter, search, options).then((request) => request(axios, basePath));
        },
        /**
         * List the ArticleTranslation items.
         * @summary List Items
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {Array<string>} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readItemsArticleTranslation(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, options?: any): AxiosPromise<ReadItemsArticleTranslation200Response> {
            return localVarFp.readItemsArticleTranslation(fields, limit, meta, offset, sort, filter, search, options).then((request) => request(axios, basePath));
        },
        /**
         * List the Condition items.
         * @summary List Items
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {Array<string>} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readItemsCondition(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, options?: any): AxiosPromise<ReadItemsCondition200Response> {
            return localVarFp.readItemsCondition(fields, limit, meta, offset, sort, filter, search, options).then((request) => request(axios, basePath));
        },
        /**
         * List the ConditionFact items.
         * @summary List Items
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {Array<string>} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readItemsConditionFact(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, options?: any): AxiosPromise<ReadItemsConditionFact200Response> {
            return localVarFp.readItemsConditionFact(fields, limit, meta, offset, sort, filter, search, options).then((request) => request(axios, basePath));
        },
        /**
         * List the Fact items.
         * @summary List Items
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {Array<string>} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readItemsFact(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, options?: any): AxiosPromise<ReadItemsFact200Response> {
            return localVarFp.readItemsFact(fields, limit, meta, offset, sort, filter, search, options).then((request) => request(axios, basePath));
        },
        /**
         * List the Language items.
         * @summary List Items
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {Array<string>} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readItemsLanguage(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, options?: any): AxiosPromise<ReadItemsLanguage200Response> {
            return localVarFp.readItemsLanguage(fields, limit, meta, offset, sort, filter, search, options).then((request) => request(axios, basePath));
        },
        /**
         * List the Meaning items.
         * @summary List Items
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {Array<string>} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readItemsMeaning(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, options?: any): AxiosPromise<ReadItemsMeaning200Response> {
            return localVarFp.readItemsMeaning(fields, limit, meta, offset, sort, filter, search, options).then((request) => request(axios, basePath));
        },
        /**
         * List the Operator items.
         * @summary List Items
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {Array<string>} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readItemsOperator(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, options?: any): AxiosPromise<ReadItemsOperator200Response> {
            return localVarFp.readItemsOperator(fields, limit, meta, offset, sort, filter, search, options).then((request) => request(axios, basePath));
        },
        /**
         * List the Question items.
         * @summary List Items
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {Array<string>} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readItemsQuestion(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, options?: any): AxiosPromise<ReadItemsQuestion200Response> {
            return localVarFp.readItemsQuestion(fields, limit, meta, offset, sort, filter, search, options).then((request) => request(axios, basePath));
        },
        /**
         * List the QuestionTranslation items.
         * @summary List Items
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {Array<string>} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readItemsQuestionTranslation(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, options?: any): AxiosPromise<ReadItemsQuestionTranslation200Response> {
            return localVarFp.readItemsQuestionTranslation(fields, limit, meta, offset, sort, filter, search, options).then((request) => request(axios, basePath));
        },
        /**
         * List the QuestionDisplay items.
         * @summary List Items
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {Array<string>} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readItemsQuestiondisplay(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, options?: any): AxiosPromise<ReadItemsQuestiondisplay200Response> {
            return localVarFp.readItemsQuestiondisplay(fields, limit, meta, offset, sort, filter, search, options).then((request) => request(axios, basePath));
        },
        /**
         * List the Questionnaire items.
         * @summary List Items
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {Array<string>} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readItemsQuestionnaire(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, options?: any): AxiosPromise<ReadItemsQuestionnaire200Response> {
            return localVarFp.readItemsQuestionnaire(fields, limit, meta, offset, sort, filter, search, options).then((request) => request(axios, basePath));
        },
        /**
         * List the QuestionnaireTranslation items.
         * @summary List Items
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {Array<string>} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readItemsQuestionnaireTranslation(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, options?: any): AxiosPromise<ReadItemsQuestionnaireTranslation200Response> {
            return localVarFp.readItemsQuestionnaireTranslation(fields, limit, meta, offset, sort, filter, search, options).then((request) => request(axios, basePath));
        },
        /**
         * List the QuestionType items.
         * @summary List Items
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {Array<string>} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readItemsQuestiontype(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, options?: any): AxiosPromise<ReadItemsQuestiontype200Response> {
            return localVarFp.readItemsQuestiontype(fields, limit, meta, offset, sort, filter, search, options).then((request) => request(axios, basePath));
        },
        /**
         * List the Section items.
         * @summary List Items
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {Array<string>} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readItemsSection(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, options?: any): AxiosPromise<ReadItemsSection200Response> {
            return localVarFp.readItemsSection(fields, limit, meta, offset, sort, filter, search, options).then((request) => request(axios, basePath));
        },
        /**
         * List the SectionTranslation items.
         * @summary List Items
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {Array<string>} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readItemsSectionTranslation(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, options?: any): AxiosPromise<ReadItemsSectionTranslation200Response> {
            return localVarFp.readItemsSectionTranslation(fields, limit, meta, offset, sort, filter, search, options).then((request) => request(axios, basePath));
        },
        /**
         * List the Version items.
         * @summary List Items
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {Array<string>} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readItemsVersion(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, options?: any): AxiosPromise<ReadItemsVersion200Response> {
            return localVarFp.readItemsVersion(fields, limit, meta, offset, sort, filter, search, options).then((request) => request(axios, basePath));
        },
        /**
         * List the VersionContentType items.
         * @summary List Items
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {Array<string>} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readItemsVersionContentType(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, options?: any): AxiosPromise<ReadItemsVersionContentType200Response> {
            return localVarFp.readItemsVersionContentType(fields, limit, meta, offset, sort, filter, search, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a single AnswerOption item by unique identifier.
         * @summary Retrieve an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readSingleItemsAnswerOption(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, options?: any): AxiosPromise<ReadSingleItemsAnswerOption200Response> {
            return localVarFp.readSingleItemsAnswerOption(id, fields, meta, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a single AnswerOptionTranslation item by unique identifier.
         * @summary Retrieve an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readSingleItemsAnswerOptionTranslation(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, options?: any): AxiosPromise<ReadSingleItemsAnswerOptionTranslation200Response> {
            return localVarFp.readSingleItemsAnswerOptionTranslation(id, fields, meta, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a single Article item by unique identifier.
         * @summary Retrieve an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readSingleItemsArticle(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, options?: any): AxiosPromise<ReadSingleItemsArticle200Response> {
            return localVarFp.readSingleItemsArticle(id, fields, meta, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a single ArticleCategory item by unique identifier.
         * @summary Retrieve an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readSingleItemsArticleCategory(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, options?: any): AxiosPromise<ReadSingleItemsArticleCategory200Response> {
            return localVarFp.readSingleItemsArticleCategory(id, fields, meta, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a single ArticleTranslation item by unique identifier.
         * @summary Retrieve an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readSingleItemsArticleTranslation(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, options?: any): AxiosPromise<ReadSingleItemsArticleTranslation200Response> {
            return localVarFp.readSingleItemsArticleTranslation(id, fields, meta, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a single Condition item by unique identifier.
         * @summary Retrieve an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readSingleItemsCondition(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, options?: any): AxiosPromise<ReadSingleItemsCondition200Response> {
            return localVarFp.readSingleItemsCondition(id, fields, meta, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a single ConditionFact item by unique identifier.
         * @summary Retrieve an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readSingleItemsConditionFact(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, options?: any): AxiosPromise<ReadSingleItemsConditionFact200Response> {
            return localVarFp.readSingleItemsConditionFact(id, fields, meta, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a single Fact item by unique identifier.
         * @summary Retrieve an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readSingleItemsFact(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, options?: any): AxiosPromise<ReadSingleItemsFact200Response> {
            return localVarFp.readSingleItemsFact(id, fields, meta, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a single Language item by unique identifier.
         * @summary Retrieve an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readSingleItemsLanguage(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, options?: any): AxiosPromise<ReadSingleItemsLanguage200Response> {
            return localVarFp.readSingleItemsLanguage(id, fields, meta, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a single Meaning item by unique identifier.
         * @summary Retrieve an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readSingleItemsMeaning(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, options?: any): AxiosPromise<ReadSingleItemsMeaning200Response> {
            return localVarFp.readSingleItemsMeaning(id, fields, meta, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a single Operator item by unique identifier.
         * @summary Retrieve an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readSingleItemsOperator(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, options?: any): AxiosPromise<ReadSingleItemsOperator200Response> {
            return localVarFp.readSingleItemsOperator(id, fields, meta, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a single Question item by unique identifier.
         * @summary Retrieve an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readSingleItemsQuestion(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, options?: any): AxiosPromise<ReadSingleItemsQuestion200Response> {
            return localVarFp.readSingleItemsQuestion(id, fields, meta, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a single QuestionTranslation item by unique identifier.
         * @summary Retrieve an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readSingleItemsQuestionTranslation(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, options?: any): AxiosPromise<ReadSingleItemsQuestionTranslation200Response> {
            return localVarFp.readSingleItemsQuestionTranslation(id, fields, meta, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a single QuestionDisplay item by unique identifier.
         * @summary Retrieve an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readSingleItemsQuestiondisplay(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, options?: any): AxiosPromise<ReadSingleItemsQuestiondisplay200Response> {
            return localVarFp.readSingleItemsQuestiondisplay(id, fields, meta, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a single Questionnaire item by unique identifier.
         * @summary Retrieve an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readSingleItemsQuestionnaire(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, options?: any): AxiosPromise<ReadSingleItemsQuestionnaire200Response> {
            return localVarFp.readSingleItemsQuestionnaire(id, fields, meta, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a single QuestionnaireTranslation item by unique identifier.
         * @summary Retrieve an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readSingleItemsQuestionnaireTranslation(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, options?: any): AxiosPromise<ReadSingleItemsQuestionnaireTranslation200Response> {
            return localVarFp.readSingleItemsQuestionnaireTranslation(id, fields, meta, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a single QuestionType item by unique identifier.
         * @summary Retrieve an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readSingleItemsQuestiontype(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, options?: any): AxiosPromise<ReadSingleItemsQuestiontype200Response> {
            return localVarFp.readSingleItemsQuestiontype(id, fields, meta, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a single Section item by unique identifier.
         * @summary Retrieve an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readSingleItemsSection(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, options?: any): AxiosPromise<ReadSingleItemsSection200Response> {
            return localVarFp.readSingleItemsSection(id, fields, meta, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a single SectionTranslation item by unique identifier.
         * @summary Retrieve an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readSingleItemsSectionTranslation(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, options?: any): AxiosPromise<ReadSingleItemsSectionTranslation200Response> {
            return localVarFp.readSingleItemsSectionTranslation(id, fields, meta, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a single Version item by unique identifier.
         * @summary Retrieve an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readSingleItemsVersion(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, options?: any): AxiosPromise<ReadSingleItemsVersion200Response> {
            return localVarFp.readSingleItemsVersion(id, fields, meta, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a single VersionContentType item by unique identifier.
         * @summary Retrieve an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readSingleItemsVersionContentType(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, options?: any): AxiosPromise<ReadSingleItemsVersionContentType200Response> {
            return localVarFp.readSingleItemsVersionContentType(id, fields, meta, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an existing AnswerOption item.
         * @summary Update an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {ItemsAnswerOption} [itemsAnswerOption] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSingleItemsAnswerOption(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, itemsAnswerOption?: ItemsAnswerOption, options?: any): AxiosPromise<ReadSingleItemsAnswerOption200Response> {
            return localVarFp.updateSingleItemsAnswerOption(id, fields, meta, itemsAnswerOption, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an existing AnswerOptionTranslation item.
         * @summary Update an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {ItemsAnswerOptionTranslation} [itemsAnswerOptionTranslation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSingleItemsAnswerOptionTranslation(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, itemsAnswerOptionTranslation?: ItemsAnswerOptionTranslation, options?: any): AxiosPromise<ReadSingleItemsAnswerOptionTranslation200Response> {
            return localVarFp.updateSingleItemsAnswerOptionTranslation(id, fields, meta, itemsAnswerOptionTranslation, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an existing Article item.
         * @summary Update an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {ItemsArticle} [itemsArticle] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSingleItemsArticle(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, itemsArticle?: ItemsArticle, options?: any): AxiosPromise<ReadSingleItemsArticle200Response> {
            return localVarFp.updateSingleItemsArticle(id, fields, meta, itemsArticle, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an existing ArticleCategory item.
         * @summary Update an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {ItemsArticleCategory} [itemsArticleCategory] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSingleItemsArticleCategory(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, itemsArticleCategory?: ItemsArticleCategory, options?: any): AxiosPromise<ReadSingleItemsArticleCategory200Response> {
            return localVarFp.updateSingleItemsArticleCategory(id, fields, meta, itemsArticleCategory, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an existing ArticleTranslation item.
         * @summary Update an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {ItemsArticleTranslation} [itemsArticleTranslation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSingleItemsArticleTranslation(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, itemsArticleTranslation?: ItemsArticleTranslation, options?: any): AxiosPromise<ReadSingleItemsArticleTranslation200Response> {
            return localVarFp.updateSingleItemsArticleTranslation(id, fields, meta, itemsArticleTranslation, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an existing Condition item.
         * @summary Update an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {ItemsCondition} [itemsCondition] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSingleItemsCondition(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, itemsCondition?: ItemsCondition, options?: any): AxiosPromise<ReadSingleItemsCondition200Response> {
            return localVarFp.updateSingleItemsCondition(id, fields, meta, itemsCondition, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an existing ConditionFact item.
         * @summary Update an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {ItemsConditionFact} [itemsConditionFact] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSingleItemsConditionFact(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, itemsConditionFact?: ItemsConditionFact, options?: any): AxiosPromise<ReadSingleItemsConditionFact200Response> {
            return localVarFp.updateSingleItemsConditionFact(id, fields, meta, itemsConditionFact, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an existing Fact item.
         * @summary Update an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {ItemsFact} [itemsFact] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSingleItemsFact(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, itemsFact?: ItemsFact, options?: any): AxiosPromise<ReadSingleItemsFact200Response> {
            return localVarFp.updateSingleItemsFact(id, fields, meta, itemsFact, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an existing Question item.
         * @summary Update an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {ItemsQuestion} [itemsQuestion] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSingleItemsQuestion(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, itemsQuestion?: ItemsQuestion, options?: any): AxiosPromise<ReadSingleItemsQuestion200Response> {
            return localVarFp.updateSingleItemsQuestion(id, fields, meta, itemsQuestion, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an existing QuestionTranslation item.
         * @summary Update an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {ItemsQuestionTranslation} [itemsQuestionTranslation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSingleItemsQuestionTranslation(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, itemsQuestionTranslation?: ItemsQuestionTranslation, options?: any): AxiosPromise<ReadSingleItemsQuestionTranslation200Response> {
            return localVarFp.updateSingleItemsQuestionTranslation(id, fields, meta, itemsQuestionTranslation, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an existing Questionnaire item.
         * @summary Update an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {ItemsQuestionnaire} [itemsQuestionnaire] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSingleItemsQuestionnaire(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, itemsQuestionnaire?: ItemsQuestionnaire, options?: any): AxiosPromise<ReadSingleItemsQuestionnaire200Response> {
            return localVarFp.updateSingleItemsQuestionnaire(id, fields, meta, itemsQuestionnaire, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an existing QuestionnaireTranslation item.
         * @summary Update an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {ItemsQuestionnaireTranslation} [itemsQuestionnaireTranslation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSingleItemsQuestionnaireTranslation(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, itemsQuestionnaireTranslation?: ItemsQuestionnaireTranslation, options?: any): AxiosPromise<ReadSingleItemsQuestionnaireTranslation200Response> {
            return localVarFp.updateSingleItemsQuestionnaireTranslation(id, fields, meta, itemsQuestionnaireTranslation, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an existing Section item.
         * @summary Update an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {ItemsSection} [itemsSection] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSingleItemsSection(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, itemsSection?: ItemsSection, options?: any): AxiosPromise<ReadSingleItemsSection200Response> {
            return localVarFp.updateSingleItemsSection(id, fields, meta, itemsSection, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an existing SectionTranslation item.
         * @summary Update an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {ItemsSectionTranslation} [itemsSectionTranslation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSingleItemsSectionTranslation(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, itemsSectionTranslation?: ItemsSectionTranslation, options?: any): AxiosPromise<ReadSingleItemsSectionTranslation200Response> {
            return localVarFp.updateSingleItemsSectionTranslation(id, fields, meta, itemsSectionTranslation, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ItemsApi - object-oriented interface
 * @export
 * @class ItemsApi
 * @extends {BaseAPI}
 */
export class ItemsApi extends BaseAPI {
    /**
     * Create a new AnswerOption item.
     * @summary Create an Item
     * @param {string} [meta] What metadata to return in the response.
     * @param {CreateItemsAnswerOptionRequest} [createItemsAnswerOptionRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public createItemsAnswerOption(meta?: string, createItemsAnswerOptionRequest?: CreateItemsAnswerOptionRequest, options?: AxiosRequestConfig) {
        return ItemsApiFp(this.configuration).createItemsAnswerOption(meta, createItemsAnswerOptionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new AnswerOptionTranslation item.
     * @summary Create an Item
     * @param {string} [meta] What metadata to return in the response.
     * @param {CreateItemsAnswerOptionTranslationRequest} [createItemsAnswerOptionTranslationRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public createItemsAnswerOptionTranslation(meta?: string, createItemsAnswerOptionTranslationRequest?: CreateItemsAnswerOptionTranslationRequest, options?: AxiosRequestConfig) {
        return ItemsApiFp(this.configuration).createItemsAnswerOptionTranslation(meta, createItemsAnswerOptionTranslationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new Article item.
     * @summary Create an Item
     * @param {string} [meta] What metadata to return in the response.
     * @param {CreateItemsArticleRequest} [createItemsArticleRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public createItemsArticle(meta?: string, createItemsArticleRequest?: CreateItemsArticleRequest, options?: AxiosRequestConfig) {
        return ItemsApiFp(this.configuration).createItemsArticle(meta, createItemsArticleRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new ArticleCategory item.
     * @summary Create an Item
     * @param {string} [meta] What metadata to return in the response.
     * @param {CreateItemsArticleCategoryRequest} [createItemsArticleCategoryRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public createItemsArticleCategory(meta?: string, createItemsArticleCategoryRequest?: CreateItemsArticleCategoryRequest, options?: AxiosRequestConfig) {
        return ItemsApiFp(this.configuration).createItemsArticleCategory(meta, createItemsArticleCategoryRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new ArticleTranslation item.
     * @summary Create an Item
     * @param {string} [meta] What metadata to return in the response.
     * @param {CreateItemsArticleTranslationRequest} [createItemsArticleTranslationRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public createItemsArticleTranslation(meta?: string, createItemsArticleTranslationRequest?: CreateItemsArticleTranslationRequest, options?: AxiosRequestConfig) {
        return ItemsApiFp(this.configuration).createItemsArticleTranslation(meta, createItemsArticleTranslationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new Condition item.
     * @summary Create an Item
     * @param {string} [meta] What metadata to return in the response.
     * @param {CreateItemsConditionRequest} [createItemsConditionRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public createItemsCondition(meta?: string, createItemsConditionRequest?: CreateItemsConditionRequest, options?: AxiosRequestConfig) {
        return ItemsApiFp(this.configuration).createItemsCondition(meta, createItemsConditionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new ConditionFact item.
     * @summary Create an Item
     * @param {string} [meta] What metadata to return in the response.
     * @param {CreateItemsConditionFactRequest} [createItemsConditionFactRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public createItemsConditionFact(meta?: string, createItemsConditionFactRequest?: CreateItemsConditionFactRequest, options?: AxiosRequestConfig) {
        return ItemsApiFp(this.configuration).createItemsConditionFact(meta, createItemsConditionFactRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new Fact item.
     * @summary Create an Item
     * @param {string} [meta] What metadata to return in the response.
     * @param {CreateItemsFactRequest} [createItemsFactRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public createItemsFact(meta?: string, createItemsFactRequest?: CreateItemsFactRequest, options?: AxiosRequestConfig) {
        return ItemsApiFp(this.configuration).createItemsFact(meta, createItemsFactRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new Question item.
     * @summary Create an Item
     * @param {string} [meta] What metadata to return in the response.
     * @param {CreateItemsQuestionRequest} [createItemsQuestionRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public createItemsQuestion(meta?: string, createItemsQuestionRequest?: CreateItemsQuestionRequest, options?: AxiosRequestConfig) {
        return ItemsApiFp(this.configuration).createItemsQuestion(meta, createItemsQuestionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new QuestionTranslation item.
     * @summary Create an Item
     * @param {string} [meta] What metadata to return in the response.
     * @param {CreateItemsQuestionTranslationRequest} [createItemsQuestionTranslationRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public createItemsQuestionTranslation(meta?: string, createItemsQuestionTranslationRequest?: CreateItemsQuestionTranslationRequest, options?: AxiosRequestConfig) {
        return ItemsApiFp(this.configuration).createItemsQuestionTranslation(meta, createItemsQuestionTranslationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new Questionnaire item.
     * @summary Create an Item
     * @param {string} [meta] What metadata to return in the response.
     * @param {CreateItemsQuestionnaireRequest} [createItemsQuestionnaireRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public createItemsQuestionnaire(meta?: string, createItemsQuestionnaireRequest?: CreateItemsQuestionnaireRequest, options?: AxiosRequestConfig) {
        return ItemsApiFp(this.configuration).createItemsQuestionnaire(meta, createItemsQuestionnaireRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new QuestionnaireTranslation item.
     * @summary Create an Item
     * @param {string} [meta] What metadata to return in the response.
     * @param {CreateItemsQuestionnaireTranslationRequest} [createItemsQuestionnaireTranslationRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public createItemsQuestionnaireTranslation(meta?: string, createItemsQuestionnaireTranslationRequest?: CreateItemsQuestionnaireTranslationRequest, options?: AxiosRequestConfig) {
        return ItemsApiFp(this.configuration).createItemsQuestionnaireTranslation(meta, createItemsQuestionnaireTranslationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new Section item.
     * @summary Create an Item
     * @param {string} [meta] What metadata to return in the response.
     * @param {CreateItemsSectionRequest} [createItemsSectionRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public createItemsSection(meta?: string, createItemsSectionRequest?: CreateItemsSectionRequest, options?: AxiosRequestConfig) {
        return ItemsApiFp(this.configuration).createItemsSection(meta, createItemsSectionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new SectionTranslation item.
     * @summary Create an Item
     * @param {string} [meta] What metadata to return in the response.
     * @param {CreateItemsSectionTranslationRequest} [createItemsSectionTranslationRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public createItemsSectionTranslation(meta?: string, createItemsSectionTranslationRequest?: CreateItemsSectionTranslationRequest, options?: AxiosRequestConfig) {
        return ItemsApiFp(this.configuration).createItemsSectionTranslation(meta, createItemsSectionTranslationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new Version item.
     * @summary Create an Item
     * @param {string} [meta] What metadata to return in the response.
     * @param {CreateItemsVersionRequest} [createItemsVersionRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public createItemsVersion(meta?: string, createItemsVersionRequest?: CreateItemsVersionRequest, options?: AxiosRequestConfig) {
        return ItemsApiFp(this.configuration).createItemsVersion(meta, createItemsVersionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an existing AnswerOption item.
     * @summary Delete an Item
     * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public deleteSingleItemsAnswerOption(id: ReadSingleItemsAnswerOptionIdParameter, options?: AxiosRequestConfig) {
        return ItemsApiFp(this.configuration).deleteSingleItemsAnswerOption(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an existing AnswerOptionTranslation item.
     * @summary Delete an Item
     * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public deleteSingleItemsAnswerOptionTranslation(id: ReadSingleItemsAnswerOptionIdParameter, options?: AxiosRequestConfig) {
        return ItemsApiFp(this.configuration).deleteSingleItemsAnswerOptionTranslation(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an existing Article item.
     * @summary Delete an Item
     * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public deleteSingleItemsArticle(id: ReadSingleItemsAnswerOptionIdParameter, options?: AxiosRequestConfig) {
        return ItemsApiFp(this.configuration).deleteSingleItemsArticle(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an existing ArticleCategory item.
     * @summary Delete an Item
     * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public deleteSingleItemsArticleCategory(id: ReadSingleItemsAnswerOptionIdParameter, options?: AxiosRequestConfig) {
        return ItemsApiFp(this.configuration).deleteSingleItemsArticleCategory(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an existing ArticleTranslation item.
     * @summary Delete an Item
     * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public deleteSingleItemsArticleTranslation(id: ReadSingleItemsAnswerOptionIdParameter, options?: AxiosRequestConfig) {
        return ItemsApiFp(this.configuration).deleteSingleItemsArticleTranslation(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an existing Condition item.
     * @summary Delete an Item
     * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public deleteSingleItemsCondition(id: ReadSingleItemsAnswerOptionIdParameter, options?: AxiosRequestConfig) {
        return ItemsApiFp(this.configuration).deleteSingleItemsCondition(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an existing ConditionFact item.
     * @summary Delete an Item
     * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public deleteSingleItemsConditionFact(id: ReadSingleItemsAnswerOptionIdParameter, options?: AxiosRequestConfig) {
        return ItemsApiFp(this.configuration).deleteSingleItemsConditionFact(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an existing Fact item.
     * @summary Delete an Item
     * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public deleteSingleItemsFact(id: ReadSingleItemsAnswerOptionIdParameter, options?: AxiosRequestConfig) {
        return ItemsApiFp(this.configuration).deleteSingleItemsFact(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an existing Question item.
     * @summary Delete an Item
     * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public deleteSingleItemsQuestion(id: ReadSingleItemsAnswerOptionIdParameter, options?: AxiosRequestConfig) {
        return ItemsApiFp(this.configuration).deleteSingleItemsQuestion(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an existing QuestionTranslation item.
     * @summary Delete an Item
     * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public deleteSingleItemsQuestionTranslation(id: ReadSingleItemsAnswerOptionIdParameter, options?: AxiosRequestConfig) {
        return ItemsApiFp(this.configuration).deleteSingleItemsQuestionTranslation(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an existing Questionnaire item.
     * @summary Delete an Item
     * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public deleteSingleItemsQuestionnaire(id: ReadSingleItemsAnswerOptionIdParameter, options?: AxiosRequestConfig) {
        return ItemsApiFp(this.configuration).deleteSingleItemsQuestionnaire(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an existing QuestionnaireTranslation item.
     * @summary Delete an Item
     * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public deleteSingleItemsQuestionnaireTranslation(id: ReadSingleItemsAnswerOptionIdParameter, options?: AxiosRequestConfig) {
        return ItemsApiFp(this.configuration).deleteSingleItemsQuestionnaireTranslation(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an existing Section item.
     * @summary Delete an Item
     * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public deleteSingleItemsSection(id: ReadSingleItemsAnswerOptionIdParameter, options?: AxiosRequestConfig) {
        return ItemsApiFp(this.configuration).deleteSingleItemsSection(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an existing SectionTranslation item.
     * @summary Delete an Item
     * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public deleteSingleItemsSectionTranslation(id: ReadSingleItemsAnswerOptionIdParameter, options?: AxiosRequestConfig) {
        return ItemsApiFp(this.configuration).deleteSingleItemsSectionTranslation(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an existing Version item.
     * @summary Delete an Item
     * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public deleteSingleItemsVersion(id: ReadSingleItemsAnswerOptionIdParameter, options?: AxiosRequestConfig) {
        return ItemsApiFp(this.configuration).deleteSingleItemsVersion(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List the AnswerOption items.
     * @summary List Items
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {number} [limit] A limit on the number of objects that are returned.
     * @param {string} [meta] What metadata to return in the response.
     * @param {number} [offset] How many items to skip when fetching data.
     * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
     * @param {Array<string>} [filter] Select items in collection by given conditions.
     * @param {string} [search] Filter by items that contain the given search query in one of their fields.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public readItemsAnswerOption(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, options?: AxiosRequestConfig) {
        return ItemsApiFp(this.configuration).readItemsAnswerOption(fields, limit, meta, offset, sort, filter, search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List the AnswerOptionTranslation items.
     * @summary List Items
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {number} [limit] A limit on the number of objects that are returned.
     * @param {string} [meta] What metadata to return in the response.
     * @param {number} [offset] How many items to skip when fetching data.
     * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
     * @param {Array<string>} [filter] Select items in collection by given conditions.
     * @param {string} [search] Filter by items that contain the given search query in one of their fields.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public readItemsAnswerOptionTranslation(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, options?: AxiosRequestConfig) {
        return ItemsApiFp(this.configuration).readItemsAnswerOptionTranslation(fields, limit, meta, offset, sort, filter, search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List the Article items.
     * @summary List Items
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {number} [limit] A limit on the number of objects that are returned.
     * @param {string} [meta] What metadata to return in the response.
     * @param {number} [offset] How many items to skip when fetching data.
     * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
     * @param {Array<string>} [filter] Select items in collection by given conditions.
     * @param {string} [search] Filter by items that contain the given search query in one of their fields.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public readItemsArticle(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, options?: AxiosRequestConfig) {
        return ItemsApiFp(this.configuration).readItemsArticle(fields, limit, meta, offset, sort, filter, search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List the ArticleCategory items.
     * @summary List Items
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {number} [limit] A limit on the number of objects that are returned.
     * @param {string} [meta] What metadata to return in the response.
     * @param {number} [offset] How many items to skip when fetching data.
     * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
     * @param {Array<string>} [filter] Select items in collection by given conditions.
     * @param {string} [search] Filter by items that contain the given search query in one of their fields.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public readItemsArticleCategory(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, options?: AxiosRequestConfig) {
        return ItemsApiFp(this.configuration).readItemsArticleCategory(fields, limit, meta, offset, sort, filter, search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List the ArticleTranslation items.
     * @summary List Items
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {number} [limit] A limit on the number of objects that are returned.
     * @param {string} [meta] What metadata to return in the response.
     * @param {number} [offset] How many items to skip when fetching data.
     * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
     * @param {Array<string>} [filter] Select items in collection by given conditions.
     * @param {string} [search] Filter by items that contain the given search query in one of their fields.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public readItemsArticleTranslation(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, options?: AxiosRequestConfig) {
        return ItemsApiFp(this.configuration).readItemsArticleTranslation(fields, limit, meta, offset, sort, filter, search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List the Condition items.
     * @summary List Items
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {number} [limit] A limit on the number of objects that are returned.
     * @param {string} [meta] What metadata to return in the response.
     * @param {number} [offset] How many items to skip when fetching data.
     * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
     * @param {Array<string>} [filter] Select items in collection by given conditions.
     * @param {string} [search] Filter by items that contain the given search query in one of their fields.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public readItemsCondition(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, options?: AxiosRequestConfig) {
        return ItemsApiFp(this.configuration).readItemsCondition(fields, limit, meta, offset, sort, filter, search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List the ConditionFact items.
     * @summary List Items
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {number} [limit] A limit on the number of objects that are returned.
     * @param {string} [meta] What metadata to return in the response.
     * @param {number} [offset] How many items to skip when fetching data.
     * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
     * @param {Array<string>} [filter] Select items in collection by given conditions.
     * @param {string} [search] Filter by items that contain the given search query in one of their fields.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public readItemsConditionFact(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, options?: AxiosRequestConfig) {
        return ItemsApiFp(this.configuration).readItemsConditionFact(fields, limit, meta, offset, sort, filter, search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List the Fact items.
     * @summary List Items
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {number} [limit] A limit on the number of objects that are returned.
     * @param {string} [meta] What metadata to return in the response.
     * @param {number} [offset] How many items to skip when fetching data.
     * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
     * @param {Array<string>} [filter] Select items in collection by given conditions.
     * @param {string} [search] Filter by items that contain the given search query in one of their fields.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public readItemsFact(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, options?: AxiosRequestConfig) {
        return ItemsApiFp(this.configuration).readItemsFact(fields, limit, meta, offset, sort, filter, search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List the Language items.
     * @summary List Items
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {number} [limit] A limit on the number of objects that are returned.
     * @param {string} [meta] What metadata to return in the response.
     * @param {number} [offset] How many items to skip when fetching data.
     * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
     * @param {Array<string>} [filter] Select items in collection by given conditions.
     * @param {string} [search] Filter by items that contain the given search query in one of their fields.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public readItemsLanguage(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, options?: AxiosRequestConfig) {
        return ItemsApiFp(this.configuration).readItemsLanguage(fields, limit, meta, offset, sort, filter, search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List the Meaning items.
     * @summary List Items
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {number} [limit] A limit on the number of objects that are returned.
     * @param {string} [meta] What metadata to return in the response.
     * @param {number} [offset] How many items to skip when fetching data.
     * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
     * @param {Array<string>} [filter] Select items in collection by given conditions.
     * @param {string} [search] Filter by items that contain the given search query in one of their fields.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public readItemsMeaning(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, options?: AxiosRequestConfig) {
        return ItemsApiFp(this.configuration).readItemsMeaning(fields, limit, meta, offset, sort, filter, search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List the Operator items.
     * @summary List Items
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {number} [limit] A limit on the number of objects that are returned.
     * @param {string} [meta] What metadata to return in the response.
     * @param {number} [offset] How many items to skip when fetching data.
     * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
     * @param {Array<string>} [filter] Select items in collection by given conditions.
     * @param {string} [search] Filter by items that contain the given search query in one of their fields.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public readItemsOperator(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, options?: AxiosRequestConfig) {
        return ItemsApiFp(this.configuration).readItemsOperator(fields, limit, meta, offset, sort, filter, search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List the Question items.
     * @summary List Items
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {number} [limit] A limit on the number of objects that are returned.
     * @param {string} [meta] What metadata to return in the response.
     * @param {number} [offset] How many items to skip when fetching data.
     * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
     * @param {Array<string>} [filter] Select items in collection by given conditions.
     * @param {string} [search] Filter by items that contain the given search query in one of their fields.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public readItemsQuestion(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, options?: AxiosRequestConfig) {
        return ItemsApiFp(this.configuration).readItemsQuestion(fields, limit, meta, offset, sort, filter, search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List the QuestionTranslation items.
     * @summary List Items
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {number} [limit] A limit on the number of objects that are returned.
     * @param {string} [meta] What metadata to return in the response.
     * @param {number} [offset] How many items to skip when fetching data.
     * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
     * @param {Array<string>} [filter] Select items in collection by given conditions.
     * @param {string} [search] Filter by items that contain the given search query in one of their fields.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public readItemsQuestionTranslation(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, options?: AxiosRequestConfig) {
        return ItemsApiFp(this.configuration).readItemsQuestionTranslation(fields, limit, meta, offset, sort, filter, search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List the QuestionDisplay items.
     * @summary List Items
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {number} [limit] A limit on the number of objects that are returned.
     * @param {string} [meta] What metadata to return in the response.
     * @param {number} [offset] How many items to skip when fetching data.
     * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
     * @param {Array<string>} [filter] Select items in collection by given conditions.
     * @param {string} [search] Filter by items that contain the given search query in one of their fields.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public readItemsQuestiondisplay(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, options?: AxiosRequestConfig) {
        return ItemsApiFp(this.configuration).readItemsQuestiondisplay(fields, limit, meta, offset, sort, filter, search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List the Questionnaire items.
     * @summary List Items
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {number} [limit] A limit on the number of objects that are returned.
     * @param {string} [meta] What metadata to return in the response.
     * @param {number} [offset] How many items to skip when fetching data.
     * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
     * @param {Array<string>} [filter] Select items in collection by given conditions.
     * @param {string} [search] Filter by items that contain the given search query in one of their fields.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public readItemsQuestionnaire(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, options?: AxiosRequestConfig) {
        return ItemsApiFp(this.configuration).readItemsQuestionnaire(fields, limit, meta, offset, sort, filter, search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List the QuestionnaireTranslation items.
     * @summary List Items
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {number} [limit] A limit on the number of objects that are returned.
     * @param {string} [meta] What metadata to return in the response.
     * @param {number} [offset] How many items to skip when fetching data.
     * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
     * @param {Array<string>} [filter] Select items in collection by given conditions.
     * @param {string} [search] Filter by items that contain the given search query in one of their fields.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public readItemsQuestionnaireTranslation(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, options?: AxiosRequestConfig) {
        return ItemsApiFp(this.configuration).readItemsQuestionnaireTranslation(fields, limit, meta, offset, sort, filter, search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List the QuestionType items.
     * @summary List Items
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {number} [limit] A limit on the number of objects that are returned.
     * @param {string} [meta] What metadata to return in the response.
     * @param {number} [offset] How many items to skip when fetching data.
     * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
     * @param {Array<string>} [filter] Select items in collection by given conditions.
     * @param {string} [search] Filter by items that contain the given search query in one of their fields.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public readItemsQuestiontype(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, options?: AxiosRequestConfig) {
        return ItemsApiFp(this.configuration).readItemsQuestiontype(fields, limit, meta, offset, sort, filter, search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List the Section items.
     * @summary List Items
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {number} [limit] A limit on the number of objects that are returned.
     * @param {string} [meta] What metadata to return in the response.
     * @param {number} [offset] How many items to skip when fetching data.
     * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
     * @param {Array<string>} [filter] Select items in collection by given conditions.
     * @param {string} [search] Filter by items that contain the given search query in one of their fields.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public readItemsSection(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, options?: AxiosRequestConfig) {
        return ItemsApiFp(this.configuration).readItemsSection(fields, limit, meta, offset, sort, filter, search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List the SectionTranslation items.
     * @summary List Items
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {number} [limit] A limit on the number of objects that are returned.
     * @param {string} [meta] What metadata to return in the response.
     * @param {number} [offset] How many items to skip when fetching data.
     * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
     * @param {Array<string>} [filter] Select items in collection by given conditions.
     * @param {string} [search] Filter by items that contain the given search query in one of their fields.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public readItemsSectionTranslation(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, options?: AxiosRequestConfig) {
        return ItemsApiFp(this.configuration).readItemsSectionTranslation(fields, limit, meta, offset, sort, filter, search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List the Version items.
     * @summary List Items
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {number} [limit] A limit on the number of objects that are returned.
     * @param {string} [meta] What metadata to return in the response.
     * @param {number} [offset] How many items to skip when fetching data.
     * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
     * @param {Array<string>} [filter] Select items in collection by given conditions.
     * @param {string} [search] Filter by items that contain the given search query in one of their fields.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public readItemsVersion(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, options?: AxiosRequestConfig) {
        return ItemsApiFp(this.configuration).readItemsVersion(fields, limit, meta, offset, sort, filter, search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List the VersionContentType items.
     * @summary List Items
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {number} [limit] A limit on the number of objects that are returned.
     * @param {string} [meta] What metadata to return in the response.
     * @param {number} [offset] How many items to skip when fetching data.
     * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
     * @param {Array<string>} [filter] Select items in collection by given conditions.
     * @param {string} [search] Filter by items that contain the given search query in one of their fields.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public readItemsVersionContentType(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, options?: AxiosRequestConfig) {
        return ItemsApiFp(this.configuration).readItemsVersionContentType(fields, limit, meta, offset, sort, filter, search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a single AnswerOption item by unique identifier.
     * @summary Retrieve an Item
     * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public readSingleItemsAnswerOption(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, options?: AxiosRequestConfig) {
        return ItemsApiFp(this.configuration).readSingleItemsAnswerOption(id, fields, meta, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a single AnswerOptionTranslation item by unique identifier.
     * @summary Retrieve an Item
     * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public readSingleItemsAnswerOptionTranslation(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, options?: AxiosRequestConfig) {
        return ItemsApiFp(this.configuration).readSingleItemsAnswerOptionTranslation(id, fields, meta, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a single Article item by unique identifier.
     * @summary Retrieve an Item
     * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public readSingleItemsArticle(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, options?: AxiosRequestConfig) {
        return ItemsApiFp(this.configuration).readSingleItemsArticle(id, fields, meta, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a single ArticleCategory item by unique identifier.
     * @summary Retrieve an Item
     * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public readSingleItemsArticleCategory(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, options?: AxiosRequestConfig) {
        return ItemsApiFp(this.configuration).readSingleItemsArticleCategory(id, fields, meta, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a single ArticleTranslation item by unique identifier.
     * @summary Retrieve an Item
     * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public readSingleItemsArticleTranslation(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, options?: AxiosRequestConfig) {
        return ItemsApiFp(this.configuration).readSingleItemsArticleTranslation(id, fields, meta, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a single Condition item by unique identifier.
     * @summary Retrieve an Item
     * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public readSingleItemsCondition(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, options?: AxiosRequestConfig) {
        return ItemsApiFp(this.configuration).readSingleItemsCondition(id, fields, meta, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a single ConditionFact item by unique identifier.
     * @summary Retrieve an Item
     * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public readSingleItemsConditionFact(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, options?: AxiosRequestConfig) {
        return ItemsApiFp(this.configuration).readSingleItemsConditionFact(id, fields, meta, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a single Fact item by unique identifier.
     * @summary Retrieve an Item
     * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public readSingleItemsFact(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, options?: AxiosRequestConfig) {
        return ItemsApiFp(this.configuration).readSingleItemsFact(id, fields, meta, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a single Language item by unique identifier.
     * @summary Retrieve an Item
     * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public readSingleItemsLanguage(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, options?: AxiosRequestConfig) {
        return ItemsApiFp(this.configuration).readSingleItemsLanguage(id, fields, meta, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a single Meaning item by unique identifier.
     * @summary Retrieve an Item
     * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public readSingleItemsMeaning(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, options?: AxiosRequestConfig) {
        return ItemsApiFp(this.configuration).readSingleItemsMeaning(id, fields, meta, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a single Operator item by unique identifier.
     * @summary Retrieve an Item
     * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public readSingleItemsOperator(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, options?: AxiosRequestConfig) {
        return ItemsApiFp(this.configuration).readSingleItemsOperator(id, fields, meta, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a single Question item by unique identifier.
     * @summary Retrieve an Item
     * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public readSingleItemsQuestion(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, options?: AxiosRequestConfig) {
        return ItemsApiFp(this.configuration).readSingleItemsQuestion(id, fields, meta, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a single QuestionTranslation item by unique identifier.
     * @summary Retrieve an Item
     * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public readSingleItemsQuestionTranslation(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, options?: AxiosRequestConfig) {
        return ItemsApiFp(this.configuration).readSingleItemsQuestionTranslation(id, fields, meta, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a single QuestionDisplay item by unique identifier.
     * @summary Retrieve an Item
     * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public readSingleItemsQuestiondisplay(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, options?: AxiosRequestConfig) {
        return ItemsApiFp(this.configuration).readSingleItemsQuestiondisplay(id, fields, meta, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a single Questionnaire item by unique identifier.
     * @summary Retrieve an Item
     * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public readSingleItemsQuestionnaire(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, options?: AxiosRequestConfig) {
        return ItemsApiFp(this.configuration).readSingleItemsQuestionnaire(id, fields, meta, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a single QuestionnaireTranslation item by unique identifier.
     * @summary Retrieve an Item
     * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public readSingleItemsQuestionnaireTranslation(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, options?: AxiosRequestConfig) {
        return ItemsApiFp(this.configuration).readSingleItemsQuestionnaireTranslation(id, fields, meta, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a single QuestionType item by unique identifier.
     * @summary Retrieve an Item
     * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public readSingleItemsQuestiontype(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, options?: AxiosRequestConfig) {
        return ItemsApiFp(this.configuration).readSingleItemsQuestiontype(id, fields, meta, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a single Section item by unique identifier.
     * @summary Retrieve an Item
     * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public readSingleItemsSection(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, options?: AxiosRequestConfig) {
        return ItemsApiFp(this.configuration).readSingleItemsSection(id, fields, meta, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a single SectionTranslation item by unique identifier.
     * @summary Retrieve an Item
     * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public readSingleItemsSectionTranslation(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, options?: AxiosRequestConfig) {
        return ItemsApiFp(this.configuration).readSingleItemsSectionTranslation(id, fields, meta, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a single Version item by unique identifier.
     * @summary Retrieve an Item
     * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public readSingleItemsVersion(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, options?: AxiosRequestConfig) {
        return ItemsApiFp(this.configuration).readSingleItemsVersion(id, fields, meta, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a single VersionContentType item by unique identifier.
     * @summary Retrieve an Item
     * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public readSingleItemsVersionContentType(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, options?: AxiosRequestConfig) {
        return ItemsApiFp(this.configuration).readSingleItemsVersionContentType(id, fields, meta, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an existing AnswerOption item.
     * @summary Update an Item
     * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {ItemsAnswerOption} [itemsAnswerOption] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public updateSingleItemsAnswerOption(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, itemsAnswerOption?: ItemsAnswerOption, options?: AxiosRequestConfig) {
        return ItemsApiFp(this.configuration).updateSingleItemsAnswerOption(id, fields, meta, itemsAnswerOption, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an existing AnswerOptionTranslation item.
     * @summary Update an Item
     * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {ItemsAnswerOptionTranslation} [itemsAnswerOptionTranslation] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public updateSingleItemsAnswerOptionTranslation(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, itemsAnswerOptionTranslation?: ItemsAnswerOptionTranslation, options?: AxiosRequestConfig) {
        return ItemsApiFp(this.configuration).updateSingleItemsAnswerOptionTranslation(id, fields, meta, itemsAnswerOptionTranslation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an existing Article item.
     * @summary Update an Item
     * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {ItemsArticle} [itemsArticle] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public updateSingleItemsArticle(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, itemsArticle?: ItemsArticle, options?: AxiosRequestConfig) {
        return ItemsApiFp(this.configuration).updateSingleItemsArticle(id, fields, meta, itemsArticle, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an existing ArticleCategory item.
     * @summary Update an Item
     * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {ItemsArticleCategory} [itemsArticleCategory] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public updateSingleItemsArticleCategory(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, itemsArticleCategory?: ItemsArticleCategory, options?: AxiosRequestConfig) {
        return ItemsApiFp(this.configuration).updateSingleItemsArticleCategory(id, fields, meta, itemsArticleCategory, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an existing ArticleTranslation item.
     * @summary Update an Item
     * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {ItemsArticleTranslation} [itemsArticleTranslation] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public updateSingleItemsArticleTranslation(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, itemsArticleTranslation?: ItemsArticleTranslation, options?: AxiosRequestConfig) {
        return ItemsApiFp(this.configuration).updateSingleItemsArticleTranslation(id, fields, meta, itemsArticleTranslation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an existing Condition item.
     * @summary Update an Item
     * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {ItemsCondition} [itemsCondition] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public updateSingleItemsCondition(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, itemsCondition?: ItemsCondition, options?: AxiosRequestConfig) {
        return ItemsApiFp(this.configuration).updateSingleItemsCondition(id, fields, meta, itemsCondition, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an existing ConditionFact item.
     * @summary Update an Item
     * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {ItemsConditionFact} [itemsConditionFact] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public updateSingleItemsConditionFact(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, itemsConditionFact?: ItemsConditionFact, options?: AxiosRequestConfig) {
        return ItemsApiFp(this.configuration).updateSingleItemsConditionFact(id, fields, meta, itemsConditionFact, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an existing Fact item.
     * @summary Update an Item
     * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {ItemsFact} [itemsFact] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public updateSingleItemsFact(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, itemsFact?: ItemsFact, options?: AxiosRequestConfig) {
        return ItemsApiFp(this.configuration).updateSingleItemsFact(id, fields, meta, itemsFact, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an existing Question item.
     * @summary Update an Item
     * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {ItemsQuestion} [itemsQuestion] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public updateSingleItemsQuestion(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, itemsQuestion?: ItemsQuestion, options?: AxiosRequestConfig) {
        return ItemsApiFp(this.configuration).updateSingleItemsQuestion(id, fields, meta, itemsQuestion, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an existing QuestionTranslation item.
     * @summary Update an Item
     * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {ItemsQuestionTranslation} [itemsQuestionTranslation] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public updateSingleItemsQuestionTranslation(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, itemsQuestionTranslation?: ItemsQuestionTranslation, options?: AxiosRequestConfig) {
        return ItemsApiFp(this.configuration).updateSingleItemsQuestionTranslation(id, fields, meta, itemsQuestionTranslation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an existing Questionnaire item.
     * @summary Update an Item
     * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {ItemsQuestionnaire} [itemsQuestionnaire] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public updateSingleItemsQuestionnaire(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, itemsQuestionnaire?: ItemsQuestionnaire, options?: AxiosRequestConfig) {
        return ItemsApiFp(this.configuration).updateSingleItemsQuestionnaire(id, fields, meta, itemsQuestionnaire, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an existing QuestionnaireTranslation item.
     * @summary Update an Item
     * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {ItemsQuestionnaireTranslation} [itemsQuestionnaireTranslation] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public updateSingleItemsQuestionnaireTranslation(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, itemsQuestionnaireTranslation?: ItemsQuestionnaireTranslation, options?: AxiosRequestConfig) {
        return ItemsApiFp(this.configuration).updateSingleItemsQuestionnaireTranslation(id, fields, meta, itemsQuestionnaireTranslation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an existing Section item.
     * @summary Update an Item
     * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {ItemsSection} [itemsSection] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public updateSingleItemsSection(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, itemsSection?: ItemsSection, options?: AxiosRequestConfig) {
        return ItemsApiFp(this.configuration).updateSingleItemsSection(id, fields, meta, itemsSection, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an existing SectionTranslation item.
     * @summary Update an Item
     * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {ItemsSectionTranslation} [itemsSectionTranslation] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public updateSingleItemsSectionTranslation(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, itemsSectionTranslation?: ItemsSectionTranslation, options?: AxiosRequestConfig) {
        return ItemsApiFp(this.configuration).updateSingleItemsSectionTranslation(id, fields, meta, itemsSectionTranslation, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ItemsAnswerOptionApi - axios parameter creator
 * @export
 */
export const ItemsAnswerOptionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new AnswerOption item.
         * @summary Create an Item
         * @param {string} [meta] What metadata to return in the response.
         * @param {CreateItemsAnswerOptionRequest} [createItemsAnswerOptionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createItemsAnswerOption: async (meta?: string, createItemsAnswerOptionRequest?: CreateItemsAnswerOptionRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/items/AnswerOption`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createItemsAnswerOptionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an existing AnswerOption item.
         * @summary Delete an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSingleItemsAnswerOption: async (id: ReadSingleItemsAnswerOptionIdParameter, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteSingleItemsAnswerOption', 'id', id)
            const localVarPath = `/items/AnswerOption/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List the AnswerOption items.
         * @summary List Items
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {Array<string>} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readItemsAnswerOption: async (fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/items/AnswerOption`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sort) {
                localVarQueryParameter['sort'] = sort.join(COLLECTION_FORMATS.csv);
            }

            if (filter) {
                localVarQueryParameter['filter'] = filter;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a single AnswerOption item by unique identifier.
         * @summary Retrieve an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readSingleItemsAnswerOption: async (id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('readSingleItemsAnswerOption', 'id', id)
            const localVarPath = `/items/AnswerOption/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an existing AnswerOption item.
         * @summary Update an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {ItemsAnswerOption} [itemsAnswerOption] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSingleItemsAnswerOption: async (id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, itemsAnswerOption?: ItemsAnswerOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateSingleItemsAnswerOption', 'id', id)
            const localVarPath = `/items/AnswerOption/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(itemsAnswerOption, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ItemsAnswerOptionApi - functional programming interface
 * @export
 */
export const ItemsAnswerOptionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ItemsAnswerOptionApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new AnswerOption item.
         * @summary Create an Item
         * @param {string} [meta] What metadata to return in the response.
         * @param {CreateItemsAnswerOptionRequest} [createItemsAnswerOptionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createItemsAnswerOption(meta?: string, createItemsAnswerOptionRequest?: CreateItemsAnswerOptionRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateItemsAnswerOption200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createItemsAnswerOption(meta, createItemsAnswerOptionRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete an existing AnswerOption item.
         * @summary Delete an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSingleItemsAnswerOption(id: ReadSingleItemsAnswerOptionIdParameter, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSingleItemsAnswerOption(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List the AnswerOption items.
         * @summary List Items
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {Array<string>} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readItemsAnswerOption(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReadItemsAnswerOption200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readItemsAnswerOption(fields, limit, meta, offset, sort, filter, search, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve a single AnswerOption item by unique identifier.
         * @summary Retrieve an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readSingleItemsAnswerOption(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReadSingleItemsAnswerOption200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readSingleItemsAnswerOption(id, fields, meta, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update an existing AnswerOption item.
         * @summary Update an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {ItemsAnswerOption} [itemsAnswerOption] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSingleItemsAnswerOption(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, itemsAnswerOption?: ItemsAnswerOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReadSingleItemsAnswerOption200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSingleItemsAnswerOption(id, fields, meta, itemsAnswerOption, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ItemsAnswerOptionApi - factory interface
 * @export
 */
export const ItemsAnswerOptionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ItemsAnswerOptionApiFp(configuration)
    return {
        /**
         * Create a new AnswerOption item.
         * @summary Create an Item
         * @param {string} [meta] What metadata to return in the response.
         * @param {CreateItemsAnswerOptionRequest} [createItemsAnswerOptionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createItemsAnswerOption(meta?: string, createItemsAnswerOptionRequest?: CreateItemsAnswerOptionRequest, options?: any): AxiosPromise<CreateItemsAnswerOption200Response> {
            return localVarFp.createItemsAnswerOption(meta, createItemsAnswerOptionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an existing AnswerOption item.
         * @summary Delete an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSingleItemsAnswerOption(id: ReadSingleItemsAnswerOptionIdParameter, options?: any): AxiosPromise<void> {
            return localVarFp.deleteSingleItemsAnswerOption(id, options).then((request) => request(axios, basePath));
        },
        /**
         * List the AnswerOption items.
         * @summary List Items
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {Array<string>} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readItemsAnswerOption(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, options?: any): AxiosPromise<ReadItemsAnswerOption200Response> {
            return localVarFp.readItemsAnswerOption(fields, limit, meta, offset, sort, filter, search, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a single AnswerOption item by unique identifier.
         * @summary Retrieve an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readSingleItemsAnswerOption(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, options?: any): AxiosPromise<ReadSingleItemsAnswerOption200Response> {
            return localVarFp.readSingleItemsAnswerOption(id, fields, meta, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an existing AnswerOption item.
         * @summary Update an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {ItemsAnswerOption} [itemsAnswerOption] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSingleItemsAnswerOption(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, itemsAnswerOption?: ItemsAnswerOption, options?: any): AxiosPromise<ReadSingleItemsAnswerOption200Response> {
            return localVarFp.updateSingleItemsAnswerOption(id, fields, meta, itemsAnswerOption, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ItemsAnswerOptionApi - object-oriented interface
 * @export
 * @class ItemsAnswerOptionApi
 * @extends {BaseAPI}
 */
export class ItemsAnswerOptionApi extends BaseAPI {
    /**
     * Create a new AnswerOption item.
     * @summary Create an Item
     * @param {string} [meta] What metadata to return in the response.
     * @param {CreateItemsAnswerOptionRequest} [createItemsAnswerOptionRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsAnswerOptionApi
     */
    public createItemsAnswerOption(meta?: string, createItemsAnswerOptionRequest?: CreateItemsAnswerOptionRequest, options?: AxiosRequestConfig) {
        return ItemsAnswerOptionApiFp(this.configuration).createItemsAnswerOption(meta, createItemsAnswerOptionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an existing AnswerOption item.
     * @summary Delete an Item
     * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsAnswerOptionApi
     */
    public deleteSingleItemsAnswerOption(id: ReadSingleItemsAnswerOptionIdParameter, options?: AxiosRequestConfig) {
        return ItemsAnswerOptionApiFp(this.configuration).deleteSingleItemsAnswerOption(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List the AnswerOption items.
     * @summary List Items
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {number} [limit] A limit on the number of objects that are returned.
     * @param {string} [meta] What metadata to return in the response.
     * @param {number} [offset] How many items to skip when fetching data.
     * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
     * @param {Array<string>} [filter] Select items in collection by given conditions.
     * @param {string} [search] Filter by items that contain the given search query in one of their fields.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsAnswerOptionApi
     */
    public readItemsAnswerOption(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, options?: AxiosRequestConfig) {
        return ItemsAnswerOptionApiFp(this.configuration).readItemsAnswerOption(fields, limit, meta, offset, sort, filter, search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a single AnswerOption item by unique identifier.
     * @summary Retrieve an Item
     * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsAnswerOptionApi
     */
    public readSingleItemsAnswerOption(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, options?: AxiosRequestConfig) {
        return ItemsAnswerOptionApiFp(this.configuration).readSingleItemsAnswerOption(id, fields, meta, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an existing AnswerOption item.
     * @summary Update an Item
     * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {ItemsAnswerOption} [itemsAnswerOption] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsAnswerOptionApi
     */
    public updateSingleItemsAnswerOption(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, itemsAnswerOption?: ItemsAnswerOption, options?: AxiosRequestConfig) {
        return ItemsAnswerOptionApiFp(this.configuration).updateSingleItemsAnswerOption(id, fields, meta, itemsAnswerOption, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ItemsAnswerOptionTranslationApi - axios parameter creator
 * @export
 */
export const ItemsAnswerOptionTranslationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new AnswerOptionTranslation item.
         * @summary Create an Item
         * @param {string} [meta] What metadata to return in the response.
         * @param {CreateItemsAnswerOptionTranslationRequest} [createItemsAnswerOptionTranslationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createItemsAnswerOptionTranslation: async (meta?: string, createItemsAnswerOptionTranslationRequest?: CreateItemsAnswerOptionTranslationRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/items/AnswerOptionTranslation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createItemsAnswerOptionTranslationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an existing AnswerOptionTranslation item.
         * @summary Delete an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSingleItemsAnswerOptionTranslation: async (id: ReadSingleItemsAnswerOptionIdParameter, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteSingleItemsAnswerOptionTranslation', 'id', id)
            const localVarPath = `/items/AnswerOptionTranslation/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List the AnswerOptionTranslation items.
         * @summary List Items
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {Array<string>} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readItemsAnswerOptionTranslation: async (fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/items/AnswerOptionTranslation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sort) {
                localVarQueryParameter['sort'] = sort.join(COLLECTION_FORMATS.csv);
            }

            if (filter) {
                localVarQueryParameter['filter'] = filter;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a single AnswerOptionTranslation item by unique identifier.
         * @summary Retrieve an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readSingleItemsAnswerOptionTranslation: async (id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('readSingleItemsAnswerOptionTranslation', 'id', id)
            const localVarPath = `/items/AnswerOptionTranslation/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an existing AnswerOptionTranslation item.
         * @summary Update an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {ItemsAnswerOptionTranslation} [itemsAnswerOptionTranslation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSingleItemsAnswerOptionTranslation: async (id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, itemsAnswerOptionTranslation?: ItemsAnswerOptionTranslation, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateSingleItemsAnswerOptionTranslation', 'id', id)
            const localVarPath = `/items/AnswerOptionTranslation/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(itemsAnswerOptionTranslation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ItemsAnswerOptionTranslationApi - functional programming interface
 * @export
 */
export const ItemsAnswerOptionTranslationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ItemsAnswerOptionTranslationApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new AnswerOptionTranslation item.
         * @summary Create an Item
         * @param {string} [meta] What metadata to return in the response.
         * @param {CreateItemsAnswerOptionTranslationRequest} [createItemsAnswerOptionTranslationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createItemsAnswerOptionTranslation(meta?: string, createItemsAnswerOptionTranslationRequest?: CreateItemsAnswerOptionTranslationRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateItemsAnswerOptionTranslation200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createItemsAnswerOptionTranslation(meta, createItemsAnswerOptionTranslationRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete an existing AnswerOptionTranslation item.
         * @summary Delete an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSingleItemsAnswerOptionTranslation(id: ReadSingleItemsAnswerOptionIdParameter, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSingleItemsAnswerOptionTranslation(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List the AnswerOptionTranslation items.
         * @summary List Items
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {Array<string>} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readItemsAnswerOptionTranslation(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReadItemsAnswerOptionTranslation200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readItemsAnswerOptionTranslation(fields, limit, meta, offset, sort, filter, search, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve a single AnswerOptionTranslation item by unique identifier.
         * @summary Retrieve an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readSingleItemsAnswerOptionTranslation(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReadSingleItemsAnswerOptionTranslation200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readSingleItemsAnswerOptionTranslation(id, fields, meta, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update an existing AnswerOptionTranslation item.
         * @summary Update an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {ItemsAnswerOptionTranslation} [itemsAnswerOptionTranslation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSingleItemsAnswerOptionTranslation(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, itemsAnswerOptionTranslation?: ItemsAnswerOptionTranslation, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReadSingleItemsAnswerOptionTranslation200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSingleItemsAnswerOptionTranslation(id, fields, meta, itemsAnswerOptionTranslation, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ItemsAnswerOptionTranslationApi - factory interface
 * @export
 */
export const ItemsAnswerOptionTranslationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ItemsAnswerOptionTranslationApiFp(configuration)
    return {
        /**
         * Create a new AnswerOptionTranslation item.
         * @summary Create an Item
         * @param {string} [meta] What metadata to return in the response.
         * @param {CreateItemsAnswerOptionTranslationRequest} [createItemsAnswerOptionTranslationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createItemsAnswerOptionTranslation(meta?: string, createItemsAnswerOptionTranslationRequest?: CreateItemsAnswerOptionTranslationRequest, options?: any): AxiosPromise<CreateItemsAnswerOptionTranslation200Response> {
            return localVarFp.createItemsAnswerOptionTranslation(meta, createItemsAnswerOptionTranslationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an existing AnswerOptionTranslation item.
         * @summary Delete an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSingleItemsAnswerOptionTranslation(id: ReadSingleItemsAnswerOptionIdParameter, options?: any): AxiosPromise<void> {
            return localVarFp.deleteSingleItemsAnswerOptionTranslation(id, options).then((request) => request(axios, basePath));
        },
        /**
         * List the AnswerOptionTranslation items.
         * @summary List Items
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {Array<string>} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readItemsAnswerOptionTranslation(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, options?: any): AxiosPromise<ReadItemsAnswerOptionTranslation200Response> {
            return localVarFp.readItemsAnswerOptionTranslation(fields, limit, meta, offset, sort, filter, search, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a single AnswerOptionTranslation item by unique identifier.
         * @summary Retrieve an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readSingleItemsAnswerOptionTranslation(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, options?: any): AxiosPromise<ReadSingleItemsAnswerOptionTranslation200Response> {
            return localVarFp.readSingleItemsAnswerOptionTranslation(id, fields, meta, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an existing AnswerOptionTranslation item.
         * @summary Update an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {ItemsAnswerOptionTranslation} [itemsAnswerOptionTranslation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSingleItemsAnswerOptionTranslation(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, itemsAnswerOptionTranslation?: ItemsAnswerOptionTranslation, options?: any): AxiosPromise<ReadSingleItemsAnswerOptionTranslation200Response> {
            return localVarFp.updateSingleItemsAnswerOptionTranslation(id, fields, meta, itemsAnswerOptionTranslation, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ItemsAnswerOptionTranslationApi - object-oriented interface
 * @export
 * @class ItemsAnswerOptionTranslationApi
 * @extends {BaseAPI}
 */
export class ItemsAnswerOptionTranslationApi extends BaseAPI {
    /**
     * Create a new AnswerOptionTranslation item.
     * @summary Create an Item
     * @param {string} [meta] What metadata to return in the response.
     * @param {CreateItemsAnswerOptionTranslationRequest} [createItemsAnswerOptionTranslationRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsAnswerOptionTranslationApi
     */
    public createItemsAnswerOptionTranslation(meta?: string, createItemsAnswerOptionTranslationRequest?: CreateItemsAnswerOptionTranslationRequest, options?: AxiosRequestConfig) {
        return ItemsAnswerOptionTranslationApiFp(this.configuration).createItemsAnswerOptionTranslation(meta, createItemsAnswerOptionTranslationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an existing AnswerOptionTranslation item.
     * @summary Delete an Item
     * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsAnswerOptionTranslationApi
     */
    public deleteSingleItemsAnswerOptionTranslation(id: ReadSingleItemsAnswerOptionIdParameter, options?: AxiosRequestConfig) {
        return ItemsAnswerOptionTranslationApiFp(this.configuration).deleteSingleItemsAnswerOptionTranslation(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List the AnswerOptionTranslation items.
     * @summary List Items
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {number} [limit] A limit on the number of objects that are returned.
     * @param {string} [meta] What metadata to return in the response.
     * @param {number} [offset] How many items to skip when fetching data.
     * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
     * @param {Array<string>} [filter] Select items in collection by given conditions.
     * @param {string} [search] Filter by items that contain the given search query in one of their fields.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsAnswerOptionTranslationApi
     */
    public readItemsAnswerOptionTranslation(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, options?: AxiosRequestConfig) {
        return ItemsAnswerOptionTranslationApiFp(this.configuration).readItemsAnswerOptionTranslation(fields, limit, meta, offset, sort, filter, search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a single AnswerOptionTranslation item by unique identifier.
     * @summary Retrieve an Item
     * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsAnswerOptionTranslationApi
     */
    public readSingleItemsAnswerOptionTranslation(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, options?: AxiosRequestConfig) {
        return ItemsAnswerOptionTranslationApiFp(this.configuration).readSingleItemsAnswerOptionTranslation(id, fields, meta, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an existing AnswerOptionTranslation item.
     * @summary Update an Item
     * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {ItemsAnswerOptionTranslation} [itemsAnswerOptionTranslation] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsAnswerOptionTranslationApi
     */
    public updateSingleItemsAnswerOptionTranslation(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, itemsAnswerOptionTranslation?: ItemsAnswerOptionTranslation, options?: AxiosRequestConfig) {
        return ItemsAnswerOptionTranslationApiFp(this.configuration).updateSingleItemsAnswerOptionTranslation(id, fields, meta, itemsAnswerOptionTranslation, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ItemsArticleApi - axios parameter creator
 * @export
 */
export const ItemsArticleApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new Article item.
         * @summary Create an Item
         * @param {string} [meta] What metadata to return in the response.
         * @param {CreateItemsArticleRequest} [createItemsArticleRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createItemsArticle: async (meta?: string, createItemsArticleRequest?: CreateItemsArticleRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/items/Article`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createItemsArticleRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an existing Article item.
         * @summary Delete an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSingleItemsArticle: async (id: ReadSingleItemsAnswerOptionIdParameter, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteSingleItemsArticle', 'id', id)
            const localVarPath = `/items/Article/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List the Article items.
         * @summary List Items
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {Array<string>} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readItemsArticle: async (fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/items/Article`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sort) {
                localVarQueryParameter['sort'] = sort.join(COLLECTION_FORMATS.csv);
            }

            if (filter) {
                localVarQueryParameter['filter'] = filter;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a single Article item by unique identifier.
         * @summary Retrieve an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readSingleItemsArticle: async (id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('readSingleItemsArticle', 'id', id)
            const localVarPath = `/items/Article/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an existing Article item.
         * @summary Update an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {ItemsArticle} [itemsArticle] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSingleItemsArticle: async (id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, itemsArticle?: ItemsArticle, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateSingleItemsArticle', 'id', id)
            const localVarPath = `/items/Article/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(itemsArticle, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ItemsArticleApi - functional programming interface
 * @export
 */
export const ItemsArticleApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ItemsArticleApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new Article item.
         * @summary Create an Item
         * @param {string} [meta] What metadata to return in the response.
         * @param {CreateItemsArticleRequest} [createItemsArticleRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createItemsArticle(meta?: string, createItemsArticleRequest?: CreateItemsArticleRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateItemsArticle200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createItemsArticle(meta, createItemsArticleRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete an existing Article item.
         * @summary Delete an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSingleItemsArticle(id: ReadSingleItemsAnswerOptionIdParameter, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSingleItemsArticle(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List the Article items.
         * @summary List Items
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {Array<string>} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readItemsArticle(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReadItemsArticle200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readItemsArticle(fields, limit, meta, offset, sort, filter, search, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve a single Article item by unique identifier.
         * @summary Retrieve an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readSingleItemsArticle(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReadSingleItemsArticle200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readSingleItemsArticle(id, fields, meta, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update an existing Article item.
         * @summary Update an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {ItemsArticle} [itemsArticle] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSingleItemsArticle(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, itemsArticle?: ItemsArticle, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReadSingleItemsArticle200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSingleItemsArticle(id, fields, meta, itemsArticle, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ItemsArticleApi - factory interface
 * @export
 */
export const ItemsArticleApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ItemsArticleApiFp(configuration)
    return {
        /**
         * Create a new Article item.
         * @summary Create an Item
         * @param {string} [meta] What metadata to return in the response.
         * @param {CreateItemsArticleRequest} [createItemsArticleRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createItemsArticle(meta?: string, createItemsArticleRequest?: CreateItemsArticleRequest, options?: any): AxiosPromise<CreateItemsArticle200Response> {
            return localVarFp.createItemsArticle(meta, createItemsArticleRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an existing Article item.
         * @summary Delete an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSingleItemsArticle(id: ReadSingleItemsAnswerOptionIdParameter, options?: any): AxiosPromise<void> {
            return localVarFp.deleteSingleItemsArticle(id, options).then((request) => request(axios, basePath));
        },
        /**
         * List the Article items.
         * @summary List Items
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {Array<string>} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readItemsArticle(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, options?: any): AxiosPromise<ReadItemsArticle200Response> {
            return localVarFp.readItemsArticle(fields, limit, meta, offset, sort, filter, search, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a single Article item by unique identifier.
         * @summary Retrieve an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readSingleItemsArticle(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, options?: any): AxiosPromise<ReadSingleItemsArticle200Response> {
            return localVarFp.readSingleItemsArticle(id, fields, meta, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an existing Article item.
         * @summary Update an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {ItemsArticle} [itemsArticle] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSingleItemsArticle(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, itemsArticle?: ItemsArticle, options?: any): AxiosPromise<ReadSingleItemsArticle200Response> {
            return localVarFp.updateSingleItemsArticle(id, fields, meta, itemsArticle, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ItemsArticleApi - object-oriented interface
 * @export
 * @class ItemsArticleApi
 * @extends {BaseAPI}
 */
export class ItemsArticleApi extends BaseAPI {
    /**
     * Create a new Article item.
     * @summary Create an Item
     * @param {string} [meta] What metadata to return in the response.
     * @param {CreateItemsArticleRequest} [createItemsArticleRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsArticleApi
     */
    public createItemsArticle(meta?: string, createItemsArticleRequest?: CreateItemsArticleRequest, options?: AxiosRequestConfig) {
        return ItemsArticleApiFp(this.configuration).createItemsArticle(meta, createItemsArticleRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an existing Article item.
     * @summary Delete an Item
     * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsArticleApi
     */
    public deleteSingleItemsArticle(id: ReadSingleItemsAnswerOptionIdParameter, options?: AxiosRequestConfig) {
        return ItemsArticleApiFp(this.configuration).deleteSingleItemsArticle(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List the Article items.
     * @summary List Items
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {number} [limit] A limit on the number of objects that are returned.
     * @param {string} [meta] What metadata to return in the response.
     * @param {number} [offset] How many items to skip when fetching data.
     * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
     * @param {Array<string>} [filter] Select items in collection by given conditions.
     * @param {string} [search] Filter by items that contain the given search query in one of their fields.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsArticleApi
     */
    public readItemsArticle(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, options?: AxiosRequestConfig) {
        return ItemsArticleApiFp(this.configuration).readItemsArticle(fields, limit, meta, offset, sort, filter, search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a single Article item by unique identifier.
     * @summary Retrieve an Item
     * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsArticleApi
     */
    public readSingleItemsArticle(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, options?: AxiosRequestConfig) {
        return ItemsArticleApiFp(this.configuration).readSingleItemsArticle(id, fields, meta, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an existing Article item.
     * @summary Update an Item
     * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {ItemsArticle} [itemsArticle] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsArticleApi
     */
    public updateSingleItemsArticle(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, itemsArticle?: ItemsArticle, options?: AxiosRequestConfig) {
        return ItemsArticleApiFp(this.configuration).updateSingleItemsArticle(id, fields, meta, itemsArticle, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ItemsArticleCategoryApi - axios parameter creator
 * @export
 */
export const ItemsArticleCategoryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new ArticleCategory item.
         * @summary Create an Item
         * @param {string} [meta] What metadata to return in the response.
         * @param {CreateItemsArticleCategoryRequest} [createItemsArticleCategoryRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createItemsArticleCategory: async (meta?: string, createItemsArticleCategoryRequest?: CreateItemsArticleCategoryRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/items/ArticleCategory`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createItemsArticleCategoryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an existing ArticleCategory item.
         * @summary Delete an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSingleItemsArticleCategory: async (id: ReadSingleItemsAnswerOptionIdParameter, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteSingleItemsArticleCategory', 'id', id)
            const localVarPath = `/items/ArticleCategory/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List the ArticleCategory items.
         * @summary List Items
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {Array<string>} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readItemsArticleCategory: async (fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/items/ArticleCategory`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sort) {
                localVarQueryParameter['sort'] = sort.join(COLLECTION_FORMATS.csv);
            }

            if (filter) {
                localVarQueryParameter['filter'] = filter;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a single ArticleCategory item by unique identifier.
         * @summary Retrieve an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readSingleItemsArticleCategory: async (id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('readSingleItemsArticleCategory', 'id', id)
            const localVarPath = `/items/ArticleCategory/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an existing ArticleCategory item.
         * @summary Update an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {ItemsArticleCategory} [itemsArticleCategory] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSingleItemsArticleCategory: async (id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, itemsArticleCategory?: ItemsArticleCategory, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateSingleItemsArticleCategory', 'id', id)
            const localVarPath = `/items/ArticleCategory/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(itemsArticleCategory, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ItemsArticleCategoryApi - functional programming interface
 * @export
 */
export const ItemsArticleCategoryApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ItemsArticleCategoryApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new ArticleCategory item.
         * @summary Create an Item
         * @param {string} [meta] What metadata to return in the response.
         * @param {CreateItemsArticleCategoryRequest} [createItemsArticleCategoryRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createItemsArticleCategory(meta?: string, createItemsArticleCategoryRequest?: CreateItemsArticleCategoryRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateItemsArticleCategory200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createItemsArticleCategory(meta, createItemsArticleCategoryRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete an existing ArticleCategory item.
         * @summary Delete an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSingleItemsArticleCategory(id: ReadSingleItemsAnswerOptionIdParameter, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSingleItemsArticleCategory(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List the ArticleCategory items.
         * @summary List Items
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {Array<string>} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readItemsArticleCategory(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReadItemsArticleCategory200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readItemsArticleCategory(fields, limit, meta, offset, sort, filter, search, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve a single ArticleCategory item by unique identifier.
         * @summary Retrieve an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readSingleItemsArticleCategory(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReadSingleItemsArticleCategory200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readSingleItemsArticleCategory(id, fields, meta, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update an existing ArticleCategory item.
         * @summary Update an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {ItemsArticleCategory} [itemsArticleCategory] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSingleItemsArticleCategory(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, itemsArticleCategory?: ItemsArticleCategory, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReadSingleItemsArticleCategory200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSingleItemsArticleCategory(id, fields, meta, itemsArticleCategory, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ItemsArticleCategoryApi - factory interface
 * @export
 */
export const ItemsArticleCategoryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ItemsArticleCategoryApiFp(configuration)
    return {
        /**
         * Create a new ArticleCategory item.
         * @summary Create an Item
         * @param {string} [meta] What metadata to return in the response.
         * @param {CreateItemsArticleCategoryRequest} [createItemsArticleCategoryRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createItemsArticleCategory(meta?: string, createItemsArticleCategoryRequest?: CreateItemsArticleCategoryRequest, options?: any): AxiosPromise<CreateItemsArticleCategory200Response> {
            return localVarFp.createItemsArticleCategory(meta, createItemsArticleCategoryRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an existing ArticleCategory item.
         * @summary Delete an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSingleItemsArticleCategory(id: ReadSingleItemsAnswerOptionIdParameter, options?: any): AxiosPromise<void> {
            return localVarFp.deleteSingleItemsArticleCategory(id, options).then((request) => request(axios, basePath));
        },
        /**
         * List the ArticleCategory items.
         * @summary List Items
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {Array<string>} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readItemsArticleCategory(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, options?: any): AxiosPromise<ReadItemsArticleCategory200Response> {
            return localVarFp.readItemsArticleCategory(fields, limit, meta, offset, sort, filter, search, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a single ArticleCategory item by unique identifier.
         * @summary Retrieve an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readSingleItemsArticleCategory(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, options?: any): AxiosPromise<ReadSingleItemsArticleCategory200Response> {
            return localVarFp.readSingleItemsArticleCategory(id, fields, meta, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an existing ArticleCategory item.
         * @summary Update an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {ItemsArticleCategory} [itemsArticleCategory] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSingleItemsArticleCategory(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, itemsArticleCategory?: ItemsArticleCategory, options?: any): AxiosPromise<ReadSingleItemsArticleCategory200Response> {
            return localVarFp.updateSingleItemsArticleCategory(id, fields, meta, itemsArticleCategory, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ItemsArticleCategoryApi - object-oriented interface
 * @export
 * @class ItemsArticleCategoryApi
 * @extends {BaseAPI}
 */
export class ItemsArticleCategoryApi extends BaseAPI {
    /**
     * Create a new ArticleCategory item.
     * @summary Create an Item
     * @param {string} [meta] What metadata to return in the response.
     * @param {CreateItemsArticleCategoryRequest} [createItemsArticleCategoryRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsArticleCategoryApi
     */
    public createItemsArticleCategory(meta?: string, createItemsArticleCategoryRequest?: CreateItemsArticleCategoryRequest, options?: AxiosRequestConfig) {
        return ItemsArticleCategoryApiFp(this.configuration).createItemsArticleCategory(meta, createItemsArticleCategoryRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an existing ArticleCategory item.
     * @summary Delete an Item
     * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsArticleCategoryApi
     */
    public deleteSingleItemsArticleCategory(id: ReadSingleItemsAnswerOptionIdParameter, options?: AxiosRequestConfig) {
        return ItemsArticleCategoryApiFp(this.configuration).deleteSingleItemsArticleCategory(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List the ArticleCategory items.
     * @summary List Items
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {number} [limit] A limit on the number of objects that are returned.
     * @param {string} [meta] What metadata to return in the response.
     * @param {number} [offset] How many items to skip when fetching data.
     * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
     * @param {Array<string>} [filter] Select items in collection by given conditions.
     * @param {string} [search] Filter by items that contain the given search query in one of their fields.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsArticleCategoryApi
     */
    public readItemsArticleCategory(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, options?: AxiosRequestConfig) {
        return ItemsArticleCategoryApiFp(this.configuration).readItemsArticleCategory(fields, limit, meta, offset, sort, filter, search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a single ArticleCategory item by unique identifier.
     * @summary Retrieve an Item
     * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsArticleCategoryApi
     */
    public readSingleItemsArticleCategory(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, options?: AxiosRequestConfig) {
        return ItemsArticleCategoryApiFp(this.configuration).readSingleItemsArticleCategory(id, fields, meta, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an existing ArticleCategory item.
     * @summary Update an Item
     * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {ItemsArticleCategory} [itemsArticleCategory] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsArticleCategoryApi
     */
    public updateSingleItemsArticleCategory(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, itemsArticleCategory?: ItemsArticleCategory, options?: AxiosRequestConfig) {
        return ItemsArticleCategoryApiFp(this.configuration).updateSingleItemsArticleCategory(id, fields, meta, itemsArticleCategory, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ItemsArticleTranslationApi - axios parameter creator
 * @export
 */
export const ItemsArticleTranslationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new ArticleTranslation item.
         * @summary Create an Item
         * @param {string} [meta] What metadata to return in the response.
         * @param {CreateItemsArticleTranslationRequest} [createItemsArticleTranslationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createItemsArticleTranslation: async (meta?: string, createItemsArticleTranslationRequest?: CreateItemsArticleTranslationRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/items/ArticleTranslation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createItemsArticleTranslationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an existing ArticleTranslation item.
         * @summary Delete an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSingleItemsArticleTranslation: async (id: ReadSingleItemsAnswerOptionIdParameter, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteSingleItemsArticleTranslation', 'id', id)
            const localVarPath = `/items/ArticleTranslation/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List the ArticleTranslation items.
         * @summary List Items
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {Array<string>} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readItemsArticleTranslation: async (fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/items/ArticleTranslation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sort) {
                localVarQueryParameter['sort'] = sort.join(COLLECTION_FORMATS.csv);
            }

            if (filter) {
                localVarQueryParameter['filter'] = filter;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a single ArticleTranslation item by unique identifier.
         * @summary Retrieve an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readSingleItemsArticleTranslation: async (id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('readSingleItemsArticleTranslation', 'id', id)
            const localVarPath = `/items/ArticleTranslation/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an existing ArticleTranslation item.
         * @summary Update an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {ItemsArticleTranslation} [itemsArticleTranslation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSingleItemsArticleTranslation: async (id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, itemsArticleTranslation?: ItemsArticleTranslation, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateSingleItemsArticleTranslation', 'id', id)
            const localVarPath = `/items/ArticleTranslation/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(itemsArticleTranslation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ItemsArticleTranslationApi - functional programming interface
 * @export
 */
export const ItemsArticleTranslationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ItemsArticleTranslationApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new ArticleTranslation item.
         * @summary Create an Item
         * @param {string} [meta] What metadata to return in the response.
         * @param {CreateItemsArticleTranslationRequest} [createItemsArticleTranslationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createItemsArticleTranslation(meta?: string, createItemsArticleTranslationRequest?: CreateItemsArticleTranslationRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateItemsArticleTranslation200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createItemsArticleTranslation(meta, createItemsArticleTranslationRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete an existing ArticleTranslation item.
         * @summary Delete an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSingleItemsArticleTranslation(id: ReadSingleItemsAnswerOptionIdParameter, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSingleItemsArticleTranslation(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List the ArticleTranslation items.
         * @summary List Items
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {Array<string>} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readItemsArticleTranslation(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReadItemsArticleTranslation200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readItemsArticleTranslation(fields, limit, meta, offset, sort, filter, search, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve a single ArticleTranslation item by unique identifier.
         * @summary Retrieve an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readSingleItemsArticleTranslation(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReadSingleItemsArticleTranslation200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readSingleItemsArticleTranslation(id, fields, meta, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update an existing ArticleTranslation item.
         * @summary Update an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {ItemsArticleTranslation} [itemsArticleTranslation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSingleItemsArticleTranslation(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, itemsArticleTranslation?: ItemsArticleTranslation, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReadSingleItemsArticleTranslation200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSingleItemsArticleTranslation(id, fields, meta, itemsArticleTranslation, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ItemsArticleTranslationApi - factory interface
 * @export
 */
export const ItemsArticleTranslationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ItemsArticleTranslationApiFp(configuration)
    return {
        /**
         * Create a new ArticleTranslation item.
         * @summary Create an Item
         * @param {string} [meta] What metadata to return in the response.
         * @param {CreateItemsArticleTranslationRequest} [createItemsArticleTranslationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createItemsArticleTranslation(meta?: string, createItemsArticleTranslationRequest?: CreateItemsArticleTranslationRequest, options?: any): AxiosPromise<CreateItemsArticleTranslation200Response> {
            return localVarFp.createItemsArticleTranslation(meta, createItemsArticleTranslationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an existing ArticleTranslation item.
         * @summary Delete an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSingleItemsArticleTranslation(id: ReadSingleItemsAnswerOptionIdParameter, options?: any): AxiosPromise<void> {
            return localVarFp.deleteSingleItemsArticleTranslation(id, options).then((request) => request(axios, basePath));
        },
        /**
         * List the ArticleTranslation items.
         * @summary List Items
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {Array<string>} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readItemsArticleTranslation(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, options?: any): AxiosPromise<ReadItemsArticleTranslation200Response> {
            return localVarFp.readItemsArticleTranslation(fields, limit, meta, offset, sort, filter, search, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a single ArticleTranslation item by unique identifier.
         * @summary Retrieve an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readSingleItemsArticleTranslation(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, options?: any): AxiosPromise<ReadSingleItemsArticleTranslation200Response> {
            return localVarFp.readSingleItemsArticleTranslation(id, fields, meta, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an existing ArticleTranslation item.
         * @summary Update an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {ItemsArticleTranslation} [itemsArticleTranslation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSingleItemsArticleTranslation(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, itemsArticleTranslation?: ItemsArticleTranslation, options?: any): AxiosPromise<ReadSingleItemsArticleTranslation200Response> {
            return localVarFp.updateSingleItemsArticleTranslation(id, fields, meta, itemsArticleTranslation, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ItemsArticleTranslationApi - object-oriented interface
 * @export
 * @class ItemsArticleTranslationApi
 * @extends {BaseAPI}
 */
export class ItemsArticleTranslationApi extends BaseAPI {
    /**
     * Create a new ArticleTranslation item.
     * @summary Create an Item
     * @param {string} [meta] What metadata to return in the response.
     * @param {CreateItemsArticleTranslationRequest} [createItemsArticleTranslationRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsArticleTranslationApi
     */
    public createItemsArticleTranslation(meta?: string, createItemsArticleTranslationRequest?: CreateItemsArticleTranslationRequest, options?: AxiosRequestConfig) {
        return ItemsArticleTranslationApiFp(this.configuration).createItemsArticleTranslation(meta, createItemsArticleTranslationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an existing ArticleTranslation item.
     * @summary Delete an Item
     * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsArticleTranslationApi
     */
    public deleteSingleItemsArticleTranslation(id: ReadSingleItemsAnswerOptionIdParameter, options?: AxiosRequestConfig) {
        return ItemsArticleTranslationApiFp(this.configuration).deleteSingleItemsArticleTranslation(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List the ArticleTranslation items.
     * @summary List Items
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {number} [limit] A limit on the number of objects that are returned.
     * @param {string} [meta] What metadata to return in the response.
     * @param {number} [offset] How many items to skip when fetching data.
     * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
     * @param {Array<string>} [filter] Select items in collection by given conditions.
     * @param {string} [search] Filter by items that contain the given search query in one of their fields.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsArticleTranslationApi
     */
    public readItemsArticleTranslation(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, options?: AxiosRequestConfig) {
        return ItemsArticleTranslationApiFp(this.configuration).readItemsArticleTranslation(fields, limit, meta, offset, sort, filter, search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a single ArticleTranslation item by unique identifier.
     * @summary Retrieve an Item
     * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsArticleTranslationApi
     */
    public readSingleItemsArticleTranslation(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, options?: AxiosRequestConfig) {
        return ItemsArticleTranslationApiFp(this.configuration).readSingleItemsArticleTranslation(id, fields, meta, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an existing ArticleTranslation item.
     * @summary Update an Item
     * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {ItemsArticleTranslation} [itemsArticleTranslation] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsArticleTranslationApi
     */
    public updateSingleItemsArticleTranslation(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, itemsArticleTranslation?: ItemsArticleTranslation, options?: AxiosRequestConfig) {
        return ItemsArticleTranslationApiFp(this.configuration).updateSingleItemsArticleTranslation(id, fields, meta, itemsArticleTranslation, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ItemsConditionApi - axios parameter creator
 * @export
 */
export const ItemsConditionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new Condition item.
         * @summary Create an Item
         * @param {string} [meta] What metadata to return in the response.
         * @param {CreateItemsConditionRequest} [createItemsConditionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createItemsCondition: async (meta?: string, createItemsConditionRequest?: CreateItemsConditionRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/items/Condition`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createItemsConditionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an existing Condition item.
         * @summary Delete an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSingleItemsCondition: async (id: ReadSingleItemsAnswerOptionIdParameter, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteSingleItemsCondition', 'id', id)
            const localVarPath = `/items/Condition/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List the Condition items.
         * @summary List Items
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {Array<string>} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readItemsCondition: async (fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/items/Condition`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sort) {
                localVarQueryParameter['sort'] = sort.join(COLLECTION_FORMATS.csv);
            }

            if (filter) {
                localVarQueryParameter['filter'] = filter;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a single Condition item by unique identifier.
         * @summary Retrieve an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readSingleItemsCondition: async (id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('readSingleItemsCondition', 'id', id)
            const localVarPath = `/items/Condition/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an existing Condition item.
         * @summary Update an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {ItemsCondition} [itemsCondition] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSingleItemsCondition: async (id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, itemsCondition?: ItemsCondition, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateSingleItemsCondition', 'id', id)
            const localVarPath = `/items/Condition/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(itemsCondition, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ItemsConditionApi - functional programming interface
 * @export
 */
export const ItemsConditionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ItemsConditionApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new Condition item.
         * @summary Create an Item
         * @param {string} [meta] What metadata to return in the response.
         * @param {CreateItemsConditionRequest} [createItemsConditionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createItemsCondition(meta?: string, createItemsConditionRequest?: CreateItemsConditionRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateItemsCondition200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createItemsCondition(meta, createItemsConditionRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete an existing Condition item.
         * @summary Delete an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSingleItemsCondition(id: ReadSingleItemsAnswerOptionIdParameter, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSingleItemsCondition(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List the Condition items.
         * @summary List Items
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {Array<string>} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readItemsCondition(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReadItemsCondition200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readItemsCondition(fields, limit, meta, offset, sort, filter, search, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve a single Condition item by unique identifier.
         * @summary Retrieve an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readSingleItemsCondition(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReadSingleItemsCondition200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readSingleItemsCondition(id, fields, meta, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update an existing Condition item.
         * @summary Update an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {ItemsCondition} [itemsCondition] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSingleItemsCondition(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, itemsCondition?: ItemsCondition, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReadSingleItemsCondition200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSingleItemsCondition(id, fields, meta, itemsCondition, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ItemsConditionApi - factory interface
 * @export
 */
export const ItemsConditionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ItemsConditionApiFp(configuration)
    return {
        /**
         * Create a new Condition item.
         * @summary Create an Item
         * @param {string} [meta] What metadata to return in the response.
         * @param {CreateItemsConditionRequest} [createItemsConditionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createItemsCondition(meta?: string, createItemsConditionRequest?: CreateItemsConditionRequest, options?: any): AxiosPromise<CreateItemsCondition200Response> {
            return localVarFp.createItemsCondition(meta, createItemsConditionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an existing Condition item.
         * @summary Delete an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSingleItemsCondition(id: ReadSingleItemsAnswerOptionIdParameter, options?: any): AxiosPromise<void> {
            return localVarFp.deleteSingleItemsCondition(id, options).then((request) => request(axios, basePath));
        },
        /**
         * List the Condition items.
         * @summary List Items
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {Array<string>} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readItemsCondition(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, options?: any): AxiosPromise<ReadItemsCondition200Response> {
            return localVarFp.readItemsCondition(fields, limit, meta, offset, sort, filter, search, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a single Condition item by unique identifier.
         * @summary Retrieve an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readSingleItemsCondition(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, options?: any): AxiosPromise<ReadSingleItemsCondition200Response> {
            return localVarFp.readSingleItemsCondition(id, fields, meta, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an existing Condition item.
         * @summary Update an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {ItemsCondition} [itemsCondition] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSingleItemsCondition(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, itemsCondition?: ItemsCondition, options?: any): AxiosPromise<ReadSingleItemsCondition200Response> {
            return localVarFp.updateSingleItemsCondition(id, fields, meta, itemsCondition, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ItemsConditionApi - object-oriented interface
 * @export
 * @class ItemsConditionApi
 * @extends {BaseAPI}
 */
export class ItemsConditionApi extends BaseAPI {
    /**
     * Create a new Condition item.
     * @summary Create an Item
     * @param {string} [meta] What metadata to return in the response.
     * @param {CreateItemsConditionRequest} [createItemsConditionRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsConditionApi
     */
    public createItemsCondition(meta?: string, createItemsConditionRequest?: CreateItemsConditionRequest, options?: AxiosRequestConfig) {
        return ItemsConditionApiFp(this.configuration).createItemsCondition(meta, createItemsConditionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an existing Condition item.
     * @summary Delete an Item
     * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsConditionApi
     */
    public deleteSingleItemsCondition(id: ReadSingleItemsAnswerOptionIdParameter, options?: AxiosRequestConfig) {
        return ItemsConditionApiFp(this.configuration).deleteSingleItemsCondition(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List the Condition items.
     * @summary List Items
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {number} [limit] A limit on the number of objects that are returned.
     * @param {string} [meta] What metadata to return in the response.
     * @param {number} [offset] How many items to skip when fetching data.
     * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
     * @param {Array<string>} [filter] Select items in collection by given conditions.
     * @param {string} [search] Filter by items that contain the given search query in one of their fields.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsConditionApi
     */
    public readItemsCondition(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, options?: AxiosRequestConfig) {
        return ItemsConditionApiFp(this.configuration).readItemsCondition(fields, limit, meta, offset, sort, filter, search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a single Condition item by unique identifier.
     * @summary Retrieve an Item
     * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsConditionApi
     */
    public readSingleItemsCondition(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, options?: AxiosRequestConfig) {
        return ItemsConditionApiFp(this.configuration).readSingleItemsCondition(id, fields, meta, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an existing Condition item.
     * @summary Update an Item
     * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {ItemsCondition} [itemsCondition] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsConditionApi
     */
    public updateSingleItemsCondition(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, itemsCondition?: ItemsCondition, options?: AxiosRequestConfig) {
        return ItemsConditionApiFp(this.configuration).updateSingleItemsCondition(id, fields, meta, itemsCondition, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ItemsConditionFactApi - axios parameter creator
 * @export
 */
export const ItemsConditionFactApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new ConditionFact item.
         * @summary Create an Item
         * @param {string} [meta] What metadata to return in the response.
         * @param {CreateItemsConditionFactRequest} [createItemsConditionFactRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createItemsConditionFact: async (meta?: string, createItemsConditionFactRequest?: CreateItemsConditionFactRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/items/ConditionFact`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createItemsConditionFactRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an existing ConditionFact item.
         * @summary Delete an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSingleItemsConditionFact: async (id: ReadSingleItemsAnswerOptionIdParameter, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteSingleItemsConditionFact', 'id', id)
            const localVarPath = `/items/ConditionFact/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List the ConditionFact items.
         * @summary List Items
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {Array<string>} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readItemsConditionFact: async (fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/items/ConditionFact`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sort) {
                localVarQueryParameter['sort'] = sort.join(COLLECTION_FORMATS.csv);
            }

            if (filter) {
                localVarQueryParameter['filter'] = filter;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a single ConditionFact item by unique identifier.
         * @summary Retrieve an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readSingleItemsConditionFact: async (id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('readSingleItemsConditionFact', 'id', id)
            const localVarPath = `/items/ConditionFact/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an existing ConditionFact item.
         * @summary Update an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {ItemsConditionFact} [itemsConditionFact] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSingleItemsConditionFact: async (id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, itemsConditionFact?: ItemsConditionFact, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateSingleItemsConditionFact', 'id', id)
            const localVarPath = `/items/ConditionFact/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(itemsConditionFact, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ItemsConditionFactApi - functional programming interface
 * @export
 */
export const ItemsConditionFactApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ItemsConditionFactApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new ConditionFact item.
         * @summary Create an Item
         * @param {string} [meta] What metadata to return in the response.
         * @param {CreateItemsConditionFactRequest} [createItemsConditionFactRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createItemsConditionFact(meta?: string, createItemsConditionFactRequest?: CreateItemsConditionFactRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateItemsConditionFact200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createItemsConditionFact(meta, createItemsConditionFactRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete an existing ConditionFact item.
         * @summary Delete an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSingleItemsConditionFact(id: ReadSingleItemsAnswerOptionIdParameter, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSingleItemsConditionFact(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List the ConditionFact items.
         * @summary List Items
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {Array<string>} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readItemsConditionFact(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReadItemsConditionFact200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readItemsConditionFact(fields, limit, meta, offset, sort, filter, search, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve a single ConditionFact item by unique identifier.
         * @summary Retrieve an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readSingleItemsConditionFact(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReadSingleItemsConditionFact200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readSingleItemsConditionFact(id, fields, meta, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update an existing ConditionFact item.
         * @summary Update an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {ItemsConditionFact} [itemsConditionFact] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSingleItemsConditionFact(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, itemsConditionFact?: ItemsConditionFact, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReadSingleItemsConditionFact200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSingleItemsConditionFact(id, fields, meta, itemsConditionFact, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ItemsConditionFactApi - factory interface
 * @export
 */
export const ItemsConditionFactApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ItemsConditionFactApiFp(configuration)
    return {
        /**
         * Create a new ConditionFact item.
         * @summary Create an Item
         * @param {string} [meta] What metadata to return in the response.
         * @param {CreateItemsConditionFactRequest} [createItemsConditionFactRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createItemsConditionFact(meta?: string, createItemsConditionFactRequest?: CreateItemsConditionFactRequest, options?: any): AxiosPromise<CreateItemsConditionFact200Response> {
            return localVarFp.createItemsConditionFact(meta, createItemsConditionFactRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an existing ConditionFact item.
         * @summary Delete an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSingleItemsConditionFact(id: ReadSingleItemsAnswerOptionIdParameter, options?: any): AxiosPromise<void> {
            return localVarFp.deleteSingleItemsConditionFact(id, options).then((request) => request(axios, basePath));
        },
        /**
         * List the ConditionFact items.
         * @summary List Items
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {Array<string>} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readItemsConditionFact(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, options?: any): AxiosPromise<ReadItemsConditionFact200Response> {
            return localVarFp.readItemsConditionFact(fields, limit, meta, offset, sort, filter, search, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a single ConditionFact item by unique identifier.
         * @summary Retrieve an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readSingleItemsConditionFact(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, options?: any): AxiosPromise<ReadSingleItemsConditionFact200Response> {
            return localVarFp.readSingleItemsConditionFact(id, fields, meta, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an existing ConditionFact item.
         * @summary Update an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {ItemsConditionFact} [itemsConditionFact] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSingleItemsConditionFact(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, itemsConditionFact?: ItemsConditionFact, options?: any): AxiosPromise<ReadSingleItemsConditionFact200Response> {
            return localVarFp.updateSingleItemsConditionFact(id, fields, meta, itemsConditionFact, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ItemsConditionFactApi - object-oriented interface
 * @export
 * @class ItemsConditionFactApi
 * @extends {BaseAPI}
 */
export class ItemsConditionFactApi extends BaseAPI {
    /**
     * Create a new ConditionFact item.
     * @summary Create an Item
     * @param {string} [meta] What metadata to return in the response.
     * @param {CreateItemsConditionFactRequest} [createItemsConditionFactRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsConditionFactApi
     */
    public createItemsConditionFact(meta?: string, createItemsConditionFactRequest?: CreateItemsConditionFactRequest, options?: AxiosRequestConfig) {
        return ItemsConditionFactApiFp(this.configuration).createItemsConditionFact(meta, createItemsConditionFactRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an existing ConditionFact item.
     * @summary Delete an Item
     * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsConditionFactApi
     */
    public deleteSingleItemsConditionFact(id: ReadSingleItemsAnswerOptionIdParameter, options?: AxiosRequestConfig) {
        return ItemsConditionFactApiFp(this.configuration).deleteSingleItemsConditionFact(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List the ConditionFact items.
     * @summary List Items
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {number} [limit] A limit on the number of objects that are returned.
     * @param {string} [meta] What metadata to return in the response.
     * @param {number} [offset] How many items to skip when fetching data.
     * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
     * @param {Array<string>} [filter] Select items in collection by given conditions.
     * @param {string} [search] Filter by items that contain the given search query in one of their fields.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsConditionFactApi
     */
    public readItemsConditionFact(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, options?: AxiosRequestConfig) {
        return ItemsConditionFactApiFp(this.configuration).readItemsConditionFact(fields, limit, meta, offset, sort, filter, search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a single ConditionFact item by unique identifier.
     * @summary Retrieve an Item
     * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsConditionFactApi
     */
    public readSingleItemsConditionFact(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, options?: AxiosRequestConfig) {
        return ItemsConditionFactApiFp(this.configuration).readSingleItemsConditionFact(id, fields, meta, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an existing ConditionFact item.
     * @summary Update an Item
     * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {ItemsConditionFact} [itemsConditionFact] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsConditionFactApi
     */
    public updateSingleItemsConditionFact(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, itemsConditionFact?: ItemsConditionFact, options?: AxiosRequestConfig) {
        return ItemsConditionFactApiFp(this.configuration).updateSingleItemsConditionFact(id, fields, meta, itemsConditionFact, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ItemsFactApi - axios parameter creator
 * @export
 */
export const ItemsFactApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new Fact item.
         * @summary Create an Item
         * @param {string} [meta] What metadata to return in the response.
         * @param {CreateItemsFactRequest} [createItemsFactRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createItemsFact: async (meta?: string, createItemsFactRequest?: CreateItemsFactRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/items/Fact`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createItemsFactRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an existing Fact item.
         * @summary Delete an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSingleItemsFact: async (id: ReadSingleItemsAnswerOptionIdParameter, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteSingleItemsFact', 'id', id)
            const localVarPath = `/items/Fact/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List the Fact items.
         * @summary List Items
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {Array<string>} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readItemsFact: async (fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/items/Fact`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sort) {
                localVarQueryParameter['sort'] = sort.join(COLLECTION_FORMATS.csv);
            }

            if (filter) {
                localVarQueryParameter['filter'] = filter;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a single Fact item by unique identifier.
         * @summary Retrieve an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readSingleItemsFact: async (id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('readSingleItemsFact', 'id', id)
            const localVarPath = `/items/Fact/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an existing Fact item.
         * @summary Update an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {ItemsFact} [itemsFact] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSingleItemsFact: async (id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, itemsFact?: ItemsFact, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateSingleItemsFact', 'id', id)
            const localVarPath = `/items/Fact/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(itemsFact, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ItemsFactApi - functional programming interface
 * @export
 */
export const ItemsFactApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ItemsFactApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new Fact item.
         * @summary Create an Item
         * @param {string} [meta] What metadata to return in the response.
         * @param {CreateItemsFactRequest} [createItemsFactRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createItemsFact(meta?: string, createItemsFactRequest?: CreateItemsFactRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateItemsFact200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createItemsFact(meta, createItemsFactRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete an existing Fact item.
         * @summary Delete an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSingleItemsFact(id: ReadSingleItemsAnswerOptionIdParameter, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSingleItemsFact(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List the Fact items.
         * @summary List Items
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {Array<string>} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readItemsFact(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReadItemsFact200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readItemsFact(fields, limit, meta, offset, sort, filter, search, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve a single Fact item by unique identifier.
         * @summary Retrieve an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readSingleItemsFact(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReadSingleItemsFact200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readSingleItemsFact(id, fields, meta, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update an existing Fact item.
         * @summary Update an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {ItemsFact} [itemsFact] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSingleItemsFact(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, itemsFact?: ItemsFact, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReadSingleItemsFact200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSingleItemsFact(id, fields, meta, itemsFact, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ItemsFactApi - factory interface
 * @export
 */
export const ItemsFactApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ItemsFactApiFp(configuration)
    return {
        /**
         * Create a new Fact item.
         * @summary Create an Item
         * @param {string} [meta] What metadata to return in the response.
         * @param {CreateItemsFactRequest} [createItemsFactRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createItemsFact(meta?: string, createItemsFactRequest?: CreateItemsFactRequest, options?: any): AxiosPromise<CreateItemsFact200Response> {
            return localVarFp.createItemsFact(meta, createItemsFactRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an existing Fact item.
         * @summary Delete an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSingleItemsFact(id: ReadSingleItemsAnswerOptionIdParameter, options?: any): AxiosPromise<void> {
            return localVarFp.deleteSingleItemsFact(id, options).then((request) => request(axios, basePath));
        },
        /**
         * List the Fact items.
         * @summary List Items
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {Array<string>} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readItemsFact(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, options?: any): AxiosPromise<ReadItemsFact200Response> {
            return localVarFp.readItemsFact(fields, limit, meta, offset, sort, filter, search, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a single Fact item by unique identifier.
         * @summary Retrieve an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readSingleItemsFact(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, options?: any): AxiosPromise<ReadSingleItemsFact200Response> {
            return localVarFp.readSingleItemsFact(id, fields, meta, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an existing Fact item.
         * @summary Update an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {ItemsFact} [itemsFact] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSingleItemsFact(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, itemsFact?: ItemsFact, options?: any): AxiosPromise<ReadSingleItemsFact200Response> {
            return localVarFp.updateSingleItemsFact(id, fields, meta, itemsFact, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ItemsFactApi - object-oriented interface
 * @export
 * @class ItemsFactApi
 * @extends {BaseAPI}
 */
export class ItemsFactApi extends BaseAPI {
    /**
     * Create a new Fact item.
     * @summary Create an Item
     * @param {string} [meta] What metadata to return in the response.
     * @param {CreateItemsFactRequest} [createItemsFactRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsFactApi
     */
    public createItemsFact(meta?: string, createItemsFactRequest?: CreateItemsFactRequest, options?: AxiosRequestConfig) {
        return ItemsFactApiFp(this.configuration).createItemsFact(meta, createItemsFactRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an existing Fact item.
     * @summary Delete an Item
     * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsFactApi
     */
    public deleteSingleItemsFact(id: ReadSingleItemsAnswerOptionIdParameter, options?: AxiosRequestConfig) {
        return ItemsFactApiFp(this.configuration).deleteSingleItemsFact(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List the Fact items.
     * @summary List Items
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {number} [limit] A limit on the number of objects that are returned.
     * @param {string} [meta] What metadata to return in the response.
     * @param {number} [offset] How many items to skip when fetching data.
     * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
     * @param {Array<string>} [filter] Select items in collection by given conditions.
     * @param {string} [search] Filter by items that contain the given search query in one of their fields.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsFactApi
     */
    public readItemsFact(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, options?: AxiosRequestConfig) {
        return ItemsFactApiFp(this.configuration).readItemsFact(fields, limit, meta, offset, sort, filter, search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a single Fact item by unique identifier.
     * @summary Retrieve an Item
     * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsFactApi
     */
    public readSingleItemsFact(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, options?: AxiosRequestConfig) {
        return ItemsFactApiFp(this.configuration).readSingleItemsFact(id, fields, meta, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an existing Fact item.
     * @summary Update an Item
     * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {ItemsFact} [itemsFact] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsFactApi
     */
    public updateSingleItemsFact(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, itemsFact?: ItemsFact, options?: AxiosRequestConfig) {
        return ItemsFactApiFp(this.configuration).updateSingleItemsFact(id, fields, meta, itemsFact, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ItemsLanguageApi - axios parameter creator
 * @export
 */
export const ItemsLanguageApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * List the Language items.
         * @summary List Items
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {Array<string>} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readItemsLanguage: async (fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/items/Language`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sort) {
                localVarQueryParameter['sort'] = sort.join(COLLECTION_FORMATS.csv);
            }

            if (filter) {
                localVarQueryParameter['filter'] = filter;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a single Language item by unique identifier.
         * @summary Retrieve an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readSingleItemsLanguage: async (id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('readSingleItemsLanguage', 'id', id)
            const localVarPath = `/items/Language/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ItemsLanguageApi - functional programming interface
 * @export
 */
export const ItemsLanguageApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ItemsLanguageApiAxiosParamCreator(configuration)
    return {
        /**
         * List the Language items.
         * @summary List Items
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {Array<string>} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readItemsLanguage(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReadItemsLanguage200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readItemsLanguage(fields, limit, meta, offset, sort, filter, search, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve a single Language item by unique identifier.
         * @summary Retrieve an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readSingleItemsLanguage(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReadSingleItemsLanguage200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readSingleItemsLanguage(id, fields, meta, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ItemsLanguageApi - factory interface
 * @export
 */
export const ItemsLanguageApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ItemsLanguageApiFp(configuration)
    return {
        /**
         * List the Language items.
         * @summary List Items
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {Array<string>} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readItemsLanguage(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, options?: any): AxiosPromise<ReadItemsLanguage200Response> {
            return localVarFp.readItemsLanguage(fields, limit, meta, offset, sort, filter, search, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a single Language item by unique identifier.
         * @summary Retrieve an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readSingleItemsLanguage(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, options?: any): AxiosPromise<ReadSingleItemsLanguage200Response> {
            return localVarFp.readSingleItemsLanguage(id, fields, meta, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ItemsLanguageApi - object-oriented interface
 * @export
 * @class ItemsLanguageApi
 * @extends {BaseAPI}
 */
export class ItemsLanguageApi extends BaseAPI {
    /**
     * List the Language items.
     * @summary List Items
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {number} [limit] A limit on the number of objects that are returned.
     * @param {string} [meta] What metadata to return in the response.
     * @param {number} [offset] How many items to skip when fetching data.
     * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
     * @param {Array<string>} [filter] Select items in collection by given conditions.
     * @param {string} [search] Filter by items that contain the given search query in one of their fields.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsLanguageApi
     */
    public readItemsLanguage(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, options?: AxiosRequestConfig) {
        return ItemsLanguageApiFp(this.configuration).readItemsLanguage(fields, limit, meta, offset, sort, filter, search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a single Language item by unique identifier.
     * @summary Retrieve an Item
     * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsLanguageApi
     */
    public readSingleItemsLanguage(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, options?: AxiosRequestConfig) {
        return ItemsLanguageApiFp(this.configuration).readSingleItemsLanguage(id, fields, meta, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ItemsMeaningApi - axios parameter creator
 * @export
 */
export const ItemsMeaningApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * List the Meaning items.
         * @summary List Items
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {Array<string>} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readItemsMeaning: async (fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/items/Meaning`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sort) {
                localVarQueryParameter['sort'] = sort.join(COLLECTION_FORMATS.csv);
            }

            if (filter) {
                localVarQueryParameter['filter'] = filter;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a single Meaning item by unique identifier.
         * @summary Retrieve an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readSingleItemsMeaning: async (id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('readSingleItemsMeaning', 'id', id)
            const localVarPath = `/items/Meaning/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ItemsMeaningApi - functional programming interface
 * @export
 */
export const ItemsMeaningApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ItemsMeaningApiAxiosParamCreator(configuration)
    return {
        /**
         * List the Meaning items.
         * @summary List Items
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {Array<string>} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readItemsMeaning(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReadItemsMeaning200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readItemsMeaning(fields, limit, meta, offset, sort, filter, search, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve a single Meaning item by unique identifier.
         * @summary Retrieve an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readSingleItemsMeaning(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReadSingleItemsMeaning200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readSingleItemsMeaning(id, fields, meta, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ItemsMeaningApi - factory interface
 * @export
 */
export const ItemsMeaningApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ItemsMeaningApiFp(configuration)
    return {
        /**
         * List the Meaning items.
         * @summary List Items
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {Array<string>} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readItemsMeaning(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, options?: any): AxiosPromise<ReadItemsMeaning200Response> {
            return localVarFp.readItemsMeaning(fields, limit, meta, offset, sort, filter, search, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a single Meaning item by unique identifier.
         * @summary Retrieve an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readSingleItemsMeaning(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, options?: any): AxiosPromise<ReadSingleItemsMeaning200Response> {
            return localVarFp.readSingleItemsMeaning(id, fields, meta, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ItemsMeaningApi - object-oriented interface
 * @export
 * @class ItemsMeaningApi
 * @extends {BaseAPI}
 */
export class ItemsMeaningApi extends BaseAPI {
    /**
     * List the Meaning items.
     * @summary List Items
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {number} [limit] A limit on the number of objects that are returned.
     * @param {string} [meta] What metadata to return in the response.
     * @param {number} [offset] How many items to skip when fetching data.
     * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
     * @param {Array<string>} [filter] Select items in collection by given conditions.
     * @param {string} [search] Filter by items that contain the given search query in one of their fields.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsMeaningApi
     */
    public readItemsMeaning(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, options?: AxiosRequestConfig) {
        return ItemsMeaningApiFp(this.configuration).readItemsMeaning(fields, limit, meta, offset, sort, filter, search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a single Meaning item by unique identifier.
     * @summary Retrieve an Item
     * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsMeaningApi
     */
    public readSingleItemsMeaning(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, options?: AxiosRequestConfig) {
        return ItemsMeaningApiFp(this.configuration).readSingleItemsMeaning(id, fields, meta, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ItemsOperatorApi - axios parameter creator
 * @export
 */
export const ItemsOperatorApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * List the Operator items.
         * @summary List Items
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {Array<string>} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readItemsOperator: async (fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/items/Operator`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sort) {
                localVarQueryParameter['sort'] = sort.join(COLLECTION_FORMATS.csv);
            }

            if (filter) {
                localVarQueryParameter['filter'] = filter;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a single Operator item by unique identifier.
         * @summary Retrieve an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readSingleItemsOperator: async (id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('readSingleItemsOperator', 'id', id)
            const localVarPath = `/items/Operator/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ItemsOperatorApi - functional programming interface
 * @export
 */
export const ItemsOperatorApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ItemsOperatorApiAxiosParamCreator(configuration)
    return {
        /**
         * List the Operator items.
         * @summary List Items
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {Array<string>} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readItemsOperator(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReadItemsOperator200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readItemsOperator(fields, limit, meta, offset, sort, filter, search, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve a single Operator item by unique identifier.
         * @summary Retrieve an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readSingleItemsOperator(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReadSingleItemsOperator200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readSingleItemsOperator(id, fields, meta, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ItemsOperatorApi - factory interface
 * @export
 */
export const ItemsOperatorApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ItemsOperatorApiFp(configuration)
    return {
        /**
         * List the Operator items.
         * @summary List Items
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {Array<string>} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readItemsOperator(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, options?: any): AxiosPromise<ReadItemsOperator200Response> {
            return localVarFp.readItemsOperator(fields, limit, meta, offset, sort, filter, search, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a single Operator item by unique identifier.
         * @summary Retrieve an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readSingleItemsOperator(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, options?: any): AxiosPromise<ReadSingleItemsOperator200Response> {
            return localVarFp.readSingleItemsOperator(id, fields, meta, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ItemsOperatorApi - object-oriented interface
 * @export
 * @class ItemsOperatorApi
 * @extends {BaseAPI}
 */
export class ItemsOperatorApi extends BaseAPI {
    /**
     * List the Operator items.
     * @summary List Items
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {number} [limit] A limit on the number of objects that are returned.
     * @param {string} [meta] What metadata to return in the response.
     * @param {number} [offset] How many items to skip when fetching data.
     * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
     * @param {Array<string>} [filter] Select items in collection by given conditions.
     * @param {string} [search] Filter by items that contain the given search query in one of their fields.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsOperatorApi
     */
    public readItemsOperator(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, options?: AxiosRequestConfig) {
        return ItemsOperatorApiFp(this.configuration).readItemsOperator(fields, limit, meta, offset, sort, filter, search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a single Operator item by unique identifier.
     * @summary Retrieve an Item
     * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsOperatorApi
     */
    public readSingleItemsOperator(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, options?: AxiosRequestConfig) {
        return ItemsOperatorApiFp(this.configuration).readSingleItemsOperator(id, fields, meta, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ItemsQuestionApi - axios parameter creator
 * @export
 */
export const ItemsQuestionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new Question item.
         * @summary Create an Item
         * @param {string} [meta] What metadata to return in the response.
         * @param {CreateItemsQuestionRequest} [createItemsQuestionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createItemsQuestion: async (meta?: string, createItemsQuestionRequest?: CreateItemsQuestionRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/items/Question`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createItemsQuestionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an existing Question item.
         * @summary Delete an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSingleItemsQuestion: async (id: ReadSingleItemsAnswerOptionIdParameter, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteSingleItemsQuestion', 'id', id)
            const localVarPath = `/items/Question/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List the Question items.
         * @summary List Items
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {Array<string>} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readItemsQuestion: async (fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/items/Question`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sort) {
                localVarQueryParameter['sort'] = sort.join(COLLECTION_FORMATS.csv);
            }

            if (filter) {
                localVarQueryParameter['filter'] = filter;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a single Question item by unique identifier.
         * @summary Retrieve an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readSingleItemsQuestion: async (id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('readSingleItemsQuestion', 'id', id)
            const localVarPath = `/items/Question/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an existing Question item.
         * @summary Update an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {ItemsQuestion} [itemsQuestion] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSingleItemsQuestion: async (id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, itemsQuestion?: ItemsQuestion, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateSingleItemsQuestion', 'id', id)
            const localVarPath = `/items/Question/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(itemsQuestion, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ItemsQuestionApi - functional programming interface
 * @export
 */
export const ItemsQuestionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ItemsQuestionApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new Question item.
         * @summary Create an Item
         * @param {string} [meta] What metadata to return in the response.
         * @param {CreateItemsQuestionRequest} [createItemsQuestionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createItemsQuestion(meta?: string, createItemsQuestionRequest?: CreateItemsQuestionRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateItemsQuestion200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createItemsQuestion(meta, createItemsQuestionRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete an existing Question item.
         * @summary Delete an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSingleItemsQuestion(id: ReadSingleItemsAnswerOptionIdParameter, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSingleItemsQuestion(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List the Question items.
         * @summary List Items
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {Array<string>} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readItemsQuestion(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReadItemsQuestion200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readItemsQuestion(fields, limit, meta, offset, sort, filter, search, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve a single Question item by unique identifier.
         * @summary Retrieve an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readSingleItemsQuestion(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReadSingleItemsQuestion200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readSingleItemsQuestion(id, fields, meta, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update an existing Question item.
         * @summary Update an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {ItemsQuestion} [itemsQuestion] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSingleItemsQuestion(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, itemsQuestion?: ItemsQuestion, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReadSingleItemsQuestion200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSingleItemsQuestion(id, fields, meta, itemsQuestion, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ItemsQuestionApi - factory interface
 * @export
 */
export const ItemsQuestionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ItemsQuestionApiFp(configuration)
    return {
        /**
         * Create a new Question item.
         * @summary Create an Item
         * @param {string} [meta] What metadata to return in the response.
         * @param {CreateItemsQuestionRequest} [createItemsQuestionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createItemsQuestion(meta?: string, createItemsQuestionRequest?: CreateItemsQuestionRequest, options?: any): AxiosPromise<CreateItemsQuestion200Response> {
            return localVarFp.createItemsQuestion(meta, createItemsQuestionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an existing Question item.
         * @summary Delete an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSingleItemsQuestion(id: ReadSingleItemsAnswerOptionIdParameter, options?: any): AxiosPromise<void> {
            return localVarFp.deleteSingleItemsQuestion(id, options).then((request) => request(axios, basePath));
        },
        /**
         * List the Question items.
         * @summary List Items
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {Array<string>} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readItemsQuestion(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, options?: any): AxiosPromise<ReadItemsQuestion200Response> {
            return localVarFp.readItemsQuestion(fields, limit, meta, offset, sort, filter, search, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a single Question item by unique identifier.
         * @summary Retrieve an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readSingleItemsQuestion(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, options?: any): AxiosPromise<ReadSingleItemsQuestion200Response> {
            return localVarFp.readSingleItemsQuestion(id, fields, meta, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an existing Question item.
         * @summary Update an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {ItemsQuestion} [itemsQuestion] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSingleItemsQuestion(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, itemsQuestion?: ItemsQuestion, options?: any): AxiosPromise<ReadSingleItemsQuestion200Response> {
            return localVarFp.updateSingleItemsQuestion(id, fields, meta, itemsQuestion, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ItemsQuestionApi - object-oriented interface
 * @export
 * @class ItemsQuestionApi
 * @extends {BaseAPI}
 */
export class ItemsQuestionApi extends BaseAPI {
    /**
     * Create a new Question item.
     * @summary Create an Item
     * @param {string} [meta] What metadata to return in the response.
     * @param {CreateItemsQuestionRequest} [createItemsQuestionRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsQuestionApi
     */
    public createItemsQuestion(meta?: string, createItemsQuestionRequest?: CreateItemsQuestionRequest, options?: AxiosRequestConfig) {
        return ItemsQuestionApiFp(this.configuration).createItemsQuestion(meta, createItemsQuestionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an existing Question item.
     * @summary Delete an Item
     * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsQuestionApi
     */
    public deleteSingleItemsQuestion(id: ReadSingleItemsAnswerOptionIdParameter, options?: AxiosRequestConfig) {
        return ItemsQuestionApiFp(this.configuration).deleteSingleItemsQuestion(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List the Question items.
     * @summary List Items
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {number} [limit] A limit on the number of objects that are returned.
     * @param {string} [meta] What metadata to return in the response.
     * @param {number} [offset] How many items to skip when fetching data.
     * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
     * @param {Array<string>} [filter] Select items in collection by given conditions.
     * @param {string} [search] Filter by items that contain the given search query in one of their fields.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsQuestionApi
     */
    public readItemsQuestion(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, options?: AxiosRequestConfig) {
        return ItemsQuestionApiFp(this.configuration).readItemsQuestion(fields, limit, meta, offset, sort, filter, search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a single Question item by unique identifier.
     * @summary Retrieve an Item
     * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsQuestionApi
     */
    public readSingleItemsQuestion(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, options?: AxiosRequestConfig) {
        return ItemsQuestionApiFp(this.configuration).readSingleItemsQuestion(id, fields, meta, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an existing Question item.
     * @summary Update an Item
     * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {ItemsQuestion} [itemsQuestion] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsQuestionApi
     */
    public updateSingleItemsQuestion(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, itemsQuestion?: ItemsQuestion, options?: AxiosRequestConfig) {
        return ItemsQuestionApiFp(this.configuration).updateSingleItemsQuestion(id, fields, meta, itemsQuestion, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ItemsQuestionTranslationApi - axios parameter creator
 * @export
 */
export const ItemsQuestionTranslationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new QuestionTranslation item.
         * @summary Create an Item
         * @param {string} [meta] What metadata to return in the response.
         * @param {CreateItemsQuestionTranslationRequest} [createItemsQuestionTranslationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createItemsQuestionTranslation: async (meta?: string, createItemsQuestionTranslationRequest?: CreateItemsQuestionTranslationRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/items/QuestionTranslation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createItemsQuestionTranslationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an existing QuestionTranslation item.
         * @summary Delete an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSingleItemsQuestionTranslation: async (id: ReadSingleItemsAnswerOptionIdParameter, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteSingleItemsQuestionTranslation', 'id', id)
            const localVarPath = `/items/QuestionTranslation/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List the QuestionTranslation items.
         * @summary List Items
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {Array<string>} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readItemsQuestionTranslation: async (fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/items/QuestionTranslation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sort) {
                localVarQueryParameter['sort'] = sort.join(COLLECTION_FORMATS.csv);
            }

            if (filter) {
                localVarQueryParameter['filter'] = filter;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a single QuestionTranslation item by unique identifier.
         * @summary Retrieve an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readSingleItemsQuestionTranslation: async (id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('readSingleItemsQuestionTranslation', 'id', id)
            const localVarPath = `/items/QuestionTranslation/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an existing QuestionTranslation item.
         * @summary Update an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {ItemsQuestionTranslation} [itemsQuestionTranslation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSingleItemsQuestionTranslation: async (id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, itemsQuestionTranslation?: ItemsQuestionTranslation, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateSingleItemsQuestionTranslation', 'id', id)
            const localVarPath = `/items/QuestionTranslation/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(itemsQuestionTranslation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ItemsQuestionTranslationApi - functional programming interface
 * @export
 */
export const ItemsQuestionTranslationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ItemsQuestionTranslationApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new QuestionTranslation item.
         * @summary Create an Item
         * @param {string} [meta] What metadata to return in the response.
         * @param {CreateItemsQuestionTranslationRequest} [createItemsQuestionTranslationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createItemsQuestionTranslation(meta?: string, createItemsQuestionTranslationRequest?: CreateItemsQuestionTranslationRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateItemsQuestionTranslation200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createItemsQuestionTranslation(meta, createItemsQuestionTranslationRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete an existing QuestionTranslation item.
         * @summary Delete an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSingleItemsQuestionTranslation(id: ReadSingleItemsAnswerOptionIdParameter, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSingleItemsQuestionTranslation(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List the QuestionTranslation items.
         * @summary List Items
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {Array<string>} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readItemsQuestionTranslation(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReadItemsQuestionTranslation200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readItemsQuestionTranslation(fields, limit, meta, offset, sort, filter, search, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve a single QuestionTranslation item by unique identifier.
         * @summary Retrieve an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readSingleItemsQuestionTranslation(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReadSingleItemsQuestionTranslation200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readSingleItemsQuestionTranslation(id, fields, meta, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update an existing QuestionTranslation item.
         * @summary Update an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {ItemsQuestionTranslation} [itemsQuestionTranslation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSingleItemsQuestionTranslation(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, itemsQuestionTranslation?: ItemsQuestionTranslation, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReadSingleItemsQuestionTranslation200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSingleItemsQuestionTranslation(id, fields, meta, itemsQuestionTranslation, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ItemsQuestionTranslationApi - factory interface
 * @export
 */
export const ItemsQuestionTranslationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ItemsQuestionTranslationApiFp(configuration)
    return {
        /**
         * Create a new QuestionTranslation item.
         * @summary Create an Item
         * @param {string} [meta] What metadata to return in the response.
         * @param {CreateItemsQuestionTranslationRequest} [createItemsQuestionTranslationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createItemsQuestionTranslation(meta?: string, createItemsQuestionTranslationRequest?: CreateItemsQuestionTranslationRequest, options?: any): AxiosPromise<CreateItemsQuestionTranslation200Response> {
            return localVarFp.createItemsQuestionTranslation(meta, createItemsQuestionTranslationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an existing QuestionTranslation item.
         * @summary Delete an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSingleItemsQuestionTranslation(id: ReadSingleItemsAnswerOptionIdParameter, options?: any): AxiosPromise<void> {
            return localVarFp.deleteSingleItemsQuestionTranslation(id, options).then((request) => request(axios, basePath));
        },
        /**
         * List the QuestionTranslation items.
         * @summary List Items
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {Array<string>} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readItemsQuestionTranslation(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, options?: any): AxiosPromise<ReadItemsQuestionTranslation200Response> {
            return localVarFp.readItemsQuestionTranslation(fields, limit, meta, offset, sort, filter, search, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a single QuestionTranslation item by unique identifier.
         * @summary Retrieve an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readSingleItemsQuestionTranslation(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, options?: any): AxiosPromise<ReadSingleItemsQuestionTranslation200Response> {
            return localVarFp.readSingleItemsQuestionTranslation(id, fields, meta, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an existing QuestionTranslation item.
         * @summary Update an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {ItemsQuestionTranslation} [itemsQuestionTranslation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSingleItemsQuestionTranslation(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, itemsQuestionTranslation?: ItemsQuestionTranslation, options?: any): AxiosPromise<ReadSingleItemsQuestionTranslation200Response> {
            return localVarFp.updateSingleItemsQuestionTranslation(id, fields, meta, itemsQuestionTranslation, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ItemsQuestionTranslationApi - object-oriented interface
 * @export
 * @class ItemsQuestionTranslationApi
 * @extends {BaseAPI}
 */
export class ItemsQuestionTranslationApi extends BaseAPI {
    /**
     * Create a new QuestionTranslation item.
     * @summary Create an Item
     * @param {string} [meta] What metadata to return in the response.
     * @param {CreateItemsQuestionTranslationRequest} [createItemsQuestionTranslationRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsQuestionTranslationApi
     */
    public createItemsQuestionTranslation(meta?: string, createItemsQuestionTranslationRequest?: CreateItemsQuestionTranslationRequest, options?: AxiosRequestConfig) {
        return ItemsQuestionTranslationApiFp(this.configuration).createItemsQuestionTranslation(meta, createItemsQuestionTranslationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an existing QuestionTranslation item.
     * @summary Delete an Item
     * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsQuestionTranslationApi
     */
    public deleteSingleItemsQuestionTranslation(id: ReadSingleItemsAnswerOptionIdParameter, options?: AxiosRequestConfig) {
        return ItemsQuestionTranslationApiFp(this.configuration).deleteSingleItemsQuestionTranslation(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List the QuestionTranslation items.
     * @summary List Items
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {number} [limit] A limit on the number of objects that are returned.
     * @param {string} [meta] What metadata to return in the response.
     * @param {number} [offset] How many items to skip when fetching data.
     * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
     * @param {Array<string>} [filter] Select items in collection by given conditions.
     * @param {string} [search] Filter by items that contain the given search query in one of their fields.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsQuestionTranslationApi
     */
    public readItemsQuestionTranslation(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, options?: AxiosRequestConfig) {
        return ItemsQuestionTranslationApiFp(this.configuration).readItemsQuestionTranslation(fields, limit, meta, offset, sort, filter, search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a single QuestionTranslation item by unique identifier.
     * @summary Retrieve an Item
     * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsQuestionTranslationApi
     */
    public readSingleItemsQuestionTranslation(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, options?: AxiosRequestConfig) {
        return ItemsQuestionTranslationApiFp(this.configuration).readSingleItemsQuestionTranslation(id, fields, meta, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an existing QuestionTranslation item.
     * @summary Update an Item
     * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {ItemsQuestionTranslation} [itemsQuestionTranslation] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsQuestionTranslationApi
     */
    public updateSingleItemsQuestionTranslation(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, itemsQuestionTranslation?: ItemsQuestionTranslation, options?: AxiosRequestConfig) {
        return ItemsQuestionTranslationApiFp(this.configuration).updateSingleItemsQuestionTranslation(id, fields, meta, itemsQuestionTranslation, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ItemsQuestiondisplayApi - axios parameter creator
 * @export
 */
export const ItemsQuestiondisplayApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * List the QuestionDisplay items.
         * @summary List Items
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {Array<string>} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readItemsQuestiondisplay: async (fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/items/QuestionDisplay`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sort) {
                localVarQueryParameter['sort'] = sort.join(COLLECTION_FORMATS.csv);
            }

            if (filter) {
                localVarQueryParameter['filter'] = filter;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a single QuestionDisplay item by unique identifier.
         * @summary Retrieve an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readSingleItemsQuestiondisplay: async (id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('readSingleItemsQuestiondisplay', 'id', id)
            const localVarPath = `/items/QuestionDisplay/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ItemsQuestiondisplayApi - functional programming interface
 * @export
 */
export const ItemsQuestiondisplayApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ItemsQuestiondisplayApiAxiosParamCreator(configuration)
    return {
        /**
         * List the QuestionDisplay items.
         * @summary List Items
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {Array<string>} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readItemsQuestiondisplay(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReadItemsQuestiondisplay200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readItemsQuestiondisplay(fields, limit, meta, offset, sort, filter, search, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve a single QuestionDisplay item by unique identifier.
         * @summary Retrieve an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readSingleItemsQuestiondisplay(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReadSingleItemsQuestiondisplay200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readSingleItemsQuestiondisplay(id, fields, meta, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ItemsQuestiondisplayApi - factory interface
 * @export
 */
export const ItemsQuestiondisplayApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ItemsQuestiondisplayApiFp(configuration)
    return {
        /**
         * List the QuestionDisplay items.
         * @summary List Items
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {Array<string>} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readItemsQuestiondisplay(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, options?: any): AxiosPromise<ReadItemsQuestiondisplay200Response> {
            return localVarFp.readItemsQuestiondisplay(fields, limit, meta, offset, sort, filter, search, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a single QuestionDisplay item by unique identifier.
         * @summary Retrieve an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readSingleItemsQuestiondisplay(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, options?: any): AxiosPromise<ReadSingleItemsQuestiondisplay200Response> {
            return localVarFp.readSingleItemsQuestiondisplay(id, fields, meta, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ItemsQuestiondisplayApi - object-oriented interface
 * @export
 * @class ItemsQuestiondisplayApi
 * @extends {BaseAPI}
 */
export class ItemsQuestiondisplayApi extends BaseAPI {
    /**
     * List the QuestionDisplay items.
     * @summary List Items
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {number} [limit] A limit on the number of objects that are returned.
     * @param {string} [meta] What metadata to return in the response.
     * @param {number} [offset] How many items to skip when fetching data.
     * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
     * @param {Array<string>} [filter] Select items in collection by given conditions.
     * @param {string} [search] Filter by items that contain the given search query in one of their fields.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsQuestiondisplayApi
     */
    public readItemsQuestiondisplay(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, options?: AxiosRequestConfig) {
        return ItemsQuestiondisplayApiFp(this.configuration).readItemsQuestiondisplay(fields, limit, meta, offset, sort, filter, search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a single QuestionDisplay item by unique identifier.
     * @summary Retrieve an Item
     * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsQuestiondisplayApi
     */
    public readSingleItemsQuestiondisplay(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, options?: AxiosRequestConfig) {
        return ItemsQuestiondisplayApiFp(this.configuration).readSingleItemsQuestiondisplay(id, fields, meta, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ItemsQuestionnaireApi - axios parameter creator
 * @export
 */
export const ItemsQuestionnaireApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new Questionnaire item.
         * @summary Create an Item
         * @param {string} [meta] What metadata to return in the response.
         * @param {CreateItemsQuestionnaireRequest} [createItemsQuestionnaireRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createItemsQuestionnaire: async (meta?: string, createItemsQuestionnaireRequest?: CreateItemsQuestionnaireRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/items/Questionnaire`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createItemsQuestionnaireRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an existing Questionnaire item.
         * @summary Delete an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSingleItemsQuestionnaire: async (id: ReadSingleItemsAnswerOptionIdParameter, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteSingleItemsQuestionnaire', 'id', id)
            const localVarPath = `/items/Questionnaire/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List the Questionnaire items.
         * @summary List Items
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {Array<string>} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readItemsQuestionnaire: async (fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/items/Questionnaire`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sort) {
                localVarQueryParameter['sort'] = sort.join(COLLECTION_FORMATS.csv);
            }

            if (filter) {
                localVarQueryParameter['filter'] = filter;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a single Questionnaire item by unique identifier.
         * @summary Retrieve an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readSingleItemsQuestionnaire: async (id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('readSingleItemsQuestionnaire', 'id', id)
            const localVarPath = `/items/Questionnaire/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an existing Questionnaire item.
         * @summary Update an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {ItemsQuestionnaire} [itemsQuestionnaire] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSingleItemsQuestionnaire: async (id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, itemsQuestionnaire?: ItemsQuestionnaire, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateSingleItemsQuestionnaire', 'id', id)
            const localVarPath = `/items/Questionnaire/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(itemsQuestionnaire, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ItemsQuestionnaireApi - functional programming interface
 * @export
 */
export const ItemsQuestionnaireApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ItemsQuestionnaireApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new Questionnaire item.
         * @summary Create an Item
         * @param {string} [meta] What metadata to return in the response.
         * @param {CreateItemsQuestionnaireRequest} [createItemsQuestionnaireRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createItemsQuestionnaire(meta?: string, createItemsQuestionnaireRequest?: CreateItemsQuestionnaireRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateItemsQuestionnaire200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createItemsQuestionnaire(meta, createItemsQuestionnaireRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete an existing Questionnaire item.
         * @summary Delete an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSingleItemsQuestionnaire(id: ReadSingleItemsAnswerOptionIdParameter, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSingleItemsQuestionnaire(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List the Questionnaire items.
         * @summary List Items
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {Array<string>} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readItemsQuestionnaire(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReadItemsQuestionnaire200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readItemsQuestionnaire(fields, limit, meta, offset, sort, filter, search, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve a single Questionnaire item by unique identifier.
         * @summary Retrieve an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readSingleItemsQuestionnaire(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReadSingleItemsQuestionnaire200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readSingleItemsQuestionnaire(id, fields, meta, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update an existing Questionnaire item.
         * @summary Update an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {ItemsQuestionnaire} [itemsQuestionnaire] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSingleItemsQuestionnaire(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, itemsQuestionnaire?: ItemsQuestionnaire, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReadSingleItemsQuestionnaire200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSingleItemsQuestionnaire(id, fields, meta, itemsQuestionnaire, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ItemsQuestionnaireApi - factory interface
 * @export
 */
export const ItemsQuestionnaireApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ItemsQuestionnaireApiFp(configuration)
    return {
        /**
         * Create a new Questionnaire item.
         * @summary Create an Item
         * @param {string} [meta] What metadata to return in the response.
         * @param {CreateItemsQuestionnaireRequest} [createItemsQuestionnaireRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createItemsQuestionnaire(meta?: string, createItemsQuestionnaireRequest?: CreateItemsQuestionnaireRequest, options?: any): AxiosPromise<CreateItemsQuestionnaire200Response> {
            return localVarFp.createItemsQuestionnaire(meta, createItemsQuestionnaireRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an existing Questionnaire item.
         * @summary Delete an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSingleItemsQuestionnaire(id: ReadSingleItemsAnswerOptionIdParameter, options?: any): AxiosPromise<void> {
            return localVarFp.deleteSingleItemsQuestionnaire(id, options).then((request) => request(axios, basePath));
        },
        /**
         * List the Questionnaire items.
         * @summary List Items
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {Array<string>} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readItemsQuestionnaire(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, options?: any): AxiosPromise<ReadItemsQuestionnaire200Response> {
            return localVarFp.readItemsQuestionnaire(fields, limit, meta, offset, sort, filter, search, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a single Questionnaire item by unique identifier.
         * @summary Retrieve an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readSingleItemsQuestionnaire(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, options?: any): AxiosPromise<ReadSingleItemsQuestionnaire200Response> {
            return localVarFp.readSingleItemsQuestionnaire(id, fields, meta, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an existing Questionnaire item.
         * @summary Update an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {ItemsQuestionnaire} [itemsQuestionnaire] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSingleItemsQuestionnaire(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, itemsQuestionnaire?: ItemsQuestionnaire, options?: any): AxiosPromise<ReadSingleItemsQuestionnaire200Response> {
            return localVarFp.updateSingleItemsQuestionnaire(id, fields, meta, itemsQuestionnaire, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ItemsQuestionnaireApi - object-oriented interface
 * @export
 * @class ItemsQuestionnaireApi
 * @extends {BaseAPI}
 */
export class ItemsQuestionnaireApi extends BaseAPI {
    /**
     * Create a new Questionnaire item.
     * @summary Create an Item
     * @param {string} [meta] What metadata to return in the response.
     * @param {CreateItemsQuestionnaireRequest} [createItemsQuestionnaireRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsQuestionnaireApi
     */
    public createItemsQuestionnaire(meta?: string, createItemsQuestionnaireRequest?: CreateItemsQuestionnaireRequest, options?: AxiosRequestConfig) {
        return ItemsQuestionnaireApiFp(this.configuration).createItemsQuestionnaire(meta, createItemsQuestionnaireRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an existing Questionnaire item.
     * @summary Delete an Item
     * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsQuestionnaireApi
     */
    public deleteSingleItemsQuestionnaire(id: ReadSingleItemsAnswerOptionIdParameter, options?: AxiosRequestConfig) {
        return ItemsQuestionnaireApiFp(this.configuration).deleteSingleItemsQuestionnaire(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List the Questionnaire items.
     * @summary List Items
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {number} [limit] A limit on the number of objects that are returned.
     * @param {string} [meta] What metadata to return in the response.
     * @param {number} [offset] How many items to skip when fetching data.
     * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
     * @param {Array<string>} [filter] Select items in collection by given conditions.
     * @param {string} [search] Filter by items that contain the given search query in one of their fields.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsQuestionnaireApi
     */
    public readItemsQuestionnaire(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, options?: AxiosRequestConfig) {
        return ItemsQuestionnaireApiFp(this.configuration).readItemsQuestionnaire(fields, limit, meta, offset, sort, filter, search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a single Questionnaire item by unique identifier.
     * @summary Retrieve an Item
     * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsQuestionnaireApi
     */
    public readSingleItemsQuestionnaire(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, options?: AxiosRequestConfig) {
        return ItemsQuestionnaireApiFp(this.configuration).readSingleItemsQuestionnaire(id, fields, meta, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an existing Questionnaire item.
     * @summary Update an Item
     * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {ItemsQuestionnaire} [itemsQuestionnaire] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsQuestionnaireApi
     */
    public updateSingleItemsQuestionnaire(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, itemsQuestionnaire?: ItemsQuestionnaire, options?: AxiosRequestConfig) {
        return ItemsQuestionnaireApiFp(this.configuration).updateSingleItemsQuestionnaire(id, fields, meta, itemsQuestionnaire, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ItemsQuestionnaireTranslationApi - axios parameter creator
 * @export
 */
export const ItemsQuestionnaireTranslationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new QuestionnaireTranslation item.
         * @summary Create an Item
         * @param {string} [meta] What metadata to return in the response.
         * @param {CreateItemsQuestionnaireTranslationRequest} [createItemsQuestionnaireTranslationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createItemsQuestionnaireTranslation: async (meta?: string, createItemsQuestionnaireTranslationRequest?: CreateItemsQuestionnaireTranslationRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/items/QuestionnaireTranslation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createItemsQuestionnaireTranslationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an existing QuestionnaireTranslation item.
         * @summary Delete an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSingleItemsQuestionnaireTranslation: async (id: ReadSingleItemsAnswerOptionIdParameter, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteSingleItemsQuestionnaireTranslation', 'id', id)
            const localVarPath = `/items/QuestionnaireTranslation/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List the QuestionnaireTranslation items.
         * @summary List Items
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {Array<string>} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readItemsQuestionnaireTranslation: async (fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/items/QuestionnaireTranslation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sort) {
                localVarQueryParameter['sort'] = sort.join(COLLECTION_FORMATS.csv);
            }

            if (filter) {
                localVarQueryParameter['filter'] = filter;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a single QuestionnaireTranslation item by unique identifier.
         * @summary Retrieve an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readSingleItemsQuestionnaireTranslation: async (id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('readSingleItemsQuestionnaireTranslation', 'id', id)
            const localVarPath = `/items/QuestionnaireTranslation/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an existing QuestionnaireTranslation item.
         * @summary Update an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {ItemsQuestionnaireTranslation} [itemsQuestionnaireTranslation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSingleItemsQuestionnaireTranslation: async (id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, itemsQuestionnaireTranslation?: ItemsQuestionnaireTranslation, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateSingleItemsQuestionnaireTranslation', 'id', id)
            const localVarPath = `/items/QuestionnaireTranslation/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(itemsQuestionnaireTranslation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ItemsQuestionnaireTranslationApi - functional programming interface
 * @export
 */
export const ItemsQuestionnaireTranslationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ItemsQuestionnaireTranslationApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new QuestionnaireTranslation item.
         * @summary Create an Item
         * @param {string} [meta] What metadata to return in the response.
         * @param {CreateItemsQuestionnaireTranslationRequest} [createItemsQuestionnaireTranslationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createItemsQuestionnaireTranslation(meta?: string, createItemsQuestionnaireTranslationRequest?: CreateItemsQuestionnaireTranslationRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateItemsQuestionnaireTranslation200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createItemsQuestionnaireTranslation(meta, createItemsQuestionnaireTranslationRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete an existing QuestionnaireTranslation item.
         * @summary Delete an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSingleItemsQuestionnaireTranslation(id: ReadSingleItemsAnswerOptionIdParameter, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSingleItemsQuestionnaireTranslation(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List the QuestionnaireTranslation items.
         * @summary List Items
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {Array<string>} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readItemsQuestionnaireTranslation(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReadItemsQuestionnaireTranslation200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readItemsQuestionnaireTranslation(fields, limit, meta, offset, sort, filter, search, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve a single QuestionnaireTranslation item by unique identifier.
         * @summary Retrieve an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readSingleItemsQuestionnaireTranslation(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReadSingleItemsQuestionnaireTranslation200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readSingleItemsQuestionnaireTranslation(id, fields, meta, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update an existing QuestionnaireTranslation item.
         * @summary Update an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {ItemsQuestionnaireTranslation} [itemsQuestionnaireTranslation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSingleItemsQuestionnaireTranslation(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, itemsQuestionnaireTranslation?: ItemsQuestionnaireTranslation, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReadSingleItemsQuestionnaireTranslation200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSingleItemsQuestionnaireTranslation(id, fields, meta, itemsQuestionnaireTranslation, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ItemsQuestionnaireTranslationApi - factory interface
 * @export
 */
export const ItemsQuestionnaireTranslationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ItemsQuestionnaireTranslationApiFp(configuration)
    return {
        /**
         * Create a new QuestionnaireTranslation item.
         * @summary Create an Item
         * @param {string} [meta] What metadata to return in the response.
         * @param {CreateItemsQuestionnaireTranslationRequest} [createItemsQuestionnaireTranslationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createItemsQuestionnaireTranslation(meta?: string, createItemsQuestionnaireTranslationRequest?: CreateItemsQuestionnaireTranslationRequest, options?: any): AxiosPromise<CreateItemsQuestionnaireTranslation200Response> {
            return localVarFp.createItemsQuestionnaireTranslation(meta, createItemsQuestionnaireTranslationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an existing QuestionnaireTranslation item.
         * @summary Delete an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSingleItemsQuestionnaireTranslation(id: ReadSingleItemsAnswerOptionIdParameter, options?: any): AxiosPromise<void> {
            return localVarFp.deleteSingleItemsQuestionnaireTranslation(id, options).then((request) => request(axios, basePath));
        },
        /**
         * List the QuestionnaireTranslation items.
         * @summary List Items
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {Array<string>} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readItemsQuestionnaireTranslation(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, options?: any): AxiosPromise<ReadItemsQuestionnaireTranslation200Response> {
            return localVarFp.readItemsQuestionnaireTranslation(fields, limit, meta, offset, sort, filter, search, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a single QuestionnaireTranslation item by unique identifier.
         * @summary Retrieve an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readSingleItemsQuestionnaireTranslation(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, options?: any): AxiosPromise<ReadSingleItemsQuestionnaireTranslation200Response> {
            return localVarFp.readSingleItemsQuestionnaireTranslation(id, fields, meta, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an existing QuestionnaireTranslation item.
         * @summary Update an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {ItemsQuestionnaireTranslation} [itemsQuestionnaireTranslation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSingleItemsQuestionnaireTranslation(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, itemsQuestionnaireTranslation?: ItemsQuestionnaireTranslation, options?: any): AxiosPromise<ReadSingleItemsQuestionnaireTranslation200Response> {
            return localVarFp.updateSingleItemsQuestionnaireTranslation(id, fields, meta, itemsQuestionnaireTranslation, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ItemsQuestionnaireTranslationApi - object-oriented interface
 * @export
 * @class ItemsQuestionnaireTranslationApi
 * @extends {BaseAPI}
 */
export class ItemsQuestionnaireTranslationApi extends BaseAPI {
    /**
     * Create a new QuestionnaireTranslation item.
     * @summary Create an Item
     * @param {string} [meta] What metadata to return in the response.
     * @param {CreateItemsQuestionnaireTranslationRequest} [createItemsQuestionnaireTranslationRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsQuestionnaireTranslationApi
     */
    public createItemsQuestionnaireTranslation(meta?: string, createItemsQuestionnaireTranslationRequest?: CreateItemsQuestionnaireTranslationRequest, options?: AxiosRequestConfig) {
        return ItemsQuestionnaireTranslationApiFp(this.configuration).createItemsQuestionnaireTranslation(meta, createItemsQuestionnaireTranslationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an existing QuestionnaireTranslation item.
     * @summary Delete an Item
     * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsQuestionnaireTranslationApi
     */
    public deleteSingleItemsQuestionnaireTranslation(id: ReadSingleItemsAnswerOptionIdParameter, options?: AxiosRequestConfig) {
        return ItemsQuestionnaireTranslationApiFp(this.configuration).deleteSingleItemsQuestionnaireTranslation(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List the QuestionnaireTranslation items.
     * @summary List Items
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {number} [limit] A limit on the number of objects that are returned.
     * @param {string} [meta] What metadata to return in the response.
     * @param {number} [offset] How many items to skip when fetching data.
     * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
     * @param {Array<string>} [filter] Select items in collection by given conditions.
     * @param {string} [search] Filter by items that contain the given search query in one of their fields.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsQuestionnaireTranslationApi
     */
    public readItemsQuestionnaireTranslation(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, options?: AxiosRequestConfig) {
        return ItemsQuestionnaireTranslationApiFp(this.configuration).readItemsQuestionnaireTranslation(fields, limit, meta, offset, sort, filter, search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a single QuestionnaireTranslation item by unique identifier.
     * @summary Retrieve an Item
     * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsQuestionnaireTranslationApi
     */
    public readSingleItemsQuestionnaireTranslation(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, options?: AxiosRequestConfig) {
        return ItemsQuestionnaireTranslationApiFp(this.configuration).readSingleItemsQuestionnaireTranslation(id, fields, meta, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an existing QuestionnaireTranslation item.
     * @summary Update an Item
     * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {ItemsQuestionnaireTranslation} [itemsQuestionnaireTranslation] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsQuestionnaireTranslationApi
     */
    public updateSingleItemsQuestionnaireTranslation(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, itemsQuestionnaireTranslation?: ItemsQuestionnaireTranslation, options?: AxiosRequestConfig) {
        return ItemsQuestionnaireTranslationApiFp(this.configuration).updateSingleItemsQuestionnaireTranslation(id, fields, meta, itemsQuestionnaireTranslation, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ItemsQuestiontypeApi - axios parameter creator
 * @export
 */
export const ItemsQuestiontypeApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * List the QuestionType items.
         * @summary List Items
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {Array<string>} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readItemsQuestiontype: async (fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/items/QuestionType`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sort) {
                localVarQueryParameter['sort'] = sort.join(COLLECTION_FORMATS.csv);
            }

            if (filter) {
                localVarQueryParameter['filter'] = filter;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a single QuestionType item by unique identifier.
         * @summary Retrieve an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readSingleItemsQuestiontype: async (id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('readSingleItemsQuestiontype', 'id', id)
            const localVarPath = `/items/QuestionType/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ItemsQuestiontypeApi - functional programming interface
 * @export
 */
export const ItemsQuestiontypeApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ItemsQuestiontypeApiAxiosParamCreator(configuration)
    return {
        /**
         * List the QuestionType items.
         * @summary List Items
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {Array<string>} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readItemsQuestiontype(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReadItemsQuestiontype200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readItemsQuestiontype(fields, limit, meta, offset, sort, filter, search, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve a single QuestionType item by unique identifier.
         * @summary Retrieve an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readSingleItemsQuestiontype(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReadSingleItemsQuestiontype200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readSingleItemsQuestiontype(id, fields, meta, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ItemsQuestiontypeApi - factory interface
 * @export
 */
export const ItemsQuestiontypeApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ItemsQuestiontypeApiFp(configuration)
    return {
        /**
         * List the QuestionType items.
         * @summary List Items
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {Array<string>} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readItemsQuestiontype(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, options?: any): AxiosPromise<ReadItemsQuestiontype200Response> {
            return localVarFp.readItemsQuestiontype(fields, limit, meta, offset, sort, filter, search, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a single QuestionType item by unique identifier.
         * @summary Retrieve an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readSingleItemsQuestiontype(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, options?: any): AxiosPromise<ReadSingleItemsQuestiontype200Response> {
            return localVarFp.readSingleItemsQuestiontype(id, fields, meta, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ItemsQuestiontypeApi - object-oriented interface
 * @export
 * @class ItemsQuestiontypeApi
 * @extends {BaseAPI}
 */
export class ItemsQuestiontypeApi extends BaseAPI {
    /**
     * List the QuestionType items.
     * @summary List Items
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {number} [limit] A limit on the number of objects that are returned.
     * @param {string} [meta] What metadata to return in the response.
     * @param {number} [offset] How many items to skip when fetching data.
     * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
     * @param {Array<string>} [filter] Select items in collection by given conditions.
     * @param {string} [search] Filter by items that contain the given search query in one of their fields.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsQuestiontypeApi
     */
    public readItemsQuestiontype(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, options?: AxiosRequestConfig) {
        return ItemsQuestiontypeApiFp(this.configuration).readItemsQuestiontype(fields, limit, meta, offset, sort, filter, search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a single QuestionType item by unique identifier.
     * @summary Retrieve an Item
     * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsQuestiontypeApi
     */
    public readSingleItemsQuestiontype(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, options?: AxiosRequestConfig) {
        return ItemsQuestiontypeApiFp(this.configuration).readSingleItemsQuestiontype(id, fields, meta, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ItemsSectionApi - axios parameter creator
 * @export
 */
export const ItemsSectionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new Section item.
         * @summary Create an Item
         * @param {string} [meta] What metadata to return in the response.
         * @param {CreateItemsSectionRequest} [createItemsSectionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createItemsSection: async (meta?: string, createItemsSectionRequest?: CreateItemsSectionRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/items/Section`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createItemsSectionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an existing Section item.
         * @summary Delete an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSingleItemsSection: async (id: ReadSingleItemsAnswerOptionIdParameter, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteSingleItemsSection', 'id', id)
            const localVarPath = `/items/Section/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List the Section items.
         * @summary List Items
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {Array<string>} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readItemsSection: async (fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/items/Section`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sort) {
                localVarQueryParameter['sort'] = sort.join(COLLECTION_FORMATS.csv);
            }

            if (filter) {
                localVarQueryParameter['filter'] = filter;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a single Section item by unique identifier.
         * @summary Retrieve an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readSingleItemsSection: async (id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('readSingleItemsSection', 'id', id)
            const localVarPath = `/items/Section/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an existing Section item.
         * @summary Update an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {ItemsSection} [itemsSection] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSingleItemsSection: async (id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, itemsSection?: ItemsSection, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateSingleItemsSection', 'id', id)
            const localVarPath = `/items/Section/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(itemsSection, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ItemsSectionApi - functional programming interface
 * @export
 */
export const ItemsSectionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ItemsSectionApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new Section item.
         * @summary Create an Item
         * @param {string} [meta] What metadata to return in the response.
         * @param {CreateItemsSectionRequest} [createItemsSectionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createItemsSection(meta?: string, createItemsSectionRequest?: CreateItemsSectionRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateItemsSection200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createItemsSection(meta, createItemsSectionRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete an existing Section item.
         * @summary Delete an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSingleItemsSection(id: ReadSingleItemsAnswerOptionIdParameter, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSingleItemsSection(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List the Section items.
         * @summary List Items
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {Array<string>} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readItemsSection(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReadItemsSection200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readItemsSection(fields, limit, meta, offset, sort, filter, search, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve a single Section item by unique identifier.
         * @summary Retrieve an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readSingleItemsSection(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReadSingleItemsSection200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readSingleItemsSection(id, fields, meta, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update an existing Section item.
         * @summary Update an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {ItemsSection} [itemsSection] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSingleItemsSection(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, itemsSection?: ItemsSection, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReadSingleItemsSection200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSingleItemsSection(id, fields, meta, itemsSection, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ItemsSectionApi - factory interface
 * @export
 */
export const ItemsSectionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ItemsSectionApiFp(configuration)
    return {
        /**
         * Create a new Section item.
         * @summary Create an Item
         * @param {string} [meta] What metadata to return in the response.
         * @param {CreateItemsSectionRequest} [createItemsSectionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createItemsSection(meta?: string, createItemsSectionRequest?: CreateItemsSectionRequest, options?: any): AxiosPromise<CreateItemsSection200Response> {
            return localVarFp.createItemsSection(meta, createItemsSectionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an existing Section item.
         * @summary Delete an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSingleItemsSection(id: ReadSingleItemsAnswerOptionIdParameter, options?: any): AxiosPromise<void> {
            return localVarFp.deleteSingleItemsSection(id, options).then((request) => request(axios, basePath));
        },
        /**
         * List the Section items.
         * @summary List Items
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {Array<string>} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readItemsSection(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, options?: any): AxiosPromise<ReadItemsSection200Response> {
            return localVarFp.readItemsSection(fields, limit, meta, offset, sort, filter, search, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a single Section item by unique identifier.
         * @summary Retrieve an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readSingleItemsSection(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, options?: any): AxiosPromise<ReadSingleItemsSection200Response> {
            return localVarFp.readSingleItemsSection(id, fields, meta, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an existing Section item.
         * @summary Update an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {ItemsSection} [itemsSection] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSingleItemsSection(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, itemsSection?: ItemsSection, options?: any): AxiosPromise<ReadSingleItemsSection200Response> {
            return localVarFp.updateSingleItemsSection(id, fields, meta, itemsSection, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ItemsSectionApi - object-oriented interface
 * @export
 * @class ItemsSectionApi
 * @extends {BaseAPI}
 */
export class ItemsSectionApi extends BaseAPI {
    /**
     * Create a new Section item.
     * @summary Create an Item
     * @param {string} [meta] What metadata to return in the response.
     * @param {CreateItemsSectionRequest} [createItemsSectionRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsSectionApi
     */
    public createItemsSection(meta?: string, createItemsSectionRequest?: CreateItemsSectionRequest, options?: AxiosRequestConfig) {
        return ItemsSectionApiFp(this.configuration).createItemsSection(meta, createItemsSectionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an existing Section item.
     * @summary Delete an Item
     * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsSectionApi
     */
    public deleteSingleItemsSection(id: ReadSingleItemsAnswerOptionIdParameter, options?: AxiosRequestConfig) {
        return ItemsSectionApiFp(this.configuration).deleteSingleItemsSection(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List the Section items.
     * @summary List Items
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {number} [limit] A limit on the number of objects that are returned.
     * @param {string} [meta] What metadata to return in the response.
     * @param {number} [offset] How many items to skip when fetching data.
     * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
     * @param {Array<string>} [filter] Select items in collection by given conditions.
     * @param {string} [search] Filter by items that contain the given search query in one of their fields.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsSectionApi
     */
    public readItemsSection(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, options?: AxiosRequestConfig) {
        return ItemsSectionApiFp(this.configuration).readItemsSection(fields, limit, meta, offset, sort, filter, search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a single Section item by unique identifier.
     * @summary Retrieve an Item
     * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsSectionApi
     */
    public readSingleItemsSection(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, options?: AxiosRequestConfig) {
        return ItemsSectionApiFp(this.configuration).readSingleItemsSection(id, fields, meta, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an existing Section item.
     * @summary Update an Item
     * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {ItemsSection} [itemsSection] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsSectionApi
     */
    public updateSingleItemsSection(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, itemsSection?: ItemsSection, options?: AxiosRequestConfig) {
        return ItemsSectionApiFp(this.configuration).updateSingleItemsSection(id, fields, meta, itemsSection, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ItemsSectionTranslationApi - axios parameter creator
 * @export
 */
export const ItemsSectionTranslationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new SectionTranslation item.
         * @summary Create an Item
         * @param {string} [meta] What metadata to return in the response.
         * @param {CreateItemsSectionTranslationRequest} [createItemsSectionTranslationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createItemsSectionTranslation: async (meta?: string, createItemsSectionTranslationRequest?: CreateItemsSectionTranslationRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/items/SectionTranslation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createItemsSectionTranslationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an existing SectionTranslation item.
         * @summary Delete an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSingleItemsSectionTranslation: async (id: ReadSingleItemsAnswerOptionIdParameter, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteSingleItemsSectionTranslation', 'id', id)
            const localVarPath = `/items/SectionTranslation/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List the SectionTranslation items.
         * @summary List Items
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {Array<string>} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readItemsSectionTranslation: async (fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/items/SectionTranslation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sort) {
                localVarQueryParameter['sort'] = sort.join(COLLECTION_FORMATS.csv);
            }

            if (filter) {
                localVarQueryParameter['filter'] = filter;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a single SectionTranslation item by unique identifier.
         * @summary Retrieve an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readSingleItemsSectionTranslation: async (id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('readSingleItemsSectionTranslation', 'id', id)
            const localVarPath = `/items/SectionTranslation/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an existing SectionTranslation item.
         * @summary Update an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {ItemsSectionTranslation} [itemsSectionTranslation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSingleItemsSectionTranslation: async (id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, itemsSectionTranslation?: ItemsSectionTranslation, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateSingleItemsSectionTranslation', 'id', id)
            const localVarPath = `/items/SectionTranslation/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(itemsSectionTranslation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ItemsSectionTranslationApi - functional programming interface
 * @export
 */
export const ItemsSectionTranslationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ItemsSectionTranslationApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new SectionTranslation item.
         * @summary Create an Item
         * @param {string} [meta] What metadata to return in the response.
         * @param {CreateItemsSectionTranslationRequest} [createItemsSectionTranslationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createItemsSectionTranslation(meta?: string, createItemsSectionTranslationRequest?: CreateItemsSectionTranslationRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateItemsSectionTranslation200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createItemsSectionTranslation(meta, createItemsSectionTranslationRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete an existing SectionTranslation item.
         * @summary Delete an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSingleItemsSectionTranslation(id: ReadSingleItemsAnswerOptionIdParameter, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSingleItemsSectionTranslation(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List the SectionTranslation items.
         * @summary List Items
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {Array<string>} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readItemsSectionTranslation(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReadItemsSectionTranslation200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readItemsSectionTranslation(fields, limit, meta, offset, sort, filter, search, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve a single SectionTranslation item by unique identifier.
         * @summary Retrieve an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readSingleItemsSectionTranslation(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReadSingleItemsSectionTranslation200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readSingleItemsSectionTranslation(id, fields, meta, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update an existing SectionTranslation item.
         * @summary Update an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {ItemsSectionTranslation} [itemsSectionTranslation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSingleItemsSectionTranslation(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, itemsSectionTranslation?: ItemsSectionTranslation, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReadSingleItemsSectionTranslation200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSingleItemsSectionTranslation(id, fields, meta, itemsSectionTranslation, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ItemsSectionTranslationApi - factory interface
 * @export
 */
export const ItemsSectionTranslationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ItemsSectionTranslationApiFp(configuration)
    return {
        /**
         * Create a new SectionTranslation item.
         * @summary Create an Item
         * @param {string} [meta] What metadata to return in the response.
         * @param {CreateItemsSectionTranslationRequest} [createItemsSectionTranslationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createItemsSectionTranslation(meta?: string, createItemsSectionTranslationRequest?: CreateItemsSectionTranslationRequest, options?: any): AxiosPromise<CreateItemsSectionTranslation200Response> {
            return localVarFp.createItemsSectionTranslation(meta, createItemsSectionTranslationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an existing SectionTranslation item.
         * @summary Delete an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSingleItemsSectionTranslation(id: ReadSingleItemsAnswerOptionIdParameter, options?: any): AxiosPromise<void> {
            return localVarFp.deleteSingleItemsSectionTranslation(id, options).then((request) => request(axios, basePath));
        },
        /**
         * List the SectionTranslation items.
         * @summary List Items
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {Array<string>} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readItemsSectionTranslation(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, options?: any): AxiosPromise<ReadItemsSectionTranslation200Response> {
            return localVarFp.readItemsSectionTranslation(fields, limit, meta, offset, sort, filter, search, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a single SectionTranslation item by unique identifier.
         * @summary Retrieve an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readSingleItemsSectionTranslation(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, options?: any): AxiosPromise<ReadSingleItemsSectionTranslation200Response> {
            return localVarFp.readSingleItemsSectionTranslation(id, fields, meta, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an existing SectionTranslation item.
         * @summary Update an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {ItemsSectionTranslation} [itemsSectionTranslation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSingleItemsSectionTranslation(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, itemsSectionTranslation?: ItemsSectionTranslation, options?: any): AxiosPromise<ReadSingleItemsSectionTranslation200Response> {
            return localVarFp.updateSingleItemsSectionTranslation(id, fields, meta, itemsSectionTranslation, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ItemsSectionTranslationApi - object-oriented interface
 * @export
 * @class ItemsSectionTranslationApi
 * @extends {BaseAPI}
 */
export class ItemsSectionTranslationApi extends BaseAPI {
    /**
     * Create a new SectionTranslation item.
     * @summary Create an Item
     * @param {string} [meta] What metadata to return in the response.
     * @param {CreateItemsSectionTranslationRequest} [createItemsSectionTranslationRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsSectionTranslationApi
     */
    public createItemsSectionTranslation(meta?: string, createItemsSectionTranslationRequest?: CreateItemsSectionTranslationRequest, options?: AxiosRequestConfig) {
        return ItemsSectionTranslationApiFp(this.configuration).createItemsSectionTranslation(meta, createItemsSectionTranslationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an existing SectionTranslation item.
     * @summary Delete an Item
     * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsSectionTranslationApi
     */
    public deleteSingleItemsSectionTranslation(id: ReadSingleItemsAnswerOptionIdParameter, options?: AxiosRequestConfig) {
        return ItemsSectionTranslationApiFp(this.configuration).deleteSingleItemsSectionTranslation(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List the SectionTranslation items.
     * @summary List Items
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {number} [limit] A limit on the number of objects that are returned.
     * @param {string} [meta] What metadata to return in the response.
     * @param {number} [offset] How many items to skip when fetching data.
     * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
     * @param {Array<string>} [filter] Select items in collection by given conditions.
     * @param {string} [search] Filter by items that contain the given search query in one of their fields.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsSectionTranslationApi
     */
    public readItemsSectionTranslation(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, options?: AxiosRequestConfig) {
        return ItemsSectionTranslationApiFp(this.configuration).readItemsSectionTranslation(fields, limit, meta, offset, sort, filter, search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a single SectionTranslation item by unique identifier.
     * @summary Retrieve an Item
     * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsSectionTranslationApi
     */
    public readSingleItemsSectionTranslation(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, options?: AxiosRequestConfig) {
        return ItemsSectionTranslationApiFp(this.configuration).readSingleItemsSectionTranslation(id, fields, meta, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an existing SectionTranslation item.
     * @summary Update an Item
     * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {ItemsSectionTranslation} [itemsSectionTranslation] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsSectionTranslationApi
     */
    public updateSingleItemsSectionTranslation(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, itemsSectionTranslation?: ItemsSectionTranslation, options?: AxiosRequestConfig) {
        return ItemsSectionTranslationApiFp(this.configuration).updateSingleItemsSectionTranslation(id, fields, meta, itemsSectionTranslation, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ItemsVersionApi - axios parameter creator
 * @export
 */
export const ItemsVersionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new Version item.
         * @summary Create an Item
         * @param {string} [meta] What metadata to return in the response.
         * @param {CreateItemsVersionRequest} [createItemsVersionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createItemsVersion: async (meta?: string, createItemsVersionRequest?: CreateItemsVersionRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/items/Version`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createItemsVersionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an existing Version item.
         * @summary Delete an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSingleItemsVersion: async (id: ReadSingleItemsAnswerOptionIdParameter, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteSingleItemsVersion', 'id', id)
            const localVarPath = `/items/Version/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List the Version items.
         * @summary List Items
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {Array<string>} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readItemsVersion: async (fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/items/Version`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sort) {
                localVarQueryParameter['sort'] = sort.join(COLLECTION_FORMATS.csv);
            }

            if (filter) {
                localVarQueryParameter['filter'] = filter;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a single Version item by unique identifier.
         * @summary Retrieve an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readSingleItemsVersion: async (id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('readSingleItemsVersion', 'id', id)
            const localVarPath = `/items/Version/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ItemsVersionApi - functional programming interface
 * @export
 */
export const ItemsVersionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ItemsVersionApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new Version item.
         * @summary Create an Item
         * @param {string} [meta] What metadata to return in the response.
         * @param {CreateItemsVersionRequest} [createItemsVersionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createItemsVersion(meta?: string, createItemsVersionRequest?: CreateItemsVersionRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateItemsVersion200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createItemsVersion(meta, createItemsVersionRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete an existing Version item.
         * @summary Delete an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSingleItemsVersion(id: ReadSingleItemsAnswerOptionIdParameter, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSingleItemsVersion(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List the Version items.
         * @summary List Items
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {Array<string>} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readItemsVersion(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReadItemsVersion200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readItemsVersion(fields, limit, meta, offset, sort, filter, search, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve a single Version item by unique identifier.
         * @summary Retrieve an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readSingleItemsVersion(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReadSingleItemsVersion200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readSingleItemsVersion(id, fields, meta, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ItemsVersionApi - factory interface
 * @export
 */
export const ItemsVersionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ItemsVersionApiFp(configuration)
    return {
        /**
         * Create a new Version item.
         * @summary Create an Item
         * @param {string} [meta] What metadata to return in the response.
         * @param {CreateItemsVersionRequest} [createItemsVersionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createItemsVersion(meta?: string, createItemsVersionRequest?: CreateItemsVersionRequest, options?: any): AxiosPromise<CreateItemsVersion200Response> {
            return localVarFp.createItemsVersion(meta, createItemsVersionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an existing Version item.
         * @summary Delete an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSingleItemsVersion(id: ReadSingleItemsAnswerOptionIdParameter, options?: any): AxiosPromise<void> {
            return localVarFp.deleteSingleItemsVersion(id, options).then((request) => request(axios, basePath));
        },
        /**
         * List the Version items.
         * @summary List Items
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {Array<string>} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readItemsVersion(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, options?: any): AxiosPromise<ReadItemsVersion200Response> {
            return localVarFp.readItemsVersion(fields, limit, meta, offset, sort, filter, search, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a single Version item by unique identifier.
         * @summary Retrieve an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readSingleItemsVersion(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, options?: any): AxiosPromise<ReadSingleItemsVersion200Response> {
            return localVarFp.readSingleItemsVersion(id, fields, meta, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ItemsVersionApi - object-oriented interface
 * @export
 * @class ItemsVersionApi
 * @extends {BaseAPI}
 */
export class ItemsVersionApi extends BaseAPI {
    /**
     * Create a new Version item.
     * @summary Create an Item
     * @param {string} [meta] What metadata to return in the response.
     * @param {CreateItemsVersionRequest} [createItemsVersionRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsVersionApi
     */
    public createItemsVersion(meta?: string, createItemsVersionRequest?: CreateItemsVersionRequest, options?: AxiosRequestConfig) {
        return ItemsVersionApiFp(this.configuration).createItemsVersion(meta, createItemsVersionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an existing Version item.
     * @summary Delete an Item
     * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsVersionApi
     */
    public deleteSingleItemsVersion(id: ReadSingleItemsAnswerOptionIdParameter, options?: AxiosRequestConfig) {
        return ItemsVersionApiFp(this.configuration).deleteSingleItemsVersion(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List the Version items.
     * @summary List Items
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {number} [limit] A limit on the number of objects that are returned.
     * @param {string} [meta] What metadata to return in the response.
     * @param {number} [offset] How many items to skip when fetching data.
     * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
     * @param {Array<string>} [filter] Select items in collection by given conditions.
     * @param {string} [search] Filter by items that contain the given search query in one of their fields.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsVersionApi
     */
    public readItemsVersion(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, options?: AxiosRequestConfig) {
        return ItemsVersionApiFp(this.configuration).readItemsVersion(fields, limit, meta, offset, sort, filter, search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a single Version item by unique identifier.
     * @summary Retrieve an Item
     * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsVersionApi
     */
    public readSingleItemsVersion(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, options?: AxiosRequestConfig) {
        return ItemsVersionApiFp(this.configuration).readSingleItemsVersion(id, fields, meta, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ItemsVersionContentTypeApi - axios parameter creator
 * @export
 */
export const ItemsVersionContentTypeApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * List the VersionContentType items.
         * @summary List Items
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {Array<string>} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readItemsVersionContentType: async (fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/items/VersionContentType`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sort) {
                localVarQueryParameter['sort'] = sort.join(COLLECTION_FORMATS.csv);
            }

            if (filter) {
                localVarQueryParameter['filter'] = filter;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a single VersionContentType item by unique identifier.
         * @summary Retrieve an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readSingleItemsVersionContentType: async (id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('readSingleItemsVersionContentType', 'id', id)
            const localVarPath = `/items/VersionContentType/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ItemsVersionContentTypeApi - functional programming interface
 * @export
 */
export const ItemsVersionContentTypeApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ItemsVersionContentTypeApiAxiosParamCreator(configuration)
    return {
        /**
         * List the VersionContentType items.
         * @summary List Items
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {Array<string>} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readItemsVersionContentType(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReadItemsVersionContentType200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readItemsVersionContentType(fields, limit, meta, offset, sort, filter, search, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve a single VersionContentType item by unique identifier.
         * @summary Retrieve an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readSingleItemsVersionContentType(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReadSingleItemsVersionContentType200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readSingleItemsVersionContentType(id, fields, meta, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ItemsVersionContentTypeApi - factory interface
 * @export
 */
export const ItemsVersionContentTypeApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ItemsVersionContentTypeApiFp(configuration)
    return {
        /**
         * List the VersionContentType items.
         * @summary List Items
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {string} [meta] What metadata to return in the response.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {Array<string>} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readItemsVersionContentType(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, options?: any): AxiosPromise<ReadItemsVersionContentType200Response> {
            return localVarFp.readItemsVersionContentType(fields, limit, meta, offset, sort, filter, search, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a single VersionContentType item by unique identifier.
         * @summary Retrieve an Item
         * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readSingleItemsVersionContentType(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, options?: any): AxiosPromise<ReadSingleItemsVersionContentType200Response> {
            return localVarFp.readSingleItemsVersionContentType(id, fields, meta, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ItemsVersionContentTypeApi - object-oriented interface
 * @export
 * @class ItemsVersionContentTypeApi
 * @extends {BaseAPI}
 */
export class ItemsVersionContentTypeApi extends BaseAPI {
    /**
     * List the VersionContentType items.
     * @summary List Items
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {number} [limit] A limit on the number of objects that are returned.
     * @param {string} [meta] What metadata to return in the response.
     * @param {number} [offset] How many items to skip when fetching data.
     * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
     * @param {Array<string>} [filter] Select items in collection by given conditions.
     * @param {string} [search] Filter by items that contain the given search query in one of their fields.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsVersionContentTypeApi
     */
    public readItemsVersionContentType(fields?: Array<string>, limit?: number, meta?: string, offset?: number, sort?: Array<string>, filter?: Array<string>, search?: string, options?: AxiosRequestConfig) {
        return ItemsVersionContentTypeApiFp(this.configuration).readItemsVersionContentType(fields, limit, meta, offset, sort, filter, search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a single VersionContentType item by unique identifier.
     * @summary Retrieve an Item
     * @param {ReadSingleItemsAnswerOptionIdParameter} id Index of the item.
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsVersionContentTypeApi
     */
    public readSingleItemsVersionContentType(id: ReadSingleItemsAnswerOptionIdParameter, fields?: Array<string>, meta?: string, options?: AxiosRequestConfig) {
        return ItemsVersionContentTypeApiFp(this.configuration).readSingleItemsVersionContentType(id, fields, meta, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RelationsApi - axios parameter creator
 * @export
 */
export const RelationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve a single relation by unique identifier.
         * @summary Retrieve a Relation
         * @param {number} id Index
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRelation: async (id: number, fields?: Array<string>, meta?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getRelation', 'id', id)
            const localVarPath = `/relations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List the relations.
         * @summary List Relations
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {string} [meta] What metadata to return in the response.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {Array<string>} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {number} [page] Cursor for use in pagination. Often used in combination with limit.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRelations: async (fields?: Array<string>, limit?: number, offset?: number, meta?: string, sort?: Array<string>, filter?: Array<string>, search?: string, page?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/relations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }

            if (sort) {
                localVarQueryParameter['sort'] = sort.join(COLLECTION_FORMATS.csv);
            }

            if (filter) {
                localVarQueryParameter['filter'] = filter;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RelationsApi - functional programming interface
 * @export
 */
export const RelationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RelationsApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve a single relation by unique identifier.
         * @summary Retrieve a Relation
         * @param {number} id Index
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRelation(id: number, fields?: Array<string>, meta?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetRelation200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRelation(id, fields, meta, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List the relations.
         * @summary List Relations
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {string} [meta] What metadata to return in the response.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {Array<string>} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {number} [page] Cursor for use in pagination. Often used in combination with limit.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRelations(fields?: Array<string>, limit?: number, offset?: number, meta?: string, sort?: Array<string>, filter?: Array<string>, search?: string, page?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetRelations200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRelations(fields, limit, offset, meta, sort, filter, search, page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RelationsApi - factory interface
 * @export
 */
export const RelationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RelationsApiFp(configuration)
    return {
        /**
         * Retrieve a single relation by unique identifier.
         * @summary Retrieve a Relation
         * @param {number} id Index
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRelation(id: number, fields?: Array<string>, meta?: string, options?: any): AxiosPromise<GetRelation200Response> {
            return localVarFp.getRelation(id, fields, meta, options).then((request) => request(axios, basePath));
        },
        /**
         * List the relations.
         * @summary List Relations
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {string} [meta] What metadata to return in the response.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {Array<string>} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {number} [page] Cursor for use in pagination. Often used in combination with limit.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRelations(fields?: Array<string>, limit?: number, offset?: number, meta?: string, sort?: Array<string>, filter?: Array<string>, search?: string, page?: number, options?: any): AxiosPromise<GetRelations200Response> {
            return localVarFp.getRelations(fields, limit, offset, meta, sort, filter, search, page, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RelationsApi - object-oriented interface
 * @export
 * @class RelationsApi
 * @extends {BaseAPI}
 */
export class RelationsApi extends BaseAPI {
    /**
     * Retrieve a single relation by unique identifier.
     * @summary Retrieve a Relation
     * @param {number} id Index
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RelationsApi
     */
    public getRelation(id: number, fields?: Array<string>, meta?: string, options?: AxiosRequestConfig) {
        return RelationsApiFp(this.configuration).getRelation(id, fields, meta, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List the relations.
     * @summary List Relations
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {number} [limit] A limit on the number of objects that are returned.
     * @param {number} [offset] How many items to skip when fetching data.
     * @param {string} [meta] What metadata to return in the response.
     * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
     * @param {Array<string>} [filter] Select items in collection by given conditions.
     * @param {string} [search] Filter by items that contain the given search query in one of their fields.
     * @param {number} [page] Cursor for use in pagination. Often used in combination with limit.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RelationsApi
     */
    public getRelations(fields?: Array<string>, limit?: number, offset?: number, meta?: string, sort?: Array<string>, filter?: Array<string>, search?: string, page?: number, options?: AxiosRequestConfig) {
        return RelationsApiFp(this.configuration).getRelations(fields, limit, offset, meta, sort, filter, search, page, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RolesApi - axios parameter creator
 * @export
 */
export const RolesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve a single role by unique identifier.
         * @summary Retrieve a Role
         * @param {string} id Unique identifier for the object.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRole: async (id: string, fields?: Array<string>, meta?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getRole', 'id', id)
            const localVarPath = `/roles/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List the roles.
         * @summary List Roles
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {string} [meta] What metadata to return in the response.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {Array<string>} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {number} [page] Cursor for use in pagination. Often used in combination with limit.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoles: async (fields?: Array<string>, limit?: number, offset?: number, meta?: string, sort?: Array<string>, filter?: Array<string>, search?: string, page?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/roles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }

            if (sort) {
                localVarQueryParameter['sort'] = sort.join(COLLECTION_FORMATS.csv);
            }

            if (filter) {
                localVarQueryParameter['filter'] = filter;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RolesApi - functional programming interface
 * @export
 */
export const RolesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RolesApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve a single role by unique identifier.
         * @summary Retrieve a Role
         * @param {string} id Unique identifier for the object.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRole(id: string, fields?: Array<string>, meta?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetRole200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRole(id, fields, meta, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List the roles.
         * @summary List Roles
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {string} [meta] What metadata to return in the response.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {Array<string>} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {number} [page] Cursor for use in pagination. Often used in combination with limit.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRoles(fields?: Array<string>, limit?: number, offset?: number, meta?: string, sort?: Array<string>, filter?: Array<string>, search?: string, page?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetRoles200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRoles(fields, limit, offset, meta, sort, filter, search, page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RolesApi - factory interface
 * @export
 */
export const RolesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RolesApiFp(configuration)
    return {
        /**
         * Retrieve a single role by unique identifier.
         * @summary Retrieve a Role
         * @param {string} id Unique identifier for the object.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRole(id: string, fields?: Array<string>, meta?: string, options?: any): AxiosPromise<GetRole200Response> {
            return localVarFp.getRole(id, fields, meta, options).then((request) => request(axios, basePath));
        },
        /**
         * List the roles.
         * @summary List Roles
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {string} [meta] What metadata to return in the response.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {Array<string>} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {number} [page] Cursor for use in pagination. Often used in combination with limit.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoles(fields?: Array<string>, limit?: number, offset?: number, meta?: string, sort?: Array<string>, filter?: Array<string>, search?: string, page?: number, options?: any): AxiosPromise<GetRoles200Response> {
            return localVarFp.getRoles(fields, limit, offset, meta, sort, filter, search, page, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RolesApi - object-oriented interface
 * @export
 * @class RolesApi
 * @extends {BaseAPI}
 */
export class RolesApi extends BaseAPI {
    /**
     * Retrieve a single role by unique identifier.
     * @summary Retrieve a Role
     * @param {string} id Unique identifier for the object.
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public getRole(id: string, fields?: Array<string>, meta?: string, options?: AxiosRequestConfig) {
        return RolesApiFp(this.configuration).getRole(id, fields, meta, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List the roles.
     * @summary List Roles
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {number} [limit] A limit on the number of objects that are returned.
     * @param {number} [offset] How many items to skip when fetching data.
     * @param {string} [meta] What metadata to return in the response.
     * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
     * @param {Array<string>} [filter] Select items in collection by given conditions.
     * @param {string} [search] Filter by items that contain the given search query in one of their fields.
     * @param {number} [page] Cursor for use in pagination. Often used in combination with limit.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public getRoles(fields?: Array<string>, limit?: number, offset?: number, meta?: string, sort?: Array<string>, filter?: Array<string>, search?: string, page?: number, options?: AxiosRequestConfig) {
        return RolesApiFp(this.configuration).getRoles(fields, limit, offset, meta, sort, filter, search, page, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ServerApi - axios parameter creator
 * @export
 */
export const ServerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Ping, pong. Ping.. pong.
         * @summary Ping
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ping: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/server/ping`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Perform a system status check and return the options.
         * @summary System Info
         * @param {number} superAdminToken The first time you create a project, the provided token will be saved and required for subsequent project installs. It can also be found and configured in &#x60;/config/__api.json&#x60; on your server.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serverInfo: async (superAdminToken: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'superAdminToken' is not null or undefined
            assertParamExists('serverInfo', 'superAdminToken', superAdminToken)
            const localVarPath = `/server/info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (superAdminToken !== undefined) {
                localVarQueryParameter['super_admin_token'] = superAdminToken;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ServerApi - functional programming interface
 * @export
 */
export const ServerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ServerApiAxiosParamCreator(configuration)
    return {
        /**
         * Ping, pong. Ping.. pong.
         * @summary Ping
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ping(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ping(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Perform a system status check and return the options.
         * @summary System Info
         * @param {number} superAdminToken The first time you create a project, the provided token will be saved and required for subsequent project installs. It can also be found and configured in &#x60;/config/__api.json&#x60; on your server.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async serverInfo(superAdminToken: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServerInfo200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.serverInfo(superAdminToken, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ServerApi - factory interface
 * @export
 */
export const ServerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ServerApiFp(configuration)
    return {
        /**
         * Ping, pong. Ping.. pong.
         * @summary Ping
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ping(options?: any): AxiosPromise<string> {
            return localVarFp.ping(options).then((request) => request(axios, basePath));
        },
        /**
         * Perform a system status check and return the options.
         * @summary System Info
         * @param {number} superAdminToken The first time you create a project, the provided token will be saved and required for subsequent project installs. It can also be found and configured in &#x60;/config/__api.json&#x60; on your server.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serverInfo(superAdminToken: number, options?: any): AxiosPromise<ServerInfo200Response> {
            return localVarFp.serverInfo(superAdminToken, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ServerApi - object-oriented interface
 * @export
 * @class ServerApi
 * @extends {BaseAPI}
 */
export class ServerApi extends BaseAPI {
    /**
     * Ping, pong. Ping.. pong.
     * @summary Ping
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerApi
     */
    public ping(options?: AxiosRequestConfig) {
        return ServerApiFp(this.configuration).ping(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Perform a system status check and return the options.
     * @summary System Info
     * @param {number} superAdminToken The first time you create a project, the provided token will be saved and required for subsequent project installs. It can also be found and configured in &#x60;/config/__api.json&#x60; on your server.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerApi
     */
    public serverInfo(superAdminToken: number, options?: AxiosRequestConfig) {
        return ServerApiFp(this.configuration).serverInfo(superAdminToken, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve the currently authenticated user.
         * @summary Retrieve Current User
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMe: async (fields?: Array<string>, meta?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a single user by unique identifier.
         * @summary Retrieve a User
         * @param {string} id Unique identifier for the object.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser: async (id: string, fields?: Array<string>, meta?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getUser', 'id', id)
            const localVarPath = `/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List the users.
         * @summary List Users
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {string} [meta] What metadata to return in the response.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {Array<string>} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers: async (fields?: Array<string>, limit?: number, offset?: number, meta?: string, sort?: Array<string>, filter?: Array<string>, search?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fields) {
                localVarQueryParameter['fields'] = fields.join(COLLECTION_FORMATS.csv);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }

            if (sort) {
                localVarQueryParameter['sort'] = sort.join(COLLECTION_FORMATS.csv);
            }

            if (filter) {
                localVarQueryParameter['filter'] = filter;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve the currently authenticated user.
         * @summary Retrieve Current User
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMe(fields?: Array<string>, meta?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUser200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMe(fields, meta, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve a single user by unique identifier.
         * @summary Retrieve a User
         * @param {string} id Unique identifier for the object.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUser(id: string, fields?: Array<string>, meta?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUser200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUser(id, fields, meta, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List the users.
         * @summary List Users
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {string} [meta] What metadata to return in the response.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {Array<string>} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsers(fields?: Array<string>, limit?: number, offset?: number, meta?: string, sort?: Array<string>, filter?: Array<string>, search?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUsers200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsers(fields, limit, offset, meta, sort, filter, search, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * Retrieve the currently authenticated user.
         * @summary Retrieve Current User
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMe(fields?: Array<string>, meta?: string, options?: any): AxiosPromise<GetUser200Response> {
            return localVarFp.getMe(fields, meta, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a single user by unique identifier.
         * @summary Retrieve a User
         * @param {string} id Unique identifier for the object.
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {string} [meta] What metadata to return in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(id: string, fields?: Array<string>, meta?: string, options?: any): AxiosPromise<GetUser200Response> {
            return localVarFp.getUser(id, fields, meta, options).then((request) => request(axios, basePath));
        },
        /**
         * List the users.
         * @summary List Users
         * @param {Array<string>} [fields] Control what fields are being returned in the object.
         * @param {number} [limit] A limit on the number of objects that are returned.
         * @param {number} [offset] How many items to skip when fetching data.
         * @param {string} [meta] What metadata to return in the response.
         * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
         * @param {Array<string>} [filter] Select items in collection by given conditions.
         * @param {string} [search] Filter by items that contain the given search query in one of their fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers(fields?: Array<string>, limit?: number, offset?: number, meta?: string, sort?: Array<string>, filter?: Array<string>, search?: string, options?: any): AxiosPromise<GetUsers200Response> {
            return localVarFp.getUsers(fields, limit, offset, meta, sort, filter, search, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * Retrieve the currently authenticated user.
     * @summary Retrieve Current User
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getMe(fields?: Array<string>, meta?: string, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).getMe(fields, meta, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a single user by unique identifier.
     * @summary Retrieve a User
     * @param {string} id Unique identifier for the object.
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {string} [meta] What metadata to return in the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUser(id: string, fields?: Array<string>, meta?: string, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUser(id, fields, meta, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List the users.
     * @summary List Users
     * @param {Array<string>} [fields] Control what fields are being returned in the object.
     * @param {number} [limit] A limit on the number of objects that are returned.
     * @param {number} [offset] How many items to skip when fetching data.
     * @param {string} [meta] What metadata to return in the response.
     * @param {Array<string>} [sort] How to sort the returned items. &#x60;sort&#x60; is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (&#x60; - &#x60;) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a &#x60; ? &#x60; to sort randomly. 
     * @param {Array<string>} [filter] Select items in collection by given conditions.
     * @param {string} [search] Filter by items that contain the given search query in one of their fields.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUsers(fields?: Array<string>, limit?: number, offset?: number, meta?: string, sort?: Array<string>, filter?: Array<string>, search?: string, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUsers(fields, limit, offset, meta, sort, filter, search, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UtilitiesApi - axios parameter creator
 * @export
 */
export const UtilitiesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Export a larger data set to a file in the File Library
         * @summary Export Items
         * @param {string} collection Collection identifier
         * @param {ExportRequest} [exportRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _export: async (collection: string, exportRequest?: ExportRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'collection' is not null or undefined
            assertParamExists('_export', 'collection', collection)
            const localVarPath = `/utils/export/{collection}`
                .replace(`{${"collection"}}`, encodeURIComponent(String(collection)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(exportRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Import multiple records from a JSON or CSV file into a collection.
         * @summary Import Items
         * @param {string} collection Collection identifier
         * @param {any} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _import: async (collection: string, file?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'collection' is not null or undefined
            assertParamExists('_import', 'collection', collection)
            const localVarPath = `/utils/import/{collection}`
                .replace(`{${"collection"}}`, encodeURIComponent(String(collection)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resets both the data and schema cache of Directus.
         * @summary Clear Cache
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clearCache: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/utils/cache/clear`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Generate a hash for a given string.
         * @summary Hash a string
         * @param {HashGenerateRequest} [hashGenerateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hashGenerate: async (hashGenerateRequest?: HashGenerateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/utils/hash/generate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(hashGenerateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Generate a hash for a given string.
         * @summary Hash a string
         * @param {HashVerifyRequest} [hashVerifyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hashVerify: async (hashVerifyRequest?: HashVerifyRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/utils/hash/verify`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(hashVerifyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a random string of given length.
         * @summary Get a Random String
         * @param {number} [length] Length of the random string.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        random: async (length?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/utils/random/string`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (length !== undefined) {
                localVarQueryParameter['length'] = length;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Re-sort items in collection based on start and to value of item
         * @summary Sort Items
         * @param {string} collection Collection identifier
         * @param {SortRequest} [sortRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sort: async (collection: string, sortRequest?: SortRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'collection' is not null or undefined
            assertParamExists('sort', 'collection', collection)
            const localVarPath = `/utils/sort/{collection}`
                .replace(`{${"collection"}}`, encodeURIComponent(String(collection)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Auth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sortRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UtilitiesApi - functional programming interface
 * @export
 */
export const UtilitiesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UtilitiesApiAxiosParamCreator(configuration)
    return {
        /**
         * Export a larger data set to a file in the File Library
         * @summary Export Items
         * @param {string} collection Collection identifier
         * @param {ExportRequest} [exportRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async _export(collection: string, exportRequest?: ExportRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator._export(collection, exportRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Import multiple records from a JSON or CSV file into a collection.
         * @summary Import Items
         * @param {string} collection Collection identifier
         * @param {any} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async _import(collection: string, file?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator._import(collection, file, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Resets both the data and schema cache of Directus.
         * @summary Clear Cache
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clearCache(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clearCache(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Generate a hash for a given string.
         * @summary Hash a string
         * @param {HashGenerateRequest} [hashGenerateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async hashGenerate(hashGenerateRequest?: HashGenerateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HashGenerate200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.hashGenerate(hashGenerateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Generate a hash for a given string.
         * @summary Hash a string
         * @param {HashVerifyRequest} [hashVerifyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async hashVerify(hashVerifyRequest?: HashVerifyRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HashVerify200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.hashVerify(hashVerifyRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a random string of given length.
         * @summary Get a Random String
         * @param {number} [length] Length of the random string.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async random(length?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Random200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.random(length, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Re-sort items in collection based on start and to value of item
         * @summary Sort Items
         * @param {string} collection Collection identifier
         * @param {SortRequest} [sortRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sort(collection: string, sortRequest?: SortRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sort(collection, sortRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UtilitiesApi - factory interface
 * @export
 */
export const UtilitiesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UtilitiesApiFp(configuration)
    return {
        /**
         * Export a larger data set to a file in the File Library
         * @summary Export Items
         * @param {string} collection Collection identifier
         * @param {ExportRequest} [exportRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _export(collection: string, exportRequest?: ExportRequest, options?: any): AxiosPromise<void> {
            return localVarFp._export(collection, exportRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Import multiple records from a JSON or CSV file into a collection.
         * @summary Import Items
         * @param {string} collection Collection identifier
         * @param {any} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _import(collection: string, file?: any, options?: any): AxiosPromise<void> {
            return localVarFp._import(collection, file, options).then((request) => request(axios, basePath));
        },
        /**
         * Resets both the data and schema cache of Directus.
         * @summary Clear Cache
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clearCache(options?: any): AxiosPromise<void> {
            return localVarFp.clearCache(options).then((request) => request(axios, basePath));
        },
        /**
         * Generate a hash for a given string.
         * @summary Hash a string
         * @param {HashGenerateRequest} [hashGenerateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hashGenerate(hashGenerateRequest?: HashGenerateRequest, options?: any): AxiosPromise<HashGenerate200Response> {
            return localVarFp.hashGenerate(hashGenerateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Generate a hash for a given string.
         * @summary Hash a string
         * @param {HashVerifyRequest} [hashVerifyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hashVerify(hashVerifyRequest?: HashVerifyRequest, options?: any): AxiosPromise<HashVerify200Response> {
            return localVarFp.hashVerify(hashVerifyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a random string of given length.
         * @summary Get a Random String
         * @param {number} [length] Length of the random string.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        random(length?: number, options?: any): AxiosPromise<Random200Response> {
            return localVarFp.random(length, options).then((request) => request(axios, basePath));
        },
        /**
         * Re-sort items in collection based on start and to value of item
         * @summary Sort Items
         * @param {string} collection Collection identifier
         * @param {SortRequest} [sortRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sort(collection: string, sortRequest?: SortRequest, options?: any): AxiosPromise<void> {
            return localVarFp.sort(collection, sortRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UtilitiesApi - object-oriented interface
 * @export
 * @class UtilitiesApi
 * @extends {BaseAPI}
 */
export class UtilitiesApi extends BaseAPI {
    /**
     * Export a larger data set to a file in the File Library
     * @summary Export Items
     * @param {string} collection Collection identifier
     * @param {ExportRequest} [exportRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UtilitiesApi
     */
    public _export(collection: string, exportRequest?: ExportRequest, options?: AxiosRequestConfig) {
        return UtilitiesApiFp(this.configuration)._export(collection, exportRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Import multiple records from a JSON or CSV file into a collection.
     * @summary Import Items
     * @param {string} collection Collection identifier
     * @param {any} [file] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UtilitiesApi
     */
    public _import(collection: string, file?: any, options?: AxiosRequestConfig) {
        return UtilitiesApiFp(this.configuration)._import(collection, file, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Resets both the data and schema cache of Directus.
     * @summary Clear Cache
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UtilitiesApi
     */
    public clearCache(options?: AxiosRequestConfig) {
        return UtilitiesApiFp(this.configuration).clearCache(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Generate a hash for a given string.
     * @summary Hash a string
     * @param {HashGenerateRequest} [hashGenerateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UtilitiesApi
     */
    public hashGenerate(hashGenerateRequest?: HashGenerateRequest, options?: AxiosRequestConfig) {
        return UtilitiesApiFp(this.configuration).hashGenerate(hashGenerateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Generate a hash for a given string.
     * @summary Hash a string
     * @param {HashVerifyRequest} [hashVerifyRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UtilitiesApi
     */
    public hashVerify(hashVerifyRequest?: HashVerifyRequest, options?: AxiosRequestConfig) {
        return UtilitiesApiFp(this.configuration).hashVerify(hashVerifyRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a random string of given length.
     * @summary Get a Random String
     * @param {number} [length] Length of the random string.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UtilitiesApi
     */
    public random(length?: number, options?: AxiosRequestConfig) {
        return UtilitiesApiFp(this.configuration).random(length, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Re-sort items in collection based on start and to value of item
     * @summary Sort Items
     * @param {string} collection Collection identifier
     * @param {SortRequest} [sortRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UtilitiesApi
     */
    public sort(collection: string, sortRequest?: SortRequest, options?: AxiosRequestConfig) {
        return UtilitiesApiFp(this.configuration).sort(collection, sortRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


